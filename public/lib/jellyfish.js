(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.srcjellyfish || (g.srcjellyfish = {})).js = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":1,"buffer":3,"ieee754":5}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],5:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],6:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],7:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],8:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],9:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":3}],10:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":4,"inherits":6,"readable-stream/lib/_stream_duplex.js":12,"readable-stream/lib/_stream_passthrough.js":13,"readable-stream/lib/_stream_readable.js":14,"readable-stream/lib/_stream_transform.js":15,"readable-stream/lib/_stream_writable.js":16,"readable-stream/lib/internal/streams/end-of-stream.js":20,"readable-stream/lib/internal/streams/pipeline.js":22}],11:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],12:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":14,"./_stream_writable":16,"_process":8,"inherits":6}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":15,"inherits":6}],14:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":11,"./_stream_duplex":12,"./internal/streams/async_iterator":17,"./internal/streams/buffer_list":18,"./internal/streams/destroy":19,"./internal/streams/from":21,"./internal/streams/state":23,"./internal/streams/stream":24,"_process":8,"buffer":3,"events":4,"inherits":6,"string_decoder/":25,"util":2}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":11,"./_stream_duplex":12,"inherits":6}],16:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":11,"./_stream_duplex":12,"./internal/streams/destroy":19,"./internal/streams/state":23,"./internal/streams/stream":24,"_process":8,"buffer":3,"inherits":6,"util-deprecate":27}],17:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":20,"_process":8}],18:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":3,"util":2}],19:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":8}],20:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":11}],21:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],22:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":11,"./end-of-stream":20}],23:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":11}],24:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":4}],25:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":9}],26:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":8,"timers":26}],27:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownTypeAddress = exports.Address = void 0;
class Address {
    constructor(network, utf8String, valid, type) {
        this.network = network;
        this.utf8String = utf8String;
        this.valid = valid;
        this.type = type;
        this.validatorPassed = 0;
    }
    validate() {
        this.valid = true;
        this.validatorPassed = 0;
        this.validators().forEach((validator, index) => {
            const passed = validator();
            this.valid = this.valid && passed;
            if (passed) {
                this.validatorPassed += 1;
            }
        });
        return this.valid;
    }
}
exports.Address = Address;
/**
 * Default Address implementation when parsed address do not matched any type
 */
class UnknownTypeAddress extends Address {
    constructor(network, raw) {
        super(network, raw, false, 'Unknown');
    }
    validators() {
        return [];
    }
    validate() {
        return false;
    }
    getScript() {
        throw new Error('InvalidDeFiAddress');
    }
}
exports.UnknownTypeAddress = UnknownTypeAddress;

},{}],29:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base58Address = void 0;
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const address_1 = require("./address");
class Base58Address extends address_1.Address {
    constructor(network, utf8String, hex, valid, type) {
        super(network, utf8String, valid, type);
        this.hex = hex;
    }
    validators() {
        return [
            () => (this.utf8String.length >= Base58Address.MIN_LENGTH),
            () => (this.utf8String.length <= Base58Address.MAX_LENGTH),
            () => {
                const charset = '[1-9A-HJ-NP-Za-km-z]';
                return new RegExp(`${charset}{${this.utf8String.length}}$`).test(this.utf8String);
            },
            () => {
                try {
                    const { prefix } = jellyfish_crypto_1.Bs58.toHash160(this.utf8String); // built in checksum check
                    return prefix === this.getPrefix();
                }
                catch (e) {
                    return false;
                }
            },
            () => {
                try {
                    const { buffer } = jellyfish_crypto_1.Bs58.toHash160(this.utf8String); // built in checksum check
                    return buffer.toString('hex') === this.hex;
                }
                catch (e) {
                    return false;
                }
            }
        ];
    }
    getPrefixString() {
        return Buffer.from([this.getPrefix()]).toString('hex');
    }
    static fromAddress(network, utf8String, AddressClass) {
        try {
            const { buffer } = jellyfish_crypto_1.Bs58.toHash160(utf8String);
            return new AddressClass(network, utf8String, buffer.toString('hex'));
        }
        catch (e) {
            // non b58 string, invalid address
            return new AddressClass(network, utf8String, '', false, 'Unknown');
        }
    }
}
exports.Base58Address = Base58Address;
Base58Address.MIN_LENGTH = 26;
Base58Address.MAX_LENGTH = 35;
Base58Address.DATA_HEX_LENGTH = 40; // hex char count

}).call(this)}).call(this,require("buffer").Buffer)
},{"./address":28,"@defichain/jellyfish-crypto":71,"buffer":3}],30:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bech32Address = void 0;
const bech32_1 = require("bech32");
const address_1 = require("./address");
class Bech32Address extends address_1.Address {
    constructor(network, utf8String, valid, addressType) {
        super(network, utf8String.toLowerCase(), valid, addressType);
    }
    validators() {
        return [
            () => (new RegExp(`^${this.getHrp()}`).test(this.utf8String)),
            () => {
                const charset = '[02-9ac-hj-np-z]'; // 0-9, a-z, and reject: [1, b, i, o]
                const arr = this.utf8String.split('1');
                const excludeHrp = arr[arr.length - 1];
                const regex = new RegExp(`${charset}{${excludeHrp.length}}$`);
                return regex.test(excludeHrp);
            }
        ];
    }
    getHrp() {
        return this.network.bech32.hrp;
    }
    static fromAddress(network, raw, AddressClass) {
        let valid;
        let prefix;
        let data = '';
        try {
            const decoded = bech32_1.bech32.decode(raw);
            valid = true;
            prefix = decoded.prefix;
            const trimmedVersion = decoded.words.slice(1);
            data = Buffer.from(bech32_1.bech32.fromWords(trimmedVersion)).toString('hex');
            if (prefix !== network.bech32.hrp) {
                valid = false;
            }
        }
        catch (e) {
            valid = false;
        }
        return new AddressClass(network, raw, data, valid);
    }
}
exports.Bech32Address = Bech32Address;
Bech32Address.MAX_LENGTH = 90;
Bech32Address.MAX_HUMAN_READABLE_LENGTH = 83;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./address":28,"bech32":166,"buffer":3}],31:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeFiAddress = void 0;
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const address_1 = require("./address");
const base58_address_1 = require("./base58_address");
const bech32_address_1 = require("./bech32_address");
const p2pkh_1 = require("./p2pkh");
const p2sh_1 = require("./p2sh");
const p2wsh_1 = require("./p2wsh");
const p2wpkh_1 = require("./p2wpkh");
__exportStar(require("./address"), exports);
__exportStar(require("./base58_address"), exports);
__exportStar(require("./bech32_address"), exports);
__exportStar(require("./p2pkh"), exports);
__exportStar(require("./p2sh"), exports);
__exportStar(require("./p2wpkh"), exports);
__exportStar(require("./p2wsh"), exports);
/**
 * When insist to use the "network" decoded from raw address, instead of passing one based on running application environment
 * @param address raw human readable address (utf-8)
 * @returns DefiAddress or a child class
 *
 * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
 */
function guess(address) {
    const networks = ['mainnet', 'testnet', 'regtest'];
    const defaultOne = new address_1.UnknownTypeAddress(jellyfish_network_1.getNetwork('mainnet'), address);
    for (let i = 0; i < networks.length; i += 1) {
        const guessed = from(networks[i], address);
        if (guessed.valid) {
            return guessed;
        }
    }
    return defaultOne;
}
/**
 * @param net to be validated against the decoded one from the raw address
 * @param address raw human readable address (utf-8)
 * @returns DefiAddress or a child class
 *
 * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
 */
function from(net, address) {
    const network = jellyfish_network_1.getNetwork(net);
    const possible = new Map();
    possible.set('Unknown', new address_1.UnknownTypeAddress(network, address));
    possible.set('P2PKH', base58_address_1.Base58Address.fromAddress(network, address, p2pkh_1.P2PKH));
    possible.set('P2SH', base58_address_1.Base58Address.fromAddress(network, address, p2sh_1.P2SH));
    possible.set('P2WPKH', bech32_address_1.Bech32Address.fromAddress(network, address, p2wpkh_1.P2WPKH));
    possible.set('P2WSH', bech32_address_1.Bech32Address.fromAddress(network, address, p2wsh_1.P2WSH));
    possible.forEach(each => each.validate());
    let valid;
    possible.forEach(each => {
        if (each.valid) {
            valid = each;
        }
    });
    /* eslint-disable @typescript-eslint/strict-boolean-expressions */
    if (valid) {
        // find if any has all validator passed
        return valid;
    }
    // else select the closest guess (most validator passed)
    // default, when non have validator passed
    let highestKey = 'Unknown';
    let highestCount = 0;
    possible.forEach((val, key) => {
        if (val.validatorPassed > highestCount) {
            highestKey = key;
            highestCount = val.validatorPassed;
        }
    });
    return possible.get(highestKey);
}
/**
 * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
 */
exports.DeFiAddress = {
    /**
     * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
     */
    guess,
    /**
     * @deprecated use fromAddress(address: string, network: NetworkName | string) instead
     */
    from
};
__exportStar(require("./script"), exports);

},{"./address":28,"./base58_address":29,"./bech32_address":30,"./p2pkh":32,"./p2sh":33,"./p2wpkh":34,"./p2wsh":35,"./script":42,"@defichain/jellyfish-network":77}],32:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PKH = void 0;
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const base58_address_1 = require("./base58_address");
class P2PKH extends base58_address_1.Base58Address {
    constructor(network, utf8String, hex, validated = false) {
        super(network, utf8String, hex, validated, 'P2PKH');
    }
    getPrefix() {
        return this.network.pubKeyHashPrefix;
    }
    getScript() {
        if (!this.valid) {
            this.validate();
        }
        if (!this.valid) {
            throw new Error('InvalidDefiAddress');
        }
        return {
            stack: [
                jellyfish_transaction_1.OP_CODES.OP_DUP,
                jellyfish_transaction_1.OP_CODES.OP_HASH160,
                new jellyfish_transaction_1.OP_PUSHDATA(Buffer.from(this.hex, 'hex'), 'little'),
                jellyfish_transaction_1.OP_CODES.OP_EQUALVERIFY,
                jellyfish_transaction_1.OP_CODES.OP_CHECKSIG
            ]
        };
    }
    static to(net, h160) {
        if (h160.length !== base58_address_1.Base58Address.DATA_HEX_LENGTH) {
            throw new Error('InvalidDataLength');
        }
        const network = typeof net === 'string' ? jellyfish_network_1.getNetwork(net) : net;
        const address = jellyfish_crypto_1.Bs58.fromHash160(h160, network.pubKeyHashPrefix);
        return new P2PKH(network, address, h160, true);
    }
}
exports.P2PKH = P2PKH;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./base58_address":29,"@defichain/jellyfish-crypto":71,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"buffer":3}],33:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2SH = void 0;
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const base58_address_1 = require("./base58_address");
class P2SH extends base58_address_1.Base58Address {
    constructor(network, utf8String, hex, validated = false) {
        super(network, utf8String, hex, validated, 'P2SH');
    }
    getPrefix() {
        return this.network.scriptHashPrefix;
    }
    getScript() {
        if (!this.valid) {
            this.validate();
        }
        if (!this.valid) {
            throw new Error('InvalidDefiAddress');
        }
        return {
            stack: [
                jellyfish_transaction_1.OP_CODES.OP_HASH160,
                new jellyfish_transaction_1.OP_PUSHDATA(Buffer.from(this.hex, 'hex'), 'little'),
                jellyfish_transaction_1.OP_CODES.OP_EQUAL
            ]
        };
    }
    static to(net, h160) {
        if (h160.length !== base58_address_1.Base58Address.DATA_HEX_LENGTH) {
            throw new Error('InvalidDataLength');
        }
        const network = typeof net === 'string' ? jellyfish_network_1.getNetwork(net) : net;
        const address = jellyfish_crypto_1.Bs58.fromHash160(h160, network.scriptHashPrefix);
        return new P2SH(network, address, h160, true);
    }
}
exports.P2SH = P2SH;
P2SH.SCRIPT_HASH_LENGTH = 50; // 25 bytes, 50 char

}).call(this)}).call(this,require("buffer").Buffer)
},{"./base58_address":29,"@defichain/jellyfish-crypto":71,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"buffer":3}],34:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2WPKH = void 0;
const bech32_1 = require("bech32");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const bech32_address_1 = require("./bech32_address");
class P2WPKH extends bech32_address_1.Bech32Address {
    constructor(network, utf8String, pubKeyHash, validated = false) {
        super(network, utf8String, validated, 'P2WPKH');
        this.pubKeyHash = pubKeyHash;
    }
    validators() {
        const rawAdd = this.utf8String;
        return [
            ...super.validators(),
            () => (rawAdd.length <= P2WPKH.LENGTH_EXCLUDE_HRP + this.getHrp().length + 1),
            () => (rawAdd.length === P2WPKH.LENGTH_EXCLUDE_HRP + this.getHrp().length + 1),
            () => (this.pubKeyHash.length === P2WPKH.PUB_KEY_HASH_LENGTH)
        ];
    }
    getHrp() {
        return this.network.bech32.hrp;
    }
    getScript() {
        if (!this.valid) {
            this.validate();
        }
        if (!this.valid) {
            throw new Error('InvalidDefiAddress');
        }
        return {
            stack: [
                jellyfish_transaction_1.OP_CODES.OP_0,
                new jellyfish_transaction_1.OP_PUSHDATA(Buffer.from(this.pubKeyHash, 'hex'), 'little')
            ]
        };
    }
    /**
     * @param net network
     * @param hex data, public key hash (20 bytes, 40 characters)
     * @param witnessVersion default 0
     * @returns
     */
    static to(net, h160, witnessVersion = 0x00) {
        const network = typeof net === 'string' ? jellyfish_network_1.getNetwork(net) : net;
        if (h160.length !== P2WPKH.PUB_KEY_HASH_LENGTH) {
            throw new Error('InvalidPubKeyHashLength');
        }
        const numbers = Buffer.from(h160, 'hex');
        const fiveBitsWords = bech32_1.bech32.toWords(numbers);
        const includeVersion = [witnessVersion, ...fiveBitsWords];
        const utf8 = bech32_1.bech32.encode(network.bech32.hrp, includeVersion);
        return new P2WPKH(network, utf8, h160, true);
    }
}
exports.P2WPKH = P2WPKH;
P2WPKH.SAMPLE = 'bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq';
P2WPKH.LENGTH_EXCLUDE_HRP = 39; // exclude hrp and separator
P2WPKH.PUB_KEY_HASH_LENGTH = 40;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bech32_address":30,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"bech32":166,"buffer":3}],35:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2WSH = void 0;
const bech32_1 = require("bech32");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const bech32_address_1 = require("./bech32_address");
class P2WSH extends bech32_address_1.Bech32Address {
    constructor(network, utf8String, data, validated = false) {
        super(network, utf8String, validated, 'P2WSH');
        this.data = data;
    }
    // bcrt1ncd7qa2cafwv3cpw68vqczg3qj904k2f4lard4wrj50rzkwmagvs3ttd5f
    validators() {
        return [
            ...super.validators(),
            () => (this.utf8String.length <= P2WSH.MAX_LENGTH),
            () => (this.data.length === P2WSH.SCRIPT_HASH_LENGTH)
        ];
    }
    getScript() {
        if (!this.valid) {
            this.validate();
        }
        if (!this.valid) {
            throw new Error('InvalidDefiAddress');
        }
        return {
            stack: [
                jellyfish_transaction_1.OP_CODES.OP_0,
                new jellyfish_transaction_1.OP_PUSHDATA(Buffer.from(this.data, 'hex'), 'little')
            ]
        };
    }
    /**
     * @param net network
     * @param hex data, redeem script (32 bytes, 64 characters)
     * @param witnessVersion default 0
     * @returns
     */
    static to(net, hex, witnessVersion = 0x00) {
        const network = typeof net === 'string' ? jellyfish_network_1.getNetwork(net) : net;
        if (hex.length !== P2WSH.SCRIPT_HASH_LENGTH) {
            throw new Error('InvalidScriptHashLength');
        }
        const numbers = Buffer.from(hex, 'hex');
        const fiveBitsWords = bech32_1.bech32.toWords(numbers);
        const includeVersion = [witnessVersion, ...fiveBitsWords];
        const utf8 = bech32_1.bech32.encode(network.bech32.hrp, includeVersion);
        return new P2WSH(network, utf8, hex, true);
    }
}
exports.P2WSH = P2WSH;
// the raw utf8, eg bc1...
// supposed to be 62, regtest prefix is longer
P2WSH.MAX_LENGTH = 64;
P2WSH.SCRIPT_HASH_LENGTH = 64;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bech32_address":30,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"bech32":166,"buffer":3}],36:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBase58Check = exports.toBase58Check = void 0;
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const bs58_1 = __importDefault(require("bs58"));
/**
 * @param {Buffer} bytes 21 bytes
 */
function _checksum(bytes) {
    return jellyfish_crypto_1.SHA256(jellyfish_crypto_1.SHA256(bytes)).slice(0, 4);
}
/**
 * Base58 with Checksum for P2SH and P2PKH addresses.
 *
 * @param {Buffer} buffer 20 bytes Buffer (Hash160)
 * @param {number} prefix 1 byte length network prefix
 * @returns string base58check encoded address
 */
function toBase58Check(buffer, prefix) {
    if (buffer.length !== 20) {
        throw new Error('Base58Check buffer length must be 20');
    }
    const prefixed = Buffer.from([
        ...Buffer.alloc(1, prefix),
        ...buffer
    ]);
    const prefixedChecked = Buffer.from([
        ...prefixed,
        ..._checksum(prefixed)
    ]);
    return bs58_1.default.encode(prefixedChecked);
}
exports.toBase58Check = toBase58Check;
function fromBase58Check(address) {
    const buffer = bs58_1.default.decode(address);
    if (buffer.length !== 25) {
        throw new Error('Invalid Base58Check address, length != 25');
    }
    const prefixed = buffer.slice(0, 21);
    const checksum = buffer.slice(21, 25);
    const expectedChecksum = _checksum(prefixed);
    if (checksum.compare(expectedChecksum) !== 0) {
        throw new Error('Invalid Base58Check address, checksum invalid');
    }
    return {
        prefix: prefixed[0],
        buffer: prefixed.slice(1, 21)
    };
}
exports.fromBase58Check = fromBase58Check;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@defichain/jellyfish-crypto":71,"bs58":194,"buffer":3}],37:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBech32 = exports.toBech32 = void 0;
const bech32_1 = require("bech32");
/**
 * @param {Buffer} buffer to format into bech32, len 20 = p2wpkh, len 32 = p2wsh
 * @param {Network['bech32']['hrp']} hrp is the human readable part to prefix
 * @param {number} [version] witness version, OP_0
 * @return {string} bech32 encoded address
 * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 */
function toBech32(buffer, hrp, version) {
    if (buffer.length !== 20 && buffer.length !== 32) {
        throw new TypeError('Bech32 buffer length must be either 20 or 32');
    }
    const words = bech32_1.bech32.toWords(buffer);
    words.unshift(version);
    return bech32_1.bech32.encode(hrp, words);
}
exports.toBech32 = toBech32;
function fromBech32(address) {
    const { prefix, words } = bech32_1.bech32.decode(address);
    const version = words.splice(0, 1)[0];
    const buffer = Buffer.from(bech32_1.bech32.fromWords(words));
    return {
        buffer: buffer,
        hrp: prefix,
        version: version
    };
}
exports.fromBech32 = fromBech32;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bech32":166,"buffer":3}],38:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBase58CheckP2PKH = exports.fromScriptP2PKH = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const Base58Check_1 = require("./Base58Check");
function isScriptP2PKH(script) {
    return script.stack.length === 5 &&
        script.stack[0].type === jellyfish_transaction_1.OP_CODES.OP_DUP.type &&
        script.stack[1].type === jellyfish_transaction_1.OP_CODES.OP_HASH160.type &&
        script.stack[2].type === 'OP_PUSHDATA' && script.stack[2].length() === 20 &&
        script.stack[3].type === jellyfish_transaction_1.OP_CODES.OP_EQUALVERIFY.type &&
        script.stack[4].type === jellyfish_transaction_1.OP_CODES.OP_CHECKSIG.type;
}
function fromScriptP2PKH(script, network) {
    if (!isScriptP2PKH(script)) {
        return undefined;
    }
    const hash = script.stack[2];
    const buffer = Buffer.from(hash.hex, 'hex');
    const prefix = jellyfish_network_1.getNetwork(network).pubKeyHashPrefix;
    return Base58Check_1.toBase58Check(buffer, prefix);
}
exports.fromScriptP2PKH = fromScriptP2PKH;
function isBase58CheckP2PKH(decoded, network) {
    return decoded.prefix === jellyfish_network_1.getNetwork(network).pubKeyHashPrefix &&
        decoded.buffer.length === 20;
}
function fromBase58CheckP2PKH(decoded, network) {
    if (!isBase58CheckP2PKH(decoded, network)) {
        return undefined;
    }
    return {
        stack: [
            jellyfish_transaction_1.OP_CODES.OP_DUP,
            jellyfish_transaction_1.OP_CODES.OP_HASH160,
            jellyfish_transaction_1.OP_CODES.OP_PUSHDATA(Buffer.from(decoded.buffer), 'little'),
            jellyfish_transaction_1.OP_CODES.OP_EQUALVERIFY,
            jellyfish_transaction_1.OP_CODES.OP_CHECKSIG
        ]
    };
}
exports.fromBase58CheckP2PKH = fromBase58CheckP2PKH;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./Base58Check":36,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"buffer":3}],39:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBase58CheckP2SH = exports.fromScriptP2SH = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const Base58Check_1 = require("./Base58Check");
function isScriptP2SH(script) {
    return script.stack.length === 3 &&
        script.stack[0].type === jellyfish_transaction_1.OP_CODES.OP_HASH160.type &&
        script.stack[1].type === 'OP_PUSHDATA' && script.stack[1].length() === 20 &&
        script.stack[2].type === jellyfish_transaction_1.OP_CODES.OP_EQUAL.type;
}
function fromScriptP2SH(script, network) {
    if (!isScriptP2SH(script)) {
        return undefined;
    }
    const hash = script.stack[1];
    const buffer = Buffer.from(hash.hex, 'hex');
    const prefix = jellyfish_network_1.getNetwork(network).scriptHashPrefix;
    return Base58Check_1.toBase58Check(buffer, prefix);
}
exports.fromScriptP2SH = fromScriptP2SH;
function isBase58CheckP2SH(decoded, network) {
    return decoded.prefix === jellyfish_network_1.getNetwork(network).scriptHashPrefix &&
        decoded.buffer.length === 20;
}
function fromBase58CheckP2SH(decoded, network) {
    if (!isBase58CheckP2SH(decoded, network)) {
        return undefined;
    }
    return {
        stack: [
            jellyfish_transaction_1.OP_CODES.OP_HASH160,
            jellyfish_transaction_1.OP_CODES.OP_PUSHDATA(Buffer.from(decoded.buffer), 'little'),
            jellyfish_transaction_1.OP_CODES.OP_EQUAL
        ]
    };
}
exports.fromBase58CheckP2SH = fromBase58CheckP2SH;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./Base58Check":36,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"buffer":3}],40:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBech32P2WPKH = exports.fromScriptP2WPKH = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const Bech32_1 = require("./Bech32");
function isScriptP2WPKH(script) {
    return script.stack.length === 2 &&
        script.stack[0].type === jellyfish_transaction_1.OP_CODES.OP_0.type &&
        script.stack[1].type === 'OP_PUSHDATA' && script.stack[1].length() === 20;
}
function fromScriptP2WPKH(script, network) {
    if (!isScriptP2WPKH(script)) {
        return undefined;
    }
    const hash = script.stack[1];
    const buffer = Buffer.from(hash.hex, 'hex');
    const hrp = jellyfish_network_1.getNetwork(network).bech32.hrp;
    return Bech32_1.toBech32(buffer, hrp, 0x00);
}
exports.fromScriptP2WPKH = fromScriptP2WPKH;
function isBech32P2WPKH(decoded, network) {
    return decoded.hrp === jellyfish_network_1.getNetwork(network).bech32.hrp &&
        decoded.version === 0x00 &&
        decoded.buffer.length === 20;
}
function fromBech32P2WPKH(decoded, network) {
    if (!isBech32P2WPKH(decoded, network)) {
        return undefined;
    }
    return {
        stack: [
            jellyfish_transaction_1.OP_CODES.OP_0,
            jellyfish_transaction_1.OP_CODES.OP_PUSHDATA(Buffer.from(decoded.buffer), 'little')
        ]
    };
}
exports.fromBech32P2WPKH = fromBech32P2WPKH;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./Bech32":37,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"buffer":3}],41:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBech32P2WSH = exports.fromScriptP2WSH = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_network_1 = require("@defichain/jellyfish-network");
const Bech32_1 = require("./Bech32");
function isScriptP2WSH(script) {
    return script.stack.length === 2 &&
        script.stack[0].type === jellyfish_transaction_1.OP_CODES.OP_0.type &&
        script.stack[1].type === 'OP_PUSHDATA' && script.stack[1].length() === 32;
}
function fromScriptP2WSH(script, network) {
    if (!isScriptP2WSH(script)) {
        return undefined;
    }
    const hash = script.stack[1];
    const buffer = Buffer.from(hash.hex, 'hex');
    const hrp = jellyfish_network_1.getNetwork(network).bech32.hrp;
    return Bech32_1.toBech32(buffer, hrp, 0x00);
}
exports.fromScriptP2WSH = fromScriptP2WSH;
function isBech32P2WSH(decoded, network) {
    return decoded.hrp === jellyfish_network_1.getNetwork(network).bech32.hrp &&
        decoded.version === 0x00 &&
        decoded.buffer.length === 32;
}
function fromBech32P2WSH(decoded, network) {
    if (!isBech32P2WSH(decoded, network)) {
        return undefined;
    }
    return {
        stack: [
            jellyfish_transaction_1.OP_CODES.OP_0,
            jellyfish_transaction_1.OP_CODES.OP_PUSHDATA(Buffer.from(decoded.buffer), 'little')
        ]
    };
}
exports.fromBech32P2WSH = fromBech32P2WSH;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./Bech32":37,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"buffer":3}],42:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromScriptHex = exports.fromScript = exports.fromAddress = exports.AddressType = void 0;
const smart_buffer_1 = require("smart-buffer");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const P2WPKH_1 = require("./P2WPKH");
const P2WSH_1 = require("./P2WSH");
const P2SH_1 = require("./P2SH");
const P2PKH_1 = require("./P2PKH");
const Bech32_1 = require("./Bech32");
const Base58Check_1 = require("./Base58Check");
/**
 * Known Address Types
 */
var AddressType;
(function (AddressType) {
    /**
     * Pay to Witness Public Key Hash
     * Native SEGWIT with Bech32
     */
    AddressType["P2WPKH"] = "P2WPKH";
    /**
     * Pay to Witness Script Hash
     * Native SEGWIT with Bech32
     */
    AddressType["P2WSH"] = "P2WSH";
    /**
     * Pay to Script Hash
     */
    AddressType["P2SH"] = "P2SH";
    /**
     * Pay to Public Key Hash
     * Also known as legacy
     */
    AddressType["P2PKH"] = "P2PKH";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
/**
 * Convert an address to a script, this operation requires the network to be known.
 * A script is network agnostic while the address is prefixed with the network's unique human readable part.
 *
 * @param {string} address to convert into Script
 * @param {NetworkName} network to prefix human readable part of the address
 * @return {DecodedAddress | undefined} DecodedAddress if is a recognizable, undefined if fail to parse
 */
function fromAddress(address, network) {
    try {
        const decodedBech32 = Bech32_1.fromBech32(address);
        const p2wpkh = P2WPKH_1.fromBech32P2WPKH(decodedBech32, network);
        if (p2wpkh !== undefined) {
            return {
                type: AddressType.P2WPKH,
                address: address,
                script: p2wpkh,
                network: network
            };
        }
        const p2wsh = P2WSH_1.fromBech32P2WSH(decodedBech32, network);
        if (p2wsh !== undefined) {
            return {
                type: AddressType.P2WSH,
                address: address,
                script: p2wsh,
                network: network
            };
        }
    }
    catch (err) {
    }
    try {
        const decodedBase58Check = Base58Check_1.fromBase58Check(address);
        const p2pkh = P2PKH_1.fromBase58CheckP2PKH(decodedBase58Check, network);
        if (p2pkh !== undefined) {
            return {
                type: AddressType.P2PKH,
                address: address,
                script: p2pkh,
                network: network
            };
        }
        const p2sh = P2SH_1.fromBase58CheckP2SH(decodedBase58Check, network);
        if (p2sh !== undefined) {
            return {
                type: AddressType.P2SH,
                address: address,
                script: p2sh,
                network: network
            };
        }
    }
    catch (err) {
    }
    return undefined;
}
exports.fromAddress = fromAddress;
/**
 * Convert a script to address, this operation requires the network to be known.
 * A script is network agnostic while the address is prefixed with the network's unique human readable part.
 *
 * @param {Script} script to convert into address
 * @param {NetworkName} network to prefix human readable part of the address
 * @return {DecodedAddress | undefined} DecodedAddress if is a recognizable, undefined if fail to parse
 */
function fromScript(script, network) {
    const p2wpkh = P2WPKH_1.fromScriptP2WPKH(script, network);
    if (p2wpkh !== undefined) {
        return {
            type: AddressType.P2WPKH,
            address: p2wpkh,
            script: script,
            network: network
        };
    }
    const p2wsh = P2WSH_1.fromScriptP2WSH(script, network);
    if (p2wsh !== undefined) {
        return {
            type: AddressType.P2WSH,
            address: p2wsh,
            script: script,
            network: network
        };
    }
    const p2pkh = P2PKH_1.fromScriptP2PKH(script, network);
    if (p2pkh !== undefined) {
        return {
            type: AddressType.P2PKH,
            address: p2pkh,
            script: script,
            network: network
        };
    }
    const p2sh = P2SH_1.fromScriptP2SH(script, network);
    if (p2sh !== undefined) {
        return {
            type: AddressType.P2SH,
            address: p2sh,
            script: script,
            network: network
        };
    }
    return undefined;
}
exports.fromScript = fromScript;
/**
 * Convert a script to address, this operation requires the network to be known.
 * A script is network agnostic while the address is prefixed with the network's unique human readable part.
 *
 * @param {string} hex of the script to convert into address, without VarUInt length
 * @param {NetworkName} network to prefix human readable part of the address
 * @return {DecodedAddress | undefined} DecodedAddress if is a recognizable, undefined if fail to parse
 */
function fromScriptHex(hex, network) {
    const buffer = Buffer.from(hex, 'hex');
    const script = {
        stack: jellyfish_transaction_1.toOPCodes(smart_buffer_1.SmartBuffer.fromBuffer(buffer))
    };
    return fromScript(script, network);
}
exports.fromScriptHex = fromScriptHex;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./Base58Check":36,"./Bech32":37,"./P2PKH":38,"./P2SH":39,"./P2WPKH":40,"./P2WSH":41,"@defichain/jellyfish-transaction":94,"buffer":3,"smart-buffer":273}],43:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = exports.SelectionModeType = exports.DfTxType = exports.OwnerType = void 0;
/**
 * Single account ID (CScript or address) or reserved words,
 * - 'mine' to list history for all owned accounts or
 * - 'all' to list the whole DB
 */
var OwnerType;
(function (OwnerType) {
    OwnerType["MINE"] = "mine";
    OwnerType["ALL"] = "all";
})(OwnerType = exports.OwnerType || (exports.OwnerType = {}));
var DfTxType;
(function (DfTxType) {
    DfTxType["MINT_TOKEN"] = "M";
    DfTxType["POOL_SWAP"] = "s";
    DfTxType["ADD_POOL_LIQUIDITY"] = "l";
    DfTxType["REMOVE_POOL_LIQUIDITY"] = "r";
    DfTxType["UTXOS_TO_ACCOUNT"] = "U";
    DfTxType["ACCOUNT_TO_UTXOS"] = "b";
    DfTxType["ACCOUNT_TO_ACCOUNT"] = "B";
    DfTxType["ANY_ACCOUNTS_TO_ACCOUNTS"] = "a";
    DfTxType["CREATE_MASTERNODE"] = "C";
    DfTxType["RESIGN_MASTERNODE"] = "R";
    DfTxType["CREATE_TOKEN"] = "T";
    DfTxType["UPDATE_TOKEN"] = "N";
    DfTxType["UPDATE_TOKEN_ANY"] = "n";
    DfTxType["CREATE_POOL_PAIR"] = "p";
    DfTxType["UPDATE_POOL_PAIR"] = "u";
    DfTxType["SET_GOV_VARIABLE"] = "G";
    DfTxType["AUTO_AUTH_PREP"] = "A";
    DfTxType["NONE"] = "0";
})(DfTxType = exports.DfTxType || (exports.DfTxType = {}));
var SelectionModeType;
(function (SelectionModeType) {
    SelectionModeType["PIE"] = "pie";
    SelectionModeType["CRUMBS"] = "crumbs";
    SelectionModeType["FORWARD"] = "forward";
})(SelectionModeType = exports.SelectionModeType || (exports.SelectionModeType = {}));
/**
 * Account RPCs for DeFi Blockchain
 */
class Account {
    constructor(client) {
        this.client = client;
    }
    listAccounts(pagination = { limit: 100 }, verbose = true, options = { indexedAmounts: false, isMineOnly: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { indexedAmounts, isMineOnly } = options;
            return yield this.client.call('listaccounts', [pagination, verbose, indexedAmounts, isMineOnly], 'bignumber');
        });
    }
    getAccount(owner, pagination = { limit: 100 }, options = { indexedAmounts: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { indexedAmounts = false } = options;
            return yield this.client.call('getaccount', [owner, pagination, indexedAmounts], 'number');
        });
    }
    getTokenBalances(pagination = { limit: 100 }, indexedAmounts = false, options = { symbolLookup: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { symbolLookup } = options;
            return yield this.client.call('gettokenbalances', [pagination, indexedAmounts, symbolLookup], 'bignumber');
        });
    }
    /**
     * Create a UTXOs to Account transaction submitted to a connected node.
     * Optionally, specific UTXOs to spend to create that transaction.
     *
     * @param {BalanceTransferPayload} payload
     * @param {string} payload[address]
     * @param {UTXO[]} [utxos = []]
     * @param {string} [utxos.txid]
     * @param {number} [utxos.vout]
     * @return {Promise<string>}
     */
    utxosToAccount(payload, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('utxostoaccount', [payload, utxos], 'number');
        });
    }
    /**
     * Create an Account to Account transaction submitted to a connected node.
     * Optionally, specific UTXOs to spend to create that transaction.
     *
     * @param {string} from
     * @param {BalanceTransferPayload} payload
     * @param {string} payload[address]
     * @param {BalanceTransferAccountOptions} [options]
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>}
     */
    accountToAccount(from, payload, options = { utxos: [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('accounttoaccount', [from, payload, options.utxos], 'number');
        });
    }
    /**
     * Create an Account to UTXOS transaction submitted to a connected node.
     * Optionally, specific UTXOs to spend to create that transaction.
     *
     * @param {string} from
     * @param {BalanceTransferPayload} payload
     * @param {string} payload[address]
     * @param {BalanceTransferAccountOptions} [options]
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>}
     */
    accountToUtxos(from, payload, options = { utxos: [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('accounttoutxos', [from, payload, options.utxos], 'number');
        });
    }
    /**
     * Returns information about account history
     *
     * @param {OwnerType | string} [owner=OwnerType.MINE] single account ID (CScript or address) or reserved words 'mine' to list history for all owned accounts or 'all' to list whole DB
     * @param {AccountHistoryOptions} [options]
     * @param {number} [options.maxBlockHeight] Optional height to iterate from (down to genesis block), (default = chaintip).
     * @param {number} [options.depth] Maximum depth, from the genesis block is the default
     * @param {boolean} [options.no_rewards] Filter out rewards
     * @param {string} [options.token] Filter by token
     * @param {DfTxType} [options.txtype] Filter by transaction type. See DfTxType.
     * @param {number} [options.limit=100] Maximum number of records to return, 100 by default
     * @return {Promise<AccountHistory[]>}
     */
    listAccountHistory(owner = OwnerType.MINE, options = {
        limit: 100
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listaccounthistory', [owner, options], 'number');
        });
    }
    /**
     * Returns count of account history
     *
     * @param {OwnerType | string} [owner=OwnerType.MINE] single account ID (CScript or address) or reserved words 'mine' to list history count for all owned accounts or 'all' to list whole DB
     * @param {AccountHistoryCountOptions} [options]
     * @param {boolean} [options.no_rewards] Filter out rewards
     * @param {string} [options.token] Filter by token
     * @param {DfTxType} [options.txtype] Filter by transaction type. See DfTxType.
     * @return {Promise<number>} count of account history
     */
    historyCount(owner = OwnerType.MINE, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('accounthistorycount', [owner, options], 'number');
        });
    }
    /**
     * Creates a transfer transaction from your accounts balances.
     *
     * @param {AddressBalances} from source address as the key, the value is amount formatted as amount@token
     * @param {AddressBalances} to address as the key, the value is amount formatted as amount@token
     * @param {SendTokensOptions} [options = { selectionMode: SelectionModeType.PIE }]
     * @param {SelectionModeType} [options.selectionMode] Account selection mode. If "from" param is empty, it will auto select.
     * @return {Promise<string>}
     */
    sendTokensToAddress(from, to, options = { selectionMode: SelectionModeType.PIE }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('sendtokenstoaddress', [from, to, options.selectionMode], 'number');
        });
    }
    /**
     * Returns information about current anchor bonus, incentive funding, burnt token(s)
     *
     * @return {Promise<CommunityBalanceData>}
     */
    listCommunityBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listcommunitybalances', [], 'bignumber');
        });
    }
    /**
     * Returns information about burn history
     *
     * @param {BurnHistoryOptions} [options]
     * @param {number} [options.maxBlockHeight]  The block height to iterate from.
     * @param {number} [options.depth] Maximum depth, from the genesis block is the default
     * @param {string} [options.token] Filter by token
     * @param {DfTxType} [options.txtype] Filter by transaction type. See DfTxType.
     * @param {number} [options.limit=100] Maximum number of records to return, 100 by default
     * @return {Promise<BurnHistory[]>}
     */
    listBurnHistory(options = {
        limit: 100
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listburnhistory', [options], 'number');
        });
    }
    /**
     * Returns burn address, burnt coin and token information.
     * Requires full acindex for correct amount, tokens and feeburn values.
     *
     * @return {Promise<BurnInfo>}
     */
    getBurnInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getburninfo', [], 'bignumber');
        });
    }
}
exports.Account = Account;

},{}],44:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = void 0;
/**
 * Blockchain RPCs for DeFi Blockchain
 */
class Blockchain {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get various state info regarding blockchain processing.
     *
     * @return {Promise<BlockchainInfo>}
     */
    getBlockchainInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockchaininfo', [], 'number');
        });
    }
    /**
     * Get a hash of block in best-block-chain at height provided.
     *
     * @param {number} height
     * @return {Promise<string>}
     */
    getBlockHash(height) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockhash', [height], 'number');
        });
    }
    /**
     * Get the height of the most-work fully-validated chain.
     *
     * @return {Promise<number>}
     */
    getBlockCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockcount', [], 'number');
        });
    }
    getBlock(hash, verbosity) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblock', [hash, verbosity], verbosity === 2
                ? {
                    tx: {
                        vout: {
                            value: 'bignumber'
                        }
                    }
                }
                : 'number');
        });
    }
    getBlockHeader(hash, verbosity) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockheader', [hash, verbosity], 'number');
        });
    }
    /**
     * Return information about all known tips in the block tree
     * including the main chain as well as orphaned branches.
     *
     * @return {Promise<ChainTip[]>}
     */
    getChainTips() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getchaintips', [], 'number');
        });
    }
    /**
     * Get the proof-of-work difficulty as a multiple of the minimum difficulty.
     *
     * @return {Promise<number>}
     */
    getDifficulty() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getdifficulty', [], 'number');
        });
    }
    /**
     * Get details of unspent transaction output (UTXO).
     *
     * @param {string} txId the transaction id
     * @param {number} index vout number
     * @param {boolean} includeMempool default true, whether to include mempool
     * @return {Promise<UTXODetails>}
     */
    getTxOut(txId, index, includeMempool = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('gettxout', [
                txId, index, includeMempool
            ], {
                value: 'bignumber'
            });
        });
    }
    /**
     * Get all transaction ids in memory pool as string[] if verbose is false
     * else as json object
     *
     * @param {boolean} verbose default = false, true for json object, false for array of transaction ids
     * @return {Promise<string[] | MempoolTx>}
     */
    getRawMempool(verbose) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getrawmempool', [verbose], 'bignumber');
        });
    }
    /**
     * Get block statistics for a given window.
     *
     * @param {number} hashOrHeight  The block hash or height of the target block.
     * @param {Array<keyof BlockStats>} stats Default = all values. See BlockStats Interface.
     * @return {Promise<BlockStats>}
     */
    getBlockStats(hashOrHeight, stats) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getblockstats', [hashOrHeight, stats], 'number');
        });
    }
    /**
     * Get the hash of the best (tip) block in the most-work fully-validated chain.
     *
     * @returns {Promise<string>}
     */
    getBestBlockHash() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getbestblockhash', [], 'number');
        });
    }
    /**
     * Returns details on the active state of the TX memory pool.
     *
     * @return {Promise<MempoolInfo>}
     */
    getMempoolInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmempoolinfo', [], { mempoolminfee: 'bignumber', minrelaytxfee: 'bignumber' });
        });
    }
    /**
     * Wait for any new block
     *
     * @param {number} [timeout=30000] in millis
     * @return Promise<WaitBlockResult> the current block on timeout or exit
     */
    waitForNewBlock(timeout = 30000) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('waitfornewblock', [timeout], 'number');
        });
    }
    /**
     * Waits for block height equal or higher than provided and returns the height and hash of the current tip.
     *
     *
     * @param {number} height
     * @param {number} [timeout=30000] in millis
     * @return Promise<WaitBlockResult> the current block on timeout or exit
     */
    waitForBlockHeight(height, timeout = 30000) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('waitforblockheight', [height, timeout], 'number');
        });
    }
}
exports.Blockchain = Blockchain;

},{}],45:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Governance = exports.MasternodeType = exports.VoteDecision = exports.ListProposalsStatus = exports.ListProposalsType = exports.ProposalStatus = exports.ProposalType = void 0;
var ProposalType;
(function (ProposalType) {
    ProposalType["COMMUNITY_FUND_REQUEST"] = "CommunityFundRequest";
    ProposalType["BLOCK_REWARD_RELLOCATION"] = "BlockRewardRellocation";
    ProposalType["VOTE_OF_CONFIDENCE"] = "VoteOfConfidence";
})(ProposalType = exports.ProposalType || (exports.ProposalType = {}));
var ProposalStatus;
(function (ProposalStatus) {
    ProposalStatus["VOTING"] = "Voting";
    ProposalStatus["REJECTED"] = "Rejected";
    ProposalStatus["COMPLETED"] = "Completed";
})(ProposalStatus = exports.ProposalStatus || (exports.ProposalStatus = {}));
var ListProposalsType;
(function (ListProposalsType) {
    ListProposalsType["CFP"] = "cfp";
    ListProposalsType["BRP"] = "brp";
    ListProposalsType["VOC"] = "voc";
    ListProposalsType["ALL"] = "all";
})(ListProposalsType = exports.ListProposalsType || (exports.ListProposalsType = {}));
var ListProposalsStatus;
(function (ListProposalsStatus) {
    ListProposalsStatus["VOTING"] = "voting";
    ListProposalsStatus["REJECTED"] = "rejected";
    ListProposalsStatus["COMPLETED"] = "completed";
    ListProposalsStatus["ALL"] = "all";
})(ListProposalsStatus = exports.ListProposalsStatus || (exports.ListProposalsStatus = {}));
var VoteDecision;
(function (VoteDecision) {
    VoteDecision["YES"] = "yes";
    VoteDecision["NO"] = "no";
    VoteDecision["NEUTRAL"] = "neutral";
})(VoteDecision = exports.VoteDecision || (exports.VoteDecision = {}));
var MasternodeType;
(function (MasternodeType) {
    MasternodeType["MINE"] = "mine";
    MasternodeType["ALL"] = "all";
})(MasternodeType = exports.MasternodeType || (exports.MasternodeType = {}));
/**
 * Governance RPCs for DeFi Blockchain
 */
class Governance {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a Community Fund Request.
     *
     * @param {CFPData} data Community fund proposal data
     * @param {string} data.title Title of community fund request
     * @param {BigNumber} data.amount Amount per period
     * @param {string} data.payoutAddress Any valid address to receive the funds
     * @param {number} [data.cycles=1] Number of cycles for periodic fund request. Defaults to one cycle.
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} [utxos.txid] The transaction id
     * @param {number} [utxos.vout] The output number
     * @return {Promise<string>} txid
     */
    createCfp(data, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultData = {
                cycles: 1
            };
            return yield this.client.call('createcfp', [Object.assign(Object.assign({}, defaultData), data), utxos], 'number');
        });
    }
    /**
     * Returns information about the proposal.
     *
     * @param {string} proposalId Proposal id
     * @return {Promise<ProposalInfo>} Information about the proposal
     */
    getProposal(proposalId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getproposal', [proposalId], { amount: 'bignumber' });
        });
    }
    /**
     * Creates a Vote of Confidence.
     *
     * @param {string} title Vote of confidence's title
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} [utxos.txid] The transaction id
     * @param {number} [utxos.vout] The output number
     * @return {Promise<string>} txid
     */
    createVoc(title, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('createvoc', [title, utxos], 'number');
        });
    }
    /**
     * Returns list of proposals.
     *
     * @param {Object} options List proposal filter options
     * @param {ListProposalsType} [options.type=ListProposalsType.ALL] type of proposals
     * @param {ListProposalsStatus} [options.status=ListProposalsStatus.ALL] status of proposals
     * @return {Promise<ProposalInfo[]>}
     */
    listProposals({ type = ListProposalsType.ALL, status = ListProposalsStatus.ALL } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listproposals', [type, status], { amount: 'bignumber' });
        });
    }
    /**
     * Vote on a community proposal.
     *
     * @param {VoteData} data Vote data
     * @param {string} data.proposalId Proposal id
     * @param {number} data.masternodeId Masternode id
     * @param {VoteDecision} data.decision Vote decision. See VoteDecision.
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} [utxos.txid] The transaction id
     * @param {string} [utxos.vout] The output number
     * @return {Promise<string>} txid
     */
    vote(data, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('vote', [data.proposalId, data.masternodeId, data.decision, utxos], 'number');
        });
    }
    /**
     * Returns information about proposal votes.
     *
     * @param {string} proposalId Proposal id
     * @param {MasternodeType | string} [masternode=MasternodeType.MINE] masternode id or reserved words 'mine' to list votes for all owned accounts or 'all' to list all votes
     * @return {Promise<ListVotesResult[]>} Proposal vote information
     */
    listVotes(proposalId, masternode = MasternodeType.MINE) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listvotes', [proposalId, masternode], 'number');
        });
    }
}
exports.Governance = Governance;

},{}],46:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ICXHTLCStatus = exports.ICXHTLCType = exports.ICXOrderType = exports.ICXOrderStatus = exports.ICXOrderBook = void 0;
/**
 * icxorderbook RPCs for DeFi Blockchain
 */
class ICXOrderBook {
    constructor(client) {
        this.client = client;
    }
    /**
     * Create and submits an ICX order creation transaction.
     *
     * @param {ICXOrder} order
     * @param {string} [order.tokenFrom] Symbol or id of selling token
     * @param {string} [order.chainFrom] Symbol or id of selling chain
     * @param {string} [order.chainTo] Symbol or id of buying chain
     * @param {string} [order.tokenTo] Symbol or id of buying token
     * @param {string} [order.ownerAddress] Address of DFI token for fees and selling tokens in case of DFC/BTC order type
     * @param {string} [order.receivePubkey] pubkey which can claim external HTLC in case of EXT/DFC order type
     * @param {BigNumber} order.amountFrom tokenFrom coins amount
     * @param {BigNumber} order.orderPrice Price per unit
     * @param {number} [order.expiry=2880] Number of blocks until the order expires, default 2880 DFI blocks
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} utxos.txid transaction Id
     * @param {number} utxos.vout The output number
     * @return {Promise<ICXGenericResult>} Object including transaction id of the the result transaction
     */
    createOrder(order, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_createorder', [
                order, utxos
            ], 'bignumber');
        });
    }
    /**
     * Create and submits a makeoffer transaction.
     *
     * @param {ICXOffer} offer
     * @param {string} offer.orderTx Transaction id of the order tx for which is the offer
     * @param {BigNumber} offer.amount Amount fulfilling the order
     * @param {string} offer.ownerAddress Address of DFI token and for receiving tokens in case of EXT/DFC order
     * @param {string} [offer.receivePubkey] Pubkey which can claim external HTLC in case of EXT/DFC order type
     * @param {number} [order.expiry = 10] Number of blocks until the offer expires, default 10 DFI blocks
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} utxos.txid transaction Id
     * @param {number} utxos.vout The output number
     * @return {Promise<ICXGenericResult>} Object including transaction id of the the transaction
     */
    makeOffer(offer, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_makeoffer', [
                offer, utxos
            ], 'bignumber');
        });
    }
    /**
     * Closes offer transaction.
     *
     * @param {string} offerTx Transaction Id of maker offer
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} utxos.txid transaction Id
     * @param {number} utxos.vout The output number
     * @return {Promise<ICXGenericResult>} Object including transaction id of the the transaction
     */
    closeOffer(offerTx, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_closeoffer', [
                offerTx, utxos
            ], 'bignumber');
        });
    }
    /**
     * Create and submit a DFC HTLC transaction
     *
     * @param {HTLC} htlc
     * @param {string} htlc.offerTx Transaction Id of the offer transaction for which the HTLC is
     * @param {BigNumber} htlc.amount Amount in HTLC
     * @param {string} htlc.hash Hash of seed used for the hash lock part
     * @param {number} [htlc.timeout] Timeout (absolute in blocks) for expiration of HTLC in DFI blocks
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} utxos.txid transaction Id
     * @param {number} utxos.vout The output number
     * @return {Promise<ICXGenericResult>} Object including transaction id of the the transaction
     */
    submitDFCHTLC(htlc, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_submitdfchtlc', [
                htlc, utxos
            ], 'bignumber');
        });
    }
    /**
     * Create and submit an external(EXT) HTLC transaction
     *
     * @param {ExtHTLC} htlc
     * @param {string} htlc.offerTx Transaction Id of the offer transaction for which the HTLC is
     * @param {BigNumber} htlc.amount Amount in HTLC
     * @param {string} htlc.htlcScriptAddress Script address of external HTLC
     * @param {string} htlc.hash Hash of seed used for the hash lock part
     * @param {string} htlc.ownerPubkey Pubkey of the owner to which the funds are refunded if HTLC timeouts
     * @param {number} htlc.timeout Timeout (absolute in blocks) for expiration of HTLC in DFI blocks
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} utxos.txid transaction Id
     * @param {number} utxos.vout The output number
     * @return {Promise<ICXGenericResult>} Object including transaction id of the the transaction
     */
    submitExtHTLC(htlc, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_submitexthtlc', [
                htlc, utxos
            ], 'bignumber');
        });
    }
    /**
     * Claims a DFC HTLC
     *
     * @param {string} DFCHTLCTxId Transaction id of DFC HTLC transaction for which the claim is
     * @param {string} seed Secret seed for claiming HTLC
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} utxos.txid transaction Id
     * @param {number} utxos.vout The output number
     * @return {Promise<ICXGenericResult>} Object including transaction id of the the transaction
     */
    claimDFCHTLC(DFCHTLCTxId, seed, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const htlc = {
                dfchtlcTx: DFCHTLCTxId,
                seed: seed
            };
            return yield this.client.call('icx_claimdfchtlc', [
                htlc, utxos
            ], 'bignumber');
        });
    }
    /**
     * Closes ICX order
     *
     * @param {string} orderTx Transaction id of maker order
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} utxos.txid transaction Id
     * @param {number} utxos.vout The output number
     * @return {Promise<ICXGenericResult>} Object indluding transaction id of the the transaction
     */
    closeOrder(orderTx, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_closeorder', [
                orderTx, utxos
            ], 'bignumber');
        });
    }
    /**
     * Returns information about order or fillorder
     *
     * @param {string} orderTx Transaction id of createorder or fulfillorder transaction
     * @return {Promise<Record<string, ICXOrderInfo | ICXOfferInfo>>} Object including details of the transaction.
     */
    getOrder(orderTx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_getorder', [
                orderTx
            ], 'bignumber');
        });
    }
    /**
     * Returns information about orders or fillorders based on ICXListOrderOptions passed
     *
     * @param {ICXListOrderOptions} options
     * @param {string}  [options.token] Token asset
     * @param {string}  [options.chain] Chain asset
     * @param {string}  [options.orderTx] Order txid to list all offers for this order
     * @param {number}  [options.limit = 50] Maximum number of orders to return (default: 50)
     * @param {boolean} [options.closed = false] Display closed orders (default: false)
     * @return {Promise<Record<string, ICXOrderInfo | ICXOfferInfo>>} Object including details of the transaction.
     */
    listOrders(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_listorders', [
                options
            ], 'bignumber');
        });
    }
    /**
     * Returns information about HTLCs based on ICXListHTLCOptions passed
     *
     * @param {ICXListHTLCOptions} options
     * @param {string} options.offerTx Offer txid  for which to list all HTLCS
     * @param {number} [options.limit = 20] Maximum number of orders to return (default: 20)
     * @param {boolean} [options.refunded = false] Display refunded HTLC (default: false)
     * @param {boolean} [options.closed = false] Display claimed HTLCs (default: false)
     * @return {Promise<Record<string, ICXDFCHTLCInfo | ICXEXTHTLCInfo | ICXClaimDFCHTLCInfo>>} Object indluding details of the HTLCS.
     */
    listHTLCs(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('icx_listhtlcs', [
                options
            ], 'bignumber');
        });
    }
}
exports.ICXOrderBook = ICXOrderBook;
var ICXOrderStatus;
(function (ICXOrderStatus) {
    ICXOrderStatus["OPEN"] = "OPEN";
    ICXOrderStatus["CLOSED"] = "CLOSED";
    ICXOrderStatus["FILLED"] = "FILLED";
    ICXOrderStatus["EXPIRED"] = "EXPIRED";
})(ICXOrderStatus = exports.ICXOrderStatus || (exports.ICXOrderStatus = {}));
var ICXOrderType;
(function (ICXOrderType) {
    ICXOrderType["INTERNAL"] = "INTERNAL";
    ICXOrderType["EXTERNAL"] = "EXTERNAL";
})(ICXOrderType = exports.ICXOrderType || (exports.ICXOrderType = {}));
var ICXHTLCType;
(function (ICXHTLCType) {
    ICXHTLCType["CLAIM_DFC"] = "CLAIM DFC";
    ICXHTLCType["DFC"] = "DFC";
    ICXHTLCType["EXTERNAL"] = "EXTERNAL";
})(ICXHTLCType = exports.ICXHTLCType || (exports.ICXHTLCType = {}));
var ICXHTLCStatus;
(function (ICXHTLCStatus) {
    ICXHTLCStatus["OPEN"] = "OPEN";
    ICXHTLCStatus["CLAIMED"] = "CLAIMED";
    ICXHTLCStatus["REFUNDED"] = "REFUNDED";
    ICXHTLCStatus["EXPIRED"] = "EXPIRED";
    ICXHTLCStatus["CLOSED"] = "CLOSED";
})(ICXHTLCStatus = exports.ICXHTLCStatus || (exports.ICXHTLCStatus = {}));

},{}],47:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultState = exports.Loan = void 0;
/**
 * Loan RPCs for DeFi Blockchain
 */
class Loan {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a loan scheme transaction.
     *
     * @param {CreateLoanScheme} scheme
     * @param {number} scheme.minColRatio Minimum collateralization ratio
     * @param {BigNumber} scheme.interestRate Interest rate
     * @param {string} scheme.id Unique identifier of the loan scheme, max 8 chars
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} LoanSchemeId, also the txn id for txn created to create loan scheme
     */
    createLoanScheme(scheme, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('createloanscheme', [scheme.minColRatio, scheme.interestRate, scheme.id, utxos], 'number');
        });
    }
    /**
     * Updates an existing loan scheme.
     *
     * @param {UpdateLoanScheme} scheme
     * @param {number} scheme.minColRatio Minimum collateralization ratio
     * @param {BigNumber} scheme.interestRate Interest rate
     * @param {string} scheme.id Unique identifier of the loan scheme, max 8 chars
     * @param {number} [scheme.activateAfterBlock] Block height at which new changes take effect
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} Hex string of the transaction
     */
    updateLoanScheme(scheme, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('updateloanscheme', [scheme.minColRatio, scheme.interestRate, scheme.id, scheme.activateAfterBlock, utxos], 'number');
        });
    }
    /**
     * Destroys a loan scheme.
     *
     * @param {DestroyLoanScheme} scheme
     * @param {string} scheme.id Unique identifier of the loan scheme, max 8 chars
     * @param {number} [scheme.activateAfterBlock] Block height at which new changes take effect
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} Hex string of the transaction
     */
    destroyLoanScheme(scheme, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('destroyloanscheme', [scheme.id, scheme.activateAfterBlock, utxos], 'number');
        });
    }
    /**
     * List all available loan schemes.
     *
     * @return {Promise<LoanSchemeResult[]>}
     */
    listLoanSchemes() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listloanschemes', [], 'bignumber');
        });
    }
    /**
     * Get loan scheme.
     *
     * @param {string} id Unique identifier of the loan scheme, max 8 chars.
     * @return {Promise<GetLoanSchemeResult>}
     */
    getLoanScheme(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getloanscheme', [id], 'bignumber');
        });
    }
    /**
     * Sets the default loan scheme.
     *
     * @param {string} id Unique identifier of the loan scheme, max 8 chars
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} Hex string of the transaction
     */
    setDefaultLoanScheme(id, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setdefaultloanscheme', [id, utxos], 'number');
        });
    }
    /**
     * Set a collateral token transaction.
     *
     * @param {SetCollateralToken} collateralToken
     * @param {string} collateralToken.token Symbol or id of collateral token
     * @param {BigNumber} collateralToken.factor Collateralization factor
     * @param {string} collateralToken.fixedIntervalPriceId token/currency pair to use for price of token
     * @param {number} [collateralToken.activateAfterBlock] changes will be active after the block height
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} collateralTokenId, also the txn id for txn created to set collateral token
     */
    setCollateralToken(collateralToken, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setcollateraltoken', [collateralToken, utxos], 'number');
        });
    }
    /**
     * List collateral tokens.
     *
     * @param {ListCollateralTokens} [collateralToken = {}]
     * @param {number} [collateralToken.height = CurrentBlockheight] Valid at specified height
     * @param {boolean} [collateralToken.all] True = All transactions, false =  Activated transactions
     * @return {Promise<CollateralTokenDetail[]>} Get all collateral tokens
     */
    listCollateralTokens(collateralToken = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listcollateraltokens', [collateralToken], 'bignumber');
        });
    }
    /**
     * Get collateral token.
     *
     * @param {string} token symbol or id
     * @return {Promise<CollateralTokenDetail>} Collateral token result
     */
    getCollateralToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getcollateraltoken', [token], 'bignumber');
        });
    }
    /**
     * Creates (and submits to local node and network) a token for a price feed set in collateral token.
     *
     * @param {SetLoanToken} loanToken
     * @param {string} loanToken.symbol Token's symbol (unique), no longer than 8
     * @param {string} [loanToken.name] Token's name, no longer than 128
     * @param {string} loanToken.fixedIntervalPriceId token/currency pair to use for price of token
     * @param {boolean} [loanToken.mintable = true] Token's 'Mintable' property
     * @param {BigNumber} [loanToken.interest = 0] Interest rate
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} LoanTokenId, also the txn id for txn created to set loan token
     */
    setLoanToken(loanToken, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = Object.assign({ mintable: true, interest: 0 }, loanToken);
            return yield this.client.call('setloantoken', [payload, utxos], 'number');
        });
    }
    /**
     * Quick access to multiple API with consolidated total collateral and loan value.
     * @see {@link listCollateralTokens}
     * @see {@link listLoanTokens}
     * @see {@link listLoanSchemes}
     *
     * @returns {Promise<GetLoanInfoResult>}
     */
    getLoanInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getloaninfo', [], 'bignumber');
        });
    }
    /**
     * Updates an existing loan token.
     *
     * @param {string} oldToken Previous tokens's symbol, id or creation tx (unique)
     * @param {UpdateLoanToken} newTokenDetails
     * @param {string} [newTokenDetails.symbol] New token's symbol (unique), no longer than 8
     * @param {string} [newTokenDetails.name] Token's name, no longer than 128
     * @param {string} [newTokenDetails.fixedIntervalPriceId] token/currency pair to use for price of token
     * @param {boolean} [newTokenDetails.mintable] Token's 'Mintable' property
     * @param {BigNumber} [newTokenDetails.interest] Interest rate
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} LoanTokenId, also the txn id for txn created to update loan token
     */
    updateLoanToken(oldToken, newTokenDetails, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('updateloantoken', [oldToken, newTokenDetails, utxos], 'number');
        });
    }
    /**
     * Get interest info
     *
     * @param {string} id Loan scheme id
     * @param {string} [token] Specified by loan token id, loan token name and loan toekn creation tx
     * @return {Promise<Interest[]>}
     */
    getInterest(id, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getinterest', [id, token], 'bignumber');
        });
    }
    /**
     * Get loan token.
     *
     * @param {string} token Symbol or id of loan token
     * @return {Promise<LoanTokenResult>} Loan token details
     */
    getLoanToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getloantoken', [token], 'bignumber');
        });
    }
    /**
     * List all created loan tokens.
     *
     * @return {Promise<LoanTokenResult[]>}
     */
    listLoanTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listloantokens', [], 'bignumber');
        });
    }
    /**
     * Creates a vault transaction.
     *
     * @param {CreateVault} vault
     * @param {string} vault.ownerAddress Any valid address or "" to generate a new address
     * @param {number} [vault.loanSchemeId] Unique identifier of the loan scheme (8 chars max). If empty, the default loan scheme will be selected
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} Transaction id of the transaction
     */
    createVault(vault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('createvault', [vault.ownerAddress, vault.loanSchemeId, utxos], 'number');
        });
    }
    /**
     * Create update vault transaction.
     *
     * @param {string} vaultId
     * @param {UpdateVault} vault
     * @param {string} [vault.ownerAddress] Any valid address
     * @param {string} [vault.loanSchemeId] Unique identifier of the loan scheme (8 chars max)
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} Transaction id of the transaction
     */
    updateVault(vaultId, vault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('updatevault', [vaultId, vault, utxos], 'number');
        });
    }
    /**
     * Returns information about vault.
     *
     * @param {string} vaultId vault hex id
     * @return {Promise<VaultActive | VaultLiquidation>}
     */
    getVault(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getvault', [vaultId], {
                collateralValue: 'bignumber',
                loanValue: 'bignumber',
                interestValue: 'bignumber',
                informativeRatio: 'bignumber'
            });
        });
    }
    /**
     * List all available vaults.
     *
     * @param {VaultPagination} [pagination]
     * @param {string} [pagination.start]
     * @param {boolean} [pagination.including_start]
     * @param {number} [pagination.limit=100]
     * @param {ListVaultOptions} [options]
     * @param {string} [options.ownerAddress] Address of the vault owner
     * @param {string} [options.loanSchemeId] Vault's loan scheme id
     * @param {VaultState} [options.state = VaultState.UNKNOWN] vault's state
     * @param {boolean} [options.verbose = false] true to return same information as getVault
     * @return {Promise<Vault | VaultActive | VaultLiquidation[]>} Array of objects including details of the vaults.
     */
    listVaults(pagination = {}, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listvaults', [options, pagination], {
                collateralValue: 'bignumber',
                loanValue: 'bignumber',
                interestValue: 'bignumber',
                informativeRatio: 'bignumber'
            });
        });
    }
    /**
     * Close vault
     *
     * @param {CloseVault} closeVault
     * @param {string} closeVault.vaultId Vault id
     * @param {string} closeVault.to Valid address to receive collateral tokens
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>}
     */
    closeVault(closeVault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('closevault', [closeVault.vaultId, closeVault.to, utxos], 'number');
        });
    }
    /**
     * Deposit to vault
     *
     * @param {DepositVault} depositVault
     * @param {string} depositVault.vaultId Vault id
     * @param {string} depositVault.from Collateral address
     * @param {string} depositVault.amount In "amount@symbol" format
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>}
     */
    depositToVault(depositVault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('deposittovault', [depositVault.vaultId, depositVault.from, depositVault.amount, utxos], 'number');
        });
    }
    /**
     * Withdraw from vault
     *
     * @param {WithdrawVault} withdrawVault
     * @param {string} withdrawVault.vaultId Vault id
     * @param {string} withdrawVault.to Collateral address
     * @param {string} withdrawVault.amount In "amount@symbol" format
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>}
     */
    withdrawFromVault(withdrawVault, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('withdrawfromvault', [withdrawVault.vaultId, withdrawVault.to, withdrawVault.amount, utxos], 'number');
        });
    }
    /**
     * Take loan
     *
     * @param {TakeLoanMetadata} metadata
     * @param {string} metadata.vaultId Vault id
     * @param {string | string[]} metadata.amounts In "amount@symbol" format
     * @param {string} [metadata.to] Address to receive tokens
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>}
     */
    takeLoan(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('takeloan', [metadata, utxos], 'number');
        });
    }
    /**
     * Return loan in a desired amount.
     *
     * @param {PaybackLoanMetadata} metadata
     * @param {string} metadata.vaultId Vault id
     * @param {string| string[]} metadata.amounts In "amount@symbol" format
     * @param {string} metadata.from Address from transfer tokens
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} txid
     */
    paybackLoan(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('paybackloan', [metadata, utxos], 'number');
        });
    }
    /**
     * Bid to vault in auction
     *
     * @param {PlaceAuctionBid} placeAuctionBid
     * @param {string} placeAuctionBid.vaultId Vault Id
     * @param {index} placeAuctionBid.index Auction index
     * @param {from} placeAuctionBid.from Address to get token
     * @param {amount} placeAuctionBid.amount in "amount@symbol" format
     * @param {UTXO[]} [utxos = []] Specific UTXOs to spend
     * @param {string} utxos.txid Transaction Id
     * @param {number} utxos.vout Output number
     * @return {Promise<string>} The transaction id
     */
    placeAuctionBid(placeAuctionBid, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('placeauctionbid', [placeAuctionBid.vaultId, placeAuctionBid.index, placeAuctionBid.from, placeAuctionBid.amount, utxos], 'number');
        });
    }
    /**
     * List all available auctions.
     *
     * @param {AuctionPagination} pagination
     * @param {AuctionPaginationStart} [pagination.start]
     * @param {string} [pagination.start.vaultId]
     * @param {number} [pagination.start.height]
     * @param {boolean} [pagination.including_start]
     * @param {number} [pagination.limit=100]
     * @return {Promise<VaultLiquidation[]>}
     */
    listAuctions(pagination = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultPagination = {
                limit: 100
            };
            return yield this.client.call('listauctions', [Object.assign(Object.assign({}, defaultPagination), pagination)], 'number');
        });
    }
    /**
     * Returns information about auction history.
     *
     * @param {string} [owner] address or reserved word : mine / all (Default to mine)
     * @param {ListAuctionHistoryPagination} pagination
     * @param {number} [pagination.maxBlockHeight] Maximum block height
     * @param {string} [pagination.vaultId] Vault Id
     * @param {number} [pagination.index] Auction index
     * @param {number} [pagination.limit = 100]
     * @return {Promise<ListAuctionHistoryDetail>}
     */
    listAuctionHistory(owner = 'mine', pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultPagination = {
                limit: 100
            };
            return yield this.client.call('listauctionhistory', [owner, Object.assign(Object.assign({}, defaultPagination), pagination)], 'number');
        });
    }
}
exports.Loan = Loan;
var VaultState;
(function (VaultState) {
    VaultState["UNKNOWN"] = "unknown";
    VaultState["ACTIVE"] = "active";
    VaultState["IN_LIQUIDATION"] = "inLiquidation";
    VaultState["FROZEN"] = "frozen";
    VaultState["MAY_LIQUIDATE"] = "mayLiquidate";
})(VaultState = exports.VaultState || (exports.VaultState = {}));

},{}],48:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Masternode = exports.MasternodeTimeLock = exports.MasternodeState = void 0;
var MasternodeState;
(function (MasternodeState) {
    MasternodeState["PRE_ENABLED"] = "PRE_ENABLED";
    MasternodeState["ENABLED"] = "ENABLED";
    MasternodeState["PRE_RESIGNED"] = "PRE_RESIGNED";
    MasternodeState["RESIGNED"] = "RESIGNED";
    MasternodeState["PRE_BANNED"] = "PRE_BANNED";
    MasternodeState["BANNED"] = "BANNED";
    MasternodeState["UNKNOWN"] = "UNKNOWN";
})(MasternodeState = exports.MasternodeState || (exports.MasternodeState = {}));
var MasternodeTimeLock;
(function (MasternodeTimeLock) {
    MasternodeTimeLock["FIVE_YEAR"] = "FIVEYEARTIMELOCK";
    MasternodeTimeLock["TEN_YEAR"] = "TENYEARTIMELOCK";
})(MasternodeTimeLock = exports.MasternodeTimeLock || (exports.MasternodeTimeLock = {}));
/**
 * Masternode RPCs for DeFi Blockchain
 */
class Masternode {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a masternode creation transaction with given owner and operator addresses.
     *
     * @param {string} ownerAddress Any valid address for keeping collateral amount
     * @param {string} [operatorAddress]  Masternode operator auth address (P2PKH only, unique). If empty, owner address will be used.
     * @param {CreateMasternodeOptions} [options]
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid] The transaction id
     * @param {string} [options.utxos.vout] The output number
     * @param {MasternodeTimeLock} [options.timelock] specify a fix period (5 or 10 years) lock which cannot be resigned and cannot spend the collateral
     * @return {Promise<string>}
     */
    createMasternode(ownerAddress, operatorAddress, options = { utxos: [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = [
                ownerAddress,
                operatorAddress !== null && operatorAddress !== void 0 ? operatorAddress : ownerAddress,
                options.utxos,
                ...(options.timelock !== undefined ? [options.timelock] : [])
            ];
            return yield this.client.call('createmasternode', params, 'number');
        });
    }
    /**
     * Returns information about multiple masternodes.
     *
     * @param {MasternodePagination} pagination
     * @param {string} [pagination.start]
     * @param {boolean} [pagination.including_start = true] Include starting position.
     * @param {string} [pagination.limit = 100] Maximum number of orders to return.
     * @param {boolean} [verbose = true] Flag for verbose list. Only ids are returned when false.
     * @return {Promise<MasternodeResult>}
     */
    listMasternodes(pagination = {
        including_start: true,
        limit: 100
    }, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listmasternodes', [pagination, verbose], 'number');
        });
    }
    /**
     * Returns information about a single masternode
     *
     * @param {string} masternodeId The masternode's id.
     * @return {Promise<MasternodeResult>}
     */
    getMasternode(masternodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmasternode', [masternodeId], 'number');
        });
    }
    /**
     * Creates a masternode creation transaction with given owner and operator addresses.
     *
     * @param {MasternodeBlock} identifier
     * @param {string} [identifier.id] Masternode's id.
     * @param {string} [identifier.ownerAddress] Masternode owner address.
     * @param {string} [identifier.operatorAddress]  Masternode operator address.
     * @param {number} [depth] Maximum depth, from the genesis block is the default.
     * @return {Promise<MasternodeResult<string>>}
     */
    getMasternodeBlocks(identifier, depth) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmasternodeblocks', [identifier, depth], 'number');
        });
    }
    /**
     * Creates a transaction resigning a masternode.
     *
     * @param {string} masternodeId The masternode's id.
     * @param {UTXO[]} [utxos = []] Array of specified utxos to spend.
     * @param {string} [utxos.txid] The transaction id.
     * @param {number} [utxos.vout] The output number.
     * @return {Promise<string>} Resignation Transaction.
     */
    resignMasternode(masternodeId, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('resignmasternode', [masternodeId, utxos], 'number');
        });
    }
    /**
     * Set special governance variables
     *
     * @param {Record<string, any>} input json object
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} [utxos.txid] The transaction id
     * @param {string} [utxos.vout] The output number
     * @return {Promise<string>} hash
     *
     */
    setGov(input, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setgov', [input, utxos], 'number');
        });
    }
    /**
     * Set special governance variables with activation height specified
     *
     * @param {Record<string, any>} input json object
     * @param {number} activationHeight
     * @param {UTXO[]} [utxos = []] Specific utxos to spend
     * @param {string} [utxos.txid] The transaction id
     * @param {string} [utxos.vout] The output number
     * @return {Promise<string>} hash
     *
     */
    setGovHeight(input, activationHeight, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setgovheight', [input, activationHeight, utxos], 'number');
        });
    }
    /**
     * Get information about governance variable
     *
     * @param {string} name governance name
     * @return {Promise<Record<string, any>} governance information as json object
     */
    getGov(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getgov', [name], 'bignumber');
        });
    }
    /**
     * List all governance variables together if any with activation height
     *
     * @example
     * [
     *   [ { govVarKey: value }, { <activation height number>: value } ],
     *   [ { govVarKey2: value }, { <activation height number>: value } ]
     * ]
     *
     * @returns {Promise<Array<Array<Record<string, any>>>>}
     */
    listGovs() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listgovs', [], 'bignumber');
        });
    }
    /**
     * Returns the auth and confirm anchor masternode teams at current or specified height
     *
     * @param {number} blockHeight The height of block which contain tx
     * @returns {Promise<AnchorTeamResult>}
     */
    getAnchorTeams(blockHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getanchorteams', [blockHeight], 'number');
        });
    }
    /**
     * Returns number of unique masternodes in the last specified number of blocks.
     *
     * @param {number} [blockCount=20160] The number of blocks to check for unique masternodes.
     * @return {Promise<number>} Number of unique masternodes seen
     */
    getActiveMasternodeCount(blockCount = 20160) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getactivemasternodecount', [blockCount], 'number');
        });
    }
    /**
     * Returns an array of anchors if any
     * @return Promise<MasternodeResult<MasternodeAnchor>>
     */
    listAnchors() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listanchors', [], 'number');
        });
    }
}
exports.Masternode = Masternode;

},{}],49:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mining = exports.EstimateMode = void 0;
var EstimateMode;
(function (EstimateMode) {
    EstimateMode["UNSET"] = "UNSET";
    EstimateMode["ECONOMICAL"] = "ECONOMICAL";
    EstimateMode["CONSERVATIVE"] = "CONSERVATIVE";
})(EstimateMode = exports.EstimateMode || (exports.EstimateMode = {}));
/**
 * Mining RPCs for DeFi Blockchain
 */
class Mining {
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the estimated network hashes per second
     *
     * @param {number} nblocks to estimate since last difficulty change.
     * @param {number} height to estimate at the time of the given height.
     * @return {Promise<number>}
     */
    getNetworkHashPerSecond(nblocks = 120, height = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getnetworkhashps', [nblocks, height], 'number');
        });
    }
    /**
     * Get mining-related information
     * @return {Promise<MiningInfo>}
     */
    getMiningInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getmininginfo', [], 'number');
        });
    }
    /**
     *
     * @param {number} confirmationTarget in blocks (1 - 1008)
     * @param {EstimateMode} [estimateMode=EstimateMode.CONSERVATIVE] estimateMode of fees.
     * @returns {Promise<SmartFeeEstimation>}
     */
    estimateSmartFee(confirmationTarget, estimateMode = EstimateMode.CONSERVATIVE) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('estimatesmartfee', [confirmationTarget, estimateMode], 'number');
        });
    }
}
exports.Mining = Mining;

},{}],50:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Misc = void 0;
/**
 * Misc RPCs for DeFi Blockchain
 */
class Misc {
    constructor(client) {
        this.client = client;
    }
    /**
     * To dynamically change the time for testing
     *
     * @param {number} ts Unix epoch in seconds
     * @return Promise<void>
     */
    setMockTime(ts) {
        return __awaiter(this, void 0, void 0, function* () {
            const timestamp = ts.toString().length === 13 ? Math.floor(ts / 1e3) : ts;
            return yield this.client.call('setmocktime', [timestamp], 'number');
        });
    }
}
exports.Misc = Misc;

},{}],51:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Net = void 0;
/**
 * Net RPCs for DeFi Blockchain
 */
class Net {
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the number of connections to other nodes.
     *
     * @return {Promise<number>}
     */
    getConnectionCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getconnectioncount', [], 'number');
        });
    }
    /**
     * Returns an object containing various state info regarding P2P networking.
     *
     * @return {Promise<NetworkInfo>}
     */
    getNetworkInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getnetworkinfo', [], 'number');
        });
    }
}
exports.Net = Net;

},{}],52:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Oracle = exports.OracleRawPriceState = void 0;
var OracleRawPriceState;
(function (OracleRawPriceState) {
    OracleRawPriceState["LIVE"] = "live";
    OracleRawPriceState["EXPIRED"] = "expired";
})(OracleRawPriceState = exports.OracleRawPriceState || (exports.OracleRawPriceState = {}));
/**
 * Oracle RPCs for DeFi Blockchain
 */
class Oracle {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a price oracle for rely of real time price data.
     *
     * @param {string} address
     * @param {OraclePriceFeed[]} priceFeeds
     * @param {AppointOracleOptions} [options]
     * @param {number} options.weightage
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>} oracleId, also the txn id for txn created to appoint oracle
     */
    appointOracle(address, priceFeeds, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { utxos = [] } = options;
            return yield this.client.call('appointoracle', [address, priceFeeds, options.weightage, utxos], 'number');
        });
    }
    /**
     * Removes oracle.
     *
     * @param {string} oracleId
     * @param {UTXO[]} [utxos = []]
     * @param {string} [utxos.txid]
     * @param {number} [utxos.vout]
     * @return {Promise<string>} txid
     */
    removeOracle(oracleId, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('removeoracle', [oracleId, utxos], 'number');
        });
    }
    /**
     * Update a price oracle for rely of real time price data.
     *
     * @param {string} oracleId
     * @param {string} address
     * @param {UpdateOracleOptions} [options]
     * @param {OraclePriceFeed[]} options.priceFeeds
     * @param {number} options.weightage
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>} txid
     */
    updateOracle(oracleId, address, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { utxos = [] } = options;
            return yield this.client.call('updateoracle', [oracleId, address, options.priceFeeds, options.weightage, utxos], 'number');
        });
    }
    /**
     * Set oracle data transaction.
     *
     * @param {string} oracleId
     * @param {number} timestamp timestamp in seconds
     * @param {SetOracleDataOptions} [options]
     * @param {OraclePrice[]} options.prices
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>} txid
     */
    setOracleData(oracleId, timestamp, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { utxos = [] } = options;
            return yield this.client.call('setoracledata', [oracleId, timestamp, options.prices, utxos], 'number');
        });
    }
    /**
     * Returns oracle data.
     *
     * @param {string} oracleId
     * @return {Promise<OracleData>}
     */
    getOracleData(oracleId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getoracledata', [oracleId], 'number');
        });
    }
    /**
     * Returns array of oracle ids.
     *
     * @return {Promise<string[]>}
     */
    listOracles() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listoracles', [], 'number');
        });
    }
    /**
     * Returns latest raw price updates from oracles.
     *
     * @param {OraclePriceFeed} [priceFeed]
     * @return {Promise<OracleRawPrice[]>}
     */
    listLatestRawPrices(priceFeed) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = priceFeed !== undefined && priceFeed !== null ? [priceFeed] : [];
            return yield this.client.call('listlatestrawprices', params, 'bignumber');
        });
    }
    /**
     * Returns aggregated price from oracles.
     *
     * @param {OraclePriceFeed} priceFeed
     * @return {Promise<BigNumber>}
     */
    getPrice(priceFeed) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getprice', [priceFeed], 'bignumber');
        });
    }
    /**
     * List all aggregated prices.
     *
     * @return {Promise<ListPricesData[]>}
     */
    listPrices() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listprices', [], 'bignumber');
        });
    }
    /**
     * Get fixed interval price.
     *
     * @param {string} id Price feed id
     * @return {Promsie<FixedIntervalPrice>}
     */
    getFixedIntervalPrice(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getfixedintervalprice', [id], {
                activePrice: 'bignumber',
                nextPrice: 'bignumber'
            });
        });
    }
    /**
     * List all fixed interval prices.
     *
     * @param {FixedIntervalPricePagination} pagination
     * @param {string} [pagination.start]
     * @param {string} [pagination.limit = 100] Maximum number of orders to return.
     * @return {Promise<ListFixedIntervalPrice[]}
     */
    listFixedIntervalPrices(pagination = {
        limit: 100
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listfixedintervalprices', [pagination], {
                activePrice: 'bignumber',
                nextPrice: 'bignumber'
            });
        });
    }
}
exports.Oracle = Oracle;

},{}],53:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolPair = void 0;
/**
 * PoolPair RPCs for DeFi Blockchain
 */
class PoolPair {
    constructor(client) {
        this.client = client;
    }
    /**
     * Create a poolpair with given metadata
     *
     * @param {CreatePoolPairMetadata} metadata a data providing information for pool pair creation
     * @param {string} metadata.tokenA uses to trade to obtain tokenB
     * @param {string} metadata.tokenB
     * @param {number} metadata.commission
     * @param {boolean} metadata.status
     * @param {string} metadata.ownerAddress
     * @param {string} [metadata.customRewards]
     * @param {string} [metadata.pairSymbol]
     * @param {UTXO[]} utxos is an array of specific UTXOs to spend
     * @param {string} utxos.txid
     * @param {number} utxos.vout
     * @return {Promise<string>}
     */
    createPoolPair(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('createpoolpair', [metadata, utxos], 'number');
        });
    }
    /**
     * Returns information about pools
     *
     * @param {PoolPairPagination} pagination
     * @param {number} pagination.start default is 0
     * @param {boolean} pagination.including_start default = true
     * @param {number} pagination.limit to limit number of records
     * @param {boolean} verbose default = true, otherwise only symbol, name, status, idTokenA, idTokenB
     * @return {Promise<PoolPairsResult>}
     */
    listPoolPairs(pagination = {
        start: 0,
        including_start: true,
        limit: 100
    }, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listpoolpairs', [pagination, verbose], 'bignumber');
        });
    }
    /**
     * Returns information about pool
     *
     * @param {string} symbol token's symbol
     * @param {boolean} verbose default = true, otherwise only symbol, name, status, idTokenA, idTokenB
     * @return {Promise<PoolPairsResult>}
     */
    getPoolPair(symbol, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getpoolpair', [symbol, verbose], 'bignumber');
        });
    }
    /**
     * Add pool liquidity transaction
     *
     * @param {AddPoolLiquiditySource} from pool liquidity sources
     * @param {string | string[]} from[address] provides at least two types of token with format 'amoun@token'
     * @param {string} shareAddress defi address for crediting tokens
     * @param {PoolLiquidityOptions} [options]
     * @param {AddPoolLiquidityUTXO[]} [options.utxos] utxos array of specific UTXOs to spend
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>}
     */
    addPoolLiquidity(from, shareAddress, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { utxos } = options;
            return yield this.client.call('addpoolliquidity', [from, shareAddress, utxos], 'bignumber');
        });
    }
    /**
     * Returns information about pool shares
     *
     * @param {PoolPairPagination} pagination
     * @param {number} pagination.start default is 0
     * @param {boolean} pagination.including_start default = true
     * @param {number} pagination.limit to limit number of records
     * @param {boolean} verbose default = true, otherwise only poolID, owner and %
     * @param {PoolShareOptions} [options]
     * @param {boolean} [options.isMineOnly=true]
     * @return {Promise<PoolSharesResult>}
     */
    listPoolShares(pagination = {
        start: 0,
        including_start: true,
        limit: 100
    }, verbose = true, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { isMineOnly = true } = options;
            return yield this.client.call('listpoolshares', [pagination, verbose, isMineOnly], 'bignumber');
        });
    }
    /**
     *  Creates a pool swap transaction with given metadata
     *
     * @param {PoolSwapMetadata} metadata a provided information to create pool swap transaction
     * @param {string} metadata.from address of the owner of tokenFrom
     * @param {string} metadata.tokenFrom swap from token {symbol/id}
     * @param {number} metadata.amountFrom amount from tokenA
     * @param {string} metadata.to address of the owner of tokenTo
     * @param {string} metadata.tokenTo swap to token {symbol/id}
     * @param {number} [metadata.maxPrice] acceptable max price
     * @param {UTXO[]} [utxos = []] array for utxos to spend from.
     * @param {string} [utxos.txid] the transaction id.
     * @param {number} [utxos.vout] the output number.
     * @return {Promise<string>}  hex of performed transaction
     */
    poolSwap(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('poolswap', [metadata, utxos], 'bignumber');
        });
    }
    /**
     *  Creates a composite swap (swap between multiple poolpairs) transaction with given metadata.
     *
     * @param {PoolSwapMetadata} metadata a provided information to create pool swap transaction
     * @param {string} metadata.from address of the owner of tokenFrom
     * @param {string} metadata.tokenFrom swap from token {symbol/id}
     * @param {number} metadata.amountFrom amount from tokenFrom
     * @param {string} metadata.to address of the owner of tokenTo
     * @param {string} metadata.tokenTo swap to token {symbol/id}
     * @param {number} [metadata.maxPrice] acceptable max price
     * @param {UTXO[]} [utxos = []] array for utxos to spend from.
     * @param {string} utxos.txid the transaction id.
     * @param {number} utxos.vout the output number.
     * @return {Promise<string>}  hex of performed transaction
     */
    compositeSwap(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('compositeswap', [metadata, utxos], 'number');
        });
    }
    /**
     * Create a test pool swap transaction to check pool swap's return result
     *
     * @param {PoolSwapMetadata} metadata a provided information to create test pool swap transaction
     * @param {string} metadata.from address of the owner of tokenFrom
     * @param {string} metadata.tokenFrom swap from token {symbol/id}
     * @param {number} metadata.amountFrom amount from tokenA
     * @param {string} metadata.to address of the owner of tokenTo
     * @param {string} metadata.tokenTo swap to token {symbol/id}
     * @param {number} [metadata.maxPrice] acceptable max price
     * @return {Promise<string>} formatted as 'amount@token' swapped
     */
    testPoolSwap(metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('testpoolswap', [metadata], 'bignumber');
        });
    }
    /**
     * Remove pool liquidity transaction
     *
     * @param {string} address defi address for crediting tokens
     * @param {string} poolAccount pool liquidity account of owner
     * @param {PoolLiquidityOptions} [options]
     * @param {UTXO[]} [options.utxos] utxos array of specific UTXOs to spend
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @return {Promise<string>}
     */
    removePoolLiquidity(address, poolAccount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { utxos } = options;
            return yield this.client.call('removepoolliquidity', [address, poolAccount, utxos], 'bignumber');
        });
    }
}
exports.PoolPair = PoolPair;

},{}],54:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawTx = exports.SigHashType = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
var SigHashType;
(function (SigHashType) {
    SigHashType["ALL"] = "ALL";
    SigHashType["NONE"] = "NONE";
    SigHashType["SINGLE"] = "SINGLE";
    SigHashType["ALL_ANYONECANPAY"] = "ALL|ANYONECANPAY";
    SigHashType["NONE_ANYONECANPAY"] = "NONE|ANYONECANPAY";
    SigHashType["SINGLE_ANYONECANPAY"] = "SINGLE|ANYONECANPAY";
})(SigHashType = exports.SigHashType || (exports.SigHashType = {}));
/**
 * RawTransaction RPCs for DeFi Blockchain
 */
class RawTx {
    constructor(client) {
        this.client = client;
    }
    /**
     * Create a transaction spending the given inputs and creating new outputs that returns a hex-encoded raw transaction.
     * Note that the transaction's inputs are not signed, and it is not stored in the wallet or transmitted to the network.
     *
     * @param {CreateRawTxIn[]} inputs array of inputs
     * @param {CreateRawTxOut[]} outputs array with outputs
     * @param {CreateRawTxOptions} [options]
     * @param {number} [options.locktime] Non-0 value also locktime-activates inputs
     * @param {boolean} [options.replaceable] Marks this transaction as BIP125-replaceable
     * @return {Promise<string>} hex string of the transaction
     */
    createRawTransaction(inputs, outputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { locktime = 0, replaceable = false } = options;
            return yield this.client.call('createrawtransaction', [
                inputs, outputs, locktime, replaceable
            ], 'number');
        });
    }
    /**
     * Sign inputs for raw transaction (serialized, hex-encoded), providing an array of base58-encoded private keys that
     * will be the keys used to sign the transaction. An optional array of previous transaction outputs that this
     * transaction depends on but may not yet be in the blockchain.
     *
     * @param {string} rawTx unsigned raw transaction
     * @param {string[]} privKeys array of base58-encoded private keys for signing (WIF)
     * @param {SignRawTxWithKeyOptions} [options]
     * @param {SigHashType} [options.sigHashType] the signature hash type to use
     * @param {SignRawTxWithKeyPrevTx[]} [options.prevTxs] array of previous dependent transaction outputs
     * @return {Promise<SignRawTxWithKeyResult>}
     */
    signRawTransactionWithKey(rawTx, privKeys, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { prevTxs = [], sigHashType = SigHashType.ALL } = options;
            return yield this.client.call('signrawtransactionwithkey', [
                rawTx, privKeys, prevTxs, sigHashType
            ], 'number');
        });
    }
    /**
     * Returns result of mempool acceptance tests indicating if raw transaction would be accepted by mempool.
     * This checks if the transaction violates the consensus or policy rules. The fee rate is expressed in DFI/kB,
     * using the vSize of the transaction.
     *
     * @param {string} signedTx signed raw transaction
     * @param {BigNumber} maxFeeRate Reject transactions whose fee rate is higher than the specified value. in DFI/kB
     * @return {Promise<TestMempoolAcceptResult>} transaction mempool accept result
     * @see sendRawTransaction
     * @see createRawTransaction
     * @see signRawTransactionWithKey
     */
    testMempoolAccept(signedTx, maxFeeRate = new bignumber_js_1.default('0')) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.client.call('testmempoolaccept', [
                [signedTx], maxFeeRate
            ], 'number');
            return results[0];
        });
    }
    /**
     * Submit a raw transaction (serialized, hex-encoded) to the connected node and network. The transaction will be sent
     * unconditionally to all peers, so using this for manual rebroadcast may degrade privacy by leaking the transaction's
     * origin, as nodes will normally not rebroadcast non-wallet transactions already in their mempool.
     *
     * @param {string} signedTx signed raw transaction
     * @param {BigNumber} maxFeeRate Reject transactions whose fee rate is higher than the specified value. in DFI/kB
     * @return {Promise<string>} transaction hash in hex
     * @see testMempoolAccept
     * @see createRawTransaction
     * @see signRawTransactionWithKey
     */
    sendRawTransaction(signedTx, maxFeeRate = new bignumber_js_1.default('0')) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('sendrawtransaction', [
                signedTx, maxFeeRate
            ], 'number');
        });
    }
    /**
     * Get raw transaction
     *
     * @param {string} txid transaction id
     * @param {boolean} [verbose=false] true will return object information, false/omitted will return hex-encoded data
     * @param {string} [blockHash] mempool transaction is returned by default. If blockHash is specified then will get transaction in block.
     * @return {Promise<string | RawTransaction>}
     */
    getRawTransaction(txid, verbose, blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getrawtransaction', [txid, verbose, blockHash], 'number');
        });
    }
}
exports.RawTx = RawTx;

},{"bignumber.js":167}],55:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
class Server {
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns details of the RPC server
     *
     * @return {Promise<RpcInfo>}
     */
    getRpcInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getrpcinfo', [], 'number');
        });
    }
    /**
     * Returns the total uptime of the server in seconds
     *
     * @return {Promise<number>}
     */
    uptime() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('uptime', [], 'number');
        });
    }
}
exports.Server = Server;

},{}],56:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Spv = exports.HTLC_MINIMUM_BLOCK_COUNT = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
exports.HTLC_MINIMUM_BLOCK_COUNT = 9;
/**
 * SPV RPCs for Bitcoin Blockchain
 */
class Spv {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates and adds a Bitcoin address to the SPV wallet.
     *
     * @return {Promise<string>} Returns a new Bitcoin address
     */
    getNewAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_getnewaddress', [], 'number');
        });
    }
    /**
     * Returns a Bitcoin address's public key.
     *
     * @param {string} address Bitcoin address
     * @return {Promise<string>} Public key
     */
    getAddressPubKey(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_getaddresspubkey', [address], 'number');
        });
    }
    /**
     * List balances by receiving address.
     *
     * @param {string} [minConfirmation=1] The minimum number of confirmations
     * @param {string} [address] Filter by address
     * @return {Promise<ReceivedByAddressInfo[]>}
     */
    listReceivedByAddress(minConfirmation = 1, address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listreceivedbyaddress', [minConfirmation, address], {
                amount: 'bignumber'
            });
        });
    }
    /**
     * Send a Bitcoin amount to a given address.
     *
     * @param {string} address Bitcoin address
     * @param {BigNumber} amount Bitcoin amount
     * @param {SpvDefaultOptions} [options]
     * @param {BigNumber} [options.feeRate=10000] Fee rate in satoshis per KB. Minimum is 1000.
     * @return {Promise<SendMessageResult>}
     */
    sendToAddress(address, amount, options = { feeRate: new bignumber_js_1.default('10000') }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_sendtoaddress', [address, amount, options.feeRate], 'bignumber');
        });
    }
    /**
     * Creates a Bitcoin address whose funds can be unlocked with a seed or as a refund.
     *
     * @param {string} receiverPubKey The public key of the possessor of the seed
     * @param {string} ownerPubKey The public key of the recipient of the refund
     * @param {CreateHtlcOptions} options
     * @param {string} options.timeout  Timeout of the contract (denominated in blocks) relative to its placement in the blockchain. Minimum 9. See HTLC_MINIMUM_BLOCK_COUNT
     * @param {string} [options.seedhash] SHA256 hash of the seed. If none provided one will be generated
     * @return {Promise<CreateHtlcResult>}
     */
    createHtlc(receiverPubKey, ownerPubKey, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_createhtlc', [receiverPubKey, ownerPubKey, options.timeout, options.seedhash], 'number');
        });
    }
    /**
     * Decode and return value in a HTLC redeemscript.
     *
     * @param {string} redeemScript HTLC redeem script
     * @return {Promise<DecodeHtlcResult>}
     */
    decodeHtlcScript(redeemScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_decodehtlcscript', [redeemScript], 'number');
        });
    }
    /**
     * Claims all coins in HTLC address.
     *
     * @param {string} scriptAddress HTLC address
     * @param {string} destinationAddress Destination address to send HTLC funds to
     * @param {ClaimHtlcOptions} options
     * @param {string} options.seed HTLC seed
     * @param {BigNumber} [options.feeRate=10000] Fee rate in satoshis per KB. Minimum is 1000.
     * @return {Promise<SendMessageResult>}
     */
    claimHtlc(scriptAddress, destinationAddress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_claimhtlc', [scriptAddress, destinationAddress, options.seed, options.feeRate], 'bignumber');
        });
    }
    /**
     * Returns the HTLC secret if available.
     *
     * @param {string} address HTLC address
     * @return {Promise<string>} HTLC secret
     */
    getHtlcSeed(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_gethtlcseed', [address], 'number');
        });
    }
    /**
     * Refunds all coins in HTLC address.
     * Can be used after the timeout threshold set in createHtlc. See https://en.bitcoin.it/wiki/BIP_0199
     *
     * @param {string} scriptAddress HTLC address
     * @param {string} destinationAddress Destination for funds in the HTLC
     * @param {SpvDefaultOptions} [options]
     * @param {BigNumber} [options.feeRate=10000] Fee rate in satoshis per KB. Minimum is 1000.
     * @return {Promise<SendMessageResult>}
     */
    refundHtlc(scriptAddress, destinationAddress, options = { feeRate: new bignumber_js_1.default('10000') }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_refundhtlc', [scriptAddress, destinationAddress, options.feeRate], 'number');
        });
    }
    /**
     * List all outputs related to HTLC addresses in the wallet.
     *
     * @param {string | undefined} [scriptAddress] HTLC address to filter result
     * @return {Promise<ListHtlcsOutputsResult[]>}
     */
    listHtlcOutputs(scriptAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listhtlcoutputs', [scriptAddress], { amount: 'bignumber' });
        });
    }
    /**
     * List anchor reward confirms
     *
     * @return {Promise<ListAnchorRewardConfirmsResult[]>}
     */
    listAnchorRewardConfirms() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorrewardconfirms', [], 'number');
        });
    }
    /**
     * List unrewarded anchors
     *
     * @return {Promise<ListAnchorsResult[]>}
     */
    listAnchorsUnrewarded() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorsunrewarded', [], 'number');
        });
    }
    /**
     * List anchor rewards
     *
     * @return {Promise<ListAnchorRewardsResult[]>}
     */
    listAnchorRewards() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorrewards', [], 'number');
        });
    }
    /**
     * Create, sign and send anchor tx, using only SPV API
     *
     * @param {CreateAnchorInput[]} createAnchorInputs Info from BTC chain
     * @param {string} createAnchorInput.txid The transaction id of the bitcoin UTXO to spent
     * @param {string} createAnchorInput.vout The output index to spend in UTXO for tx fee
     * @param {number} createAnchorInput.amount Amount of output in satoshis (base unit)
     * @param {string} createAnchorInput.privkey WIF private key of bitcoin for signing this output
     * @param {string} rewardAddress User's P2PKH address (in DeFi chain) for reward
     * @param {CreateAnchorOptions} [options]
     * @param {boolean} [options.send=true] Send it to BTC network
     * @param {BigNumber} [options.feerate=1000] Feerate (satoshis) per KB, default is 1000.
     * @return {Promise<CreateAnchorResult>}
     */
    createAnchor(createAnchorInputs, rewardAddress, options = { send: true, feerate: 1000 }) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = Object.assign({ send: true, feerate: 1000 }, options);
            return yield this.client.call('spv_createanchor', [createAnchorInputs, rewardAddress, opts.send, opts.feerate], { cost: 'bignumber', estimatedReward: 'bignumber' });
        });
    }
    /**
     * List anchors
     *
     * @param {ListAnchorsOptions} [options]
     * @param {number} [options.minBtcHeight=-1]
     * @param {number} [options.maxBtcHeight=-1]
     * @param {number} [options.minConfs=-1]
     * @param {number} [options.maxConfs=-1]
     * @param {number} [options.startBTCHeight=-1]
     * @param {number} [options.limit]
     * @return {Promise<ListAnchorsResult[]>}
     */
    listAnchors(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = Object.assign({ minBtcHeight: -1, maxBtcHeight: -1, minConfs: -1, maxConfs: -1, startBTCHeight: -1, limit: -1 }, options);
            return yield this.client.call('spv_listanchors', [opts.minBtcHeight, opts.maxBtcHeight, opts.minConfs, opts.maxConfs, opts.startBTCHeight, opts.limit], 'number');
        });
    }
    /**
     * List pending anchors in mempool
     *
     * @return {Promise<ListAnchorsResult[]>}
     */
    listAnchorsPending() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorspending', [], 'number');
        });
    }
    /**
     * List anchor auths
     *
     * @return {Promise<ListAnchorAuthsResult[]>}
     */
    listAnchorAuths() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_listanchorauths', [], 'number');
        });
    }
    /**
     * Set last height on BTC chain, use for testing purpose
     *
     * @param {number} height
     * @return {Promise<void>}
     */
    setLastHeight(height) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('spv_setlastheight', [height], 'number');
        });
    }
}
exports.Spv = Spv;

},{"bignumber.js":167}],57:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = void 0;
/**
 * Token RPCs for DeFi Blockchain
 */
class Token {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a token with given metadata
     *
     * @param {CreateTokenMetadata} metadata
     * @param {string} metadata.symbol token's symbol (unique)
     * @param {string} metadata.name token's name (unique)
     * @param {boolean} metadata.isDAT default = false
     * @param {boolean} metadata.mintable default = true
     * @param {boolean} metadata.tradeable default = true
     * @param {string} metadata.collateralAddress for keeping collateral amount
     * @param {UTXO[]} utxos array of specific UTXOs to spend
     * @param {string} utxos.txid
     * @param {number} utxos.vout
     * @return {Promise<string>}
     */
    createToken(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultMetadata = {
                isDAT: false,
                mintable: true,
                tradeable: true
            };
            return yield this.client.call('createtoken', [Object.assign(Object.assign({}, defaultMetadata), metadata), utxos], 'number');
        });
    }
    /**
     * Updates a token with given metadata
     *
     * @param {string} token symbolKey, id ror creation tx
     * @param {UpdateTokenMetadata} [metadata]
     * @param {string} [metadata.symbol]
     * @param {string} [metadata.name]
     * @param {boolean} [metadata.isDAT]
     * @param {boolean} [metadata.mintable]
     * @param {boolean} [metadata.tradeable]
     * @param {boolean} [metadata.finalize]
     * @return {Promise<string>}
     */
    updateToken(token, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('updatetoken', [token, metadata], 'number');
        });
    }
    /**
     * Returns information about tokens
     *
     * @param {TokenPagination} pagination
     * @param {number} pagination.start
     * @param {boolean} pagination.including_start
     * @param {number} pagination.limit
     * @param {boolean} verbose
     * @return {Promise<TokenResult>}
     */
    listTokens(pagination = {
        start: 0,
        including_start: true,
        limit: 100
    }, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listtokens', [pagination, verbose], 'bignumber');
        });
    }
    /**
     * Return information about token
     *
     * @param {string} symbolKey
     * @return {Promise<TokenResult>}
     */
    getToken(symbolKey) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note(canonbrother): only 'limit' and 'minted' is bignumber
            // but the 'return' contains random id which is not be able to map precision exactly
            // precision: { '0': limit: 'bignumber', minted: 'bignumber'}
            return yield this.client.call('gettoken', [symbolKey], 'bignumber');
        });
    }
    /**
     * Creates a transaction to mint tokens.
     *
     * @param {string} amountToken formatted as `${number}@${string}`
     * @param {UTXO[]} [utxos = []]
     * @param {string} [utxos.txid]
     * @param {number} [utxos.vout]
     * @return {Promise<string>}
     */
    mintTokens(amountToken, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('minttokens', [amountToken, utxos], 'number');
        });
    }
}
exports.Token = Token;

},{}],58:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = exports.InWalletTransactionCategory = exports.BIP125 = exports.WalletFlag = exports.ScriptType = exports.AddressType = exports.Mode = void 0;
var Mode;
(function (Mode) {
    Mode["UNSET"] = "UNSET";
    Mode["ECONOMICAL"] = "ECONOMICAL";
    Mode["CONSERVATIVE"] = "CONSERVATIVE";
})(Mode = exports.Mode || (exports.Mode = {}));
var AddressType;
(function (AddressType) {
    AddressType["LEGACY"] = "legacy";
    AddressType["P2SH_SEGWIT"] = "p2sh-segwit";
    AddressType["BECH32"] = "bech32";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
var ScriptType;
(function (ScriptType) {
    ScriptType["NONSTANDARD"] = "nonstandard";
    ScriptType["PUBKEY"] = "pubkey";
    ScriptType["PUBKEYHASH"] = "pubkeyhash";
    ScriptType["SCRIPTHASH"] = "scripthash";
    ScriptType["MULTISIG"] = "multisig";
    ScriptType["NULLDATA"] = "nulldata";
    ScriptType["WITNESS_V0_KEYHASH"] = "witness_v0_keyhash";
    ScriptType["WITNESS_UNKNOWN"] = "witness_unknown";
})(ScriptType = exports.ScriptType || (exports.ScriptType = {}));
var WalletFlag;
(function (WalletFlag) {
    WalletFlag["AVOID_REUSE"] = "avoid_reuse";
})(WalletFlag = exports.WalletFlag || (exports.WalletFlag = {}));
var BIP125;
(function (BIP125) {
    BIP125["YES"] = "yes";
    BIP125["NO"] = "no";
    BIP125["UNKNOWN"] = "unknown";
})(BIP125 = exports.BIP125 || (exports.BIP125 = {}));
var InWalletTransactionCategory;
(function (InWalletTransactionCategory) {
    InWalletTransactionCategory["SEND"] = "send";
    InWalletTransactionCategory["RECEIVE"] = "receive";
    InWalletTransactionCategory["GENERATE"] = "generate";
    InWalletTransactionCategory["IMMATURE"] = "immature";
    InWalletTransactionCategory["ORPHAN"] = "orphan";
})(InWalletTransactionCategory = exports.InWalletTransactionCategory || (exports.InWalletTransactionCategory = {}));
/**
 * Wallet RPCs for DeFi Blockchain
 */
class Wallet {
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the total available balance in wallet.
     *
     * @param {number} minimumConfirmation to include transactions confirmed at least this many times
     * @param {boolean} includeWatchOnly for watch-only wallets
     * @return Promise<BigNumber>
     */
    getBalance(minimumConfirmation = 0, includeWatchOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getbalance', ['*', minimumConfirmation, includeWatchOnly], 'bignumber');
        });
    }
    /**
     * Identical to getBalance to get untrusted pending balance
     *
     * @return Promise<BigNumber>
     */
    getUnconfirmedBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getunconfirmedbalance', [false], 'bignumber');
        });
    }
    /**
     * Returns an object with all balances.
     *
     * @return {Promise<WalletBalances>}
     */
    getBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getbalances', [false], 'bignumber');
        });
    }
    /**
     * Get list of UTXOs in wallet.
     *
     * @param {number} minimumConfirmation default = 1, to filter
     * @param {number} maximumConfirmation default = 9999999, to filter
     * @param {ListUnspentOptions} [options]
     * @param {string[]} [options.addresses] to filter
     * @param {boolean} [options.includeUnsafe=true] default = true, include outputs that are not safe to spend
     * @param {ListUnspentQueryOptions} [options.queryOptions]
     * @param {number} [options.queryOptions.minimumAmount] default = 0, minimum value of each UTXO
     * @param {number} [options.queryOptions.maximumAmount] default is 'unlimited', maximum value of each UTXO
     * @param {number} [options.queryOptions.maximumCount] default is 'unlimited', maximum number of UTXOs
     * @param {number} [options.queryOptions.minimumSumAmount] default is 'unlimited', minimum sum valie of all UTXOs
     * @param {string} [options.queryOptions.tokenId] default is 'all', filter by token
     * @return {Promise<UTXO[]>}
     */
    listUnspent(minimumConfirmation = 1, maximumConfirmation = 9999999, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { addresses = [], includeUnsafe = true, queryOptions = {} } = options;
            return yield this.client.call('listunspent', [
                minimumConfirmation, maximumConfirmation,
                addresses, includeUnsafe, queryOptions
            ], { amount: 'bignumber' });
        });
    }
    /**
     * Create a new wallet
     *
     * @param {string} walletName
     * @param {boolean} disablePrivateKeys
     * @param {CreateWalletOptions} [options]
     * @param {boolean} [options.blank]
     * @param {string} [options.passphrase]
     * @param {boolean} [options.avoidReuse]
     * @return {Promise<CreateWalletResult>}
     */
    createWallet(walletName, disablePrivateKeys = false, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { blank = false, passphrase = '', avoidReuse = false } = options;
            return yield this.client.call('createwallet', [walletName, disablePrivateKeys, blank, passphrase, avoidReuse], 'number');
        });
    }
    /**
     * Return object containing various wallet state info
     *
     * @return {Promise<WalletInfo>}
     */
    getWalletInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getwalletinfo', [], {
                balance: 'bignumber',
                unconfirmed_balance: 'bignumber',
                immature_balance: 'bignumber',
                paytxfee: 'bignumber'
            });
        });
    }
    /**
     * Change the state of the given wallet flag for a wallet
     *
     * @param {WalletFlag} flag to change. eg: avoid_reuse
     * @param {boolean} value optional, default = true
     * @return {Promise<WalletFlagResult>}
     */
    setWalletFlag(flag, value = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('setwalletflag', [flag, value], 'number');
        });
    }
    /**
     * Returns a new DeFi address for receiving payments.
     * If 'label' is specified, it's added to the address book
     * so payments received with the address will be associated with 'label'
     *
     * @param {string} label for address to be linked to. It can also be set as empty string
     * @param {AddressType} addressType to use, eg: legacy, p2sh-segwit, bech32
     * @return {Promise<string>}
     */
    getNewAddress(label = '', addressType = AddressType.BECH32) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getnewaddress', [label, addressType], 'number');
        });
    }
    /**
     * Validate and return information about the given DFI address
     *
     * @param {string} address
     * @return {Promise<ValidateAddressResult>}
     */
    validateAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('validateaddress', [address], 'number');
        });
    }
    /**
     * Return information about the given address
     *
     * @param {string} address
     * @return {Promise<AddressInfo>}
     */
    getAddressInfo(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getaddressinfo', [address], 'number');
        });
    }
    /**
     * Send an amount to given address and return a transaction id
     *
     * @param {string} address
     * @param {number} amount
     * @param {SendToAddressOptions} [options]
     * @param {string} [options.comment]
     * @param {string} [options.commentTo]
     * @param {boolean} [options.subtractFeeFromAmount]
     * @param {boolean} [options.replaceable]
     * @param {number} [options.confTarget]
     * @param {Mode} [options.estimateMode]
     * @param {boolean} [options.avoidReuse]
     * @return {Promise<string>}
     */
    sendToAddress(address, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { comment = '', commentTo = '', subtractFeeFromAmount = false, replaceable = false, confTarget = 6, estimateMode = Mode.UNSET, avoidReuse = false } = options;
            return yield this.client.call('sendtoaddress', [
                address, amount, comment, commentTo, subtractFeeFromAmount,
                replaceable, confTarget, estimateMode, avoidReuse
            ], 'bignumber');
        });
    }
    /**
     * Lists groups of addresses which have had their common ownership made public
     * by common use as inputs or as the resulting change in past transactions
     *
     * @return {Promise<any[][][]>}
     */
    listAddressGroupings() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listaddressgroupings', [], 'bignumber');
        });
    }
    /**
     * Send given amounts to multiple given address and return a transaction id.
     *
     * @param {Record<string, number>} amounts Dictionary/map with individual addresses and amounts
     * @param {string[]} subtractfeefrom Array of addresses from which fee needs to be deducted.
     * @param {SendManyOptions} options
     * @param {string} [options.comment] A comment
     * @param {boolean} [options.replaceable] Allow this transaction to be replaced by a transaction with higher fees via BIP 125
     * @param {number} [options.confTarget] Confirmation target (in blocks)
     * @param {Mode} [options.estimateMode] The fee estimate mode, must be one of (Mode.UNSET, Mode.ECONOMICAL, Mode.CONSERVATIVE)
     * @return {Promise<string>} hex string of the transaction
     */
    sendMany(amounts, subtractfeefrom = [], options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { comment = '', replaceable = false, confTarget = 6, estimateMode = Mode.UNSET } = options;
            const dummy = ''; // Must be set to '' for backward compatibality.
            const minconf = 0; // Ignored dummy value
            return yield this.client.call('sendmany', [
                dummy, amounts, minconf, comment, subtractfeefrom,
                replaceable, confTarget, estimateMode
            ], 'bignumber');
        });
    }
    /**
     * Reveals the private key corresponding to an address.
     *
     * @param {string} address The DFI address for the private key.
     * @return {Promise<string>}
     */
    dumpPrivKey(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('dumpprivkey', [address], 'number');
        });
    }
    /**
     * Adds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.
     *
     * @param {string} privkey The private key (see dumpprivkey)
     * @param {string}  [label=""] current label if address exists, otherwise "".
     * @param {boolean} [rescan=true] Rescan the wallet for transactions
     */
    importPrivKey(privkey, label = '', rescan = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('importprivkey', [privkey, label, rescan], 'number');
        });
    }
    /**
     * Get detailed information about in-wallet transaction
     *
     * @param {string} txid transaction id
     * @param {boolean} includeWatchOnly optional, default = true
     * @return {Promise<InWalletTransaction>}
     */
    getTransaction(txid, includeWatchOnly = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('gettransaction', [txid, includeWatchOnly], { amount: 'bignumber' });
        });
    }
}
exports.Wallet = Wallet;

},{}],59:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcApiError = exports.ClientApiError = exports.ApiError = exports.ApiClient = exports.loan = exports.misc = exports.icxorderbook = exports.spv = exports.governance = exports.masternode = exports.server = exports.oracle = exports.account = exports.token = exports.poolpair = exports.wallet = exports.rawtx = exports.net = exports.mining = exports.blockchain = void 0;
const blockchain_1 = require("./category/blockchain");
const mining_1 = require("./category/mining");
const net_1 = require("./category/net");
const rawtx_1 = require("./category/rawtx");
const wallet_1 = require("./category/wallet");
const account_1 = require("./category/account");
const poolpair_1 = require("./category/poolpair");
const token_1 = require("./category/token");
const oracle_1 = require("./category/oracle");
const server_1 = require("./category/server");
const masternode_1 = require("./category/masternode");
const icxorderbook_1 = require("./category/icxorderbook");
const governance_1 = require("./category/governance");
const spv_1 = require("./category/spv");
const misc_1 = require("./category/misc");
const loan_1 = require("./category/loan");
__exportStar(require("@defichain/jellyfish-json"), exports);
exports.blockchain = __importStar(require("./category/blockchain"));
exports.mining = __importStar(require("./category/mining"));
exports.net = __importStar(require("./category/net"));
exports.rawtx = __importStar(require("./category/rawtx"));
exports.wallet = __importStar(require("./category/wallet"));
exports.poolpair = __importStar(require("./category/poolpair"));
exports.token = __importStar(require("./category/token"));
exports.account = __importStar(require("./category/account"));
exports.oracle = __importStar(require("./category/oracle"));
exports.server = __importStar(require("./category/server"));
exports.masternode = __importStar(require("./category/masternode"));
exports.governance = __importStar(require("./category/governance"));
exports.spv = __importStar(require("./category/spv"));
exports.icxorderbook = __importStar(require("./category/icxorderbook"));
exports.misc = __importStar(require("./category/misc"));
exports.loan = __importStar(require("./category/loan"));
/**
 * A protocol agnostic DeFiChain node client, RPC calls are separated into their category.
 */
class ApiClient {
    constructor() {
        this.blockchain = new blockchain_1.Blockchain(this);
        this.mining = new mining_1.Mining(this);
        this.net = new net_1.Net(this);
        this.rawtx = new rawtx_1.RawTx(this);
        this.wallet = new wallet_1.Wallet(this);
        this.account = new account_1.Account(this);
        this.poolpair = new poolpair_1.PoolPair(this);
        this.token = new token_1.Token(this);
        this.oracle = new oracle_1.Oracle(this);
        this.server = new server_1.Server(this);
        this.masternode = new masternode_1.Masternode(this);
        this.icxorderbook = new icxorderbook_1.ICXOrderBook(this);
        this.governance = new governance_1.Governance(this);
        this.spv = new spv_1.Spv(this);
        this.misc = new misc_1.Misc(this);
        this.loan = new loan_1.Loan(this);
    }
}
exports.ApiClient = ApiClient;
/**
 * DeFi Blockchain errors are encapsulated into ApiError.
 * @see ClientApiError
 * @see RpcApiError
 */
class ApiError extends Error {
}
exports.ApiError = ApiError;
/**
 * Api client side error, from user.
 */
class ClientApiError extends ApiError {
    constructor(message) {
        super(`ClientApiError: ${message}`);
    }
}
exports.ClientApiError = ClientApiError;
/**
 * API RPC error, from upstream.
 */
class RpcApiError extends ApiError {
    constructor(error) {
        super(`RpcApiError: '${error.message}', code: ${error.code}, method: ${error.method}`);
        this.payload = error;
    }
}
exports.RpcApiError = RpcApiError;

},{"./category/account":43,"./category/blockchain":44,"./category/governance":45,"./category/icxorderbook":46,"./category/loan":47,"./category/masternode":48,"./category/mining":49,"./category/misc":50,"./category/net":51,"./category/oracle":52,"./category/poolpair":53,"./category/rawtx":54,"./category/server":55,"./category/spv":56,"./category/token":57,"./category/wallet":58,"@defichain/jellyfish-json":73}],60:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeBigNumberUInt64 = exports.readBigNumberUInt64 = exports.MAX_INT64 = exports.ONE_HUNDRED_MILLION = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
exports.ONE_HUNDRED_MILLION = new bignumber_js_1.default('100000000');
exports.MAX_INT64 = new bignumber_js_1.default('9223372036854775807');
/**
 * @param {SmartBuffer} buffer to read as unsigned BigNumber (LE)
 * @return BigNumber
 */
function readBigNumberUInt64(buffer) {
    const second = buffer.readUInt32LE();
    const first = buffer.readUInt32LE();
    return new bignumber_js_1.default(first).multipliedBy(0x100000000).plus(second);
}
exports.readBigNumberUInt64 = readBigNumberUInt64;
/**
 * @param {BigNumber} bigNumber
 * @param {SmartBuffer} buffer to write to as unsigned BigNumber (LE)
 */
function writeBigNumberUInt64(bigNumber, buffer) {
    if (bigNumber.isGreaterThan(new bignumber_js_1.default('18446744073709551615'))) {
        throw new Error(`It must be >= 0n and < 2n ** 64n. Received ${bigNumber.toString(10)}`);
    }
    const second = bigNumber.mod(0x100000000);
    const first = bigNumber.minus(second).dividedBy(0x100000000);
    buffer.writeUInt32LE(second.toNumber());
    buffer.writeUInt32LE(first.toNumber());
}
exports.writeBigNumberUInt64 = writeBigNumberUInt64;

},{"bignumber.js":167}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBitsFrom = void 0;
/**
 * Extracts the "truthiness" of a bit given a position
 * @param {number} binaryNum - The number to query from
 * @param {number} position - This is the zero-indexed position of the bit from the right
 * @returns {boolean} - "Truthiness" of the bit we're interested in
 */
function getBitsFrom(binaryNum, position) {
    // Bit-shifts according to zero-indexed position
    const mask = 1 << position;
    const query = binaryNum & mask;
    return Boolean(query);
}
exports.getBitsFrom = getBitsFrom;

},{}],62:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposableBuffer = void 0;
const smart_buffer_1 = require("smart-buffer");
const varuint_1 = require("./varuint");
const bitmask_1 = require("./bitmask");
const bignumber_1 = require("./bignumber");
/**
 * A highly composable buffer, by defining a list of composer, it allows bi-directional buffer to object serialization.
 * In short, you compose from a Buffer to Object or an Object to a Buffer. Little endian by design.
 *
 * It is also deeply recursive by default allow cascading object composing.
 */
class ComposableBuffer {
    constructor(data) {
        if (data instanceof smart_buffer_1.SmartBuffer) {
            // @ts-expect-error as data will be mapped by fromBuffer()
            this.data = {};
            this.fromBuffer(data);
        }
        else {
            this.data = data;
        }
    }
    fromBuffer(buffer) {
        for (const mapping of this.composers(this.data)) {
            mapping.fromBuffer(buffer);
        }
    }
    toBuffer(buffer) {
        for (const mapping of this.composers(this.data)) {
            mapping.toBuffer(buffer);
        }
    }
    toHex() {
        const buffer = new smart_buffer_1.SmartBuffer();
        this.toBuffer(buffer);
        return buffer.toString('hex');
    }
    /**
     * Deeply toObject() mapper.
     * This unwrap the data in ComposableBuffer and convert all ComposableBuffer into their raw object.
     * This make it compatible to convert into JSON with JSON.stringify()
     * @return {Object}
     */
    toObject() {
        function toObject(value) {
            if (value instanceof ComposableBuffer) {
                return value.toObject();
            }
            if (Array.isArray(value) && value.length > 0) {
                return value.map(v => toObject(v));
            }
            return value;
        }
        const json = {};
        for (const [key, value] of Object.entries(this.data)) {
            json[key] = toObject(value);
        }
        return json;
    }
    /**
     * @return BufferComposer that does nothing
     */
    static empty() {
        return {
            fromBuffer(_) {
            },
            toBuffer(_) {
            }
        };
    }
    /**
     * The length of the array is set with VarUInt in the first sequence of 1 - 9 bytes.
     *
     * @param getter to read array of ComposableBuffer Object from to buffer
     * @param setter to set array of ComposableBuffer Object from buffer
     * @param asC map single object into ComposableBuffer Object
     *
     * @see array if length is not given but known
     */
    static varUIntArray(getter, setter, asC) {
        return {
            fromBuffer: (buffer) => {
                const length = varuint_1.readVarUInt(buffer);
                const array = [];
                for (let i = 0; i < length; i++) {
                    array.push(asC(buffer).data);
                }
                setter(array);
            },
            toBuffer: (buffer) => {
                const array = getter();
                varuint_1.writeVarUInt(array.length, buffer);
                array.forEach(data => asC(data).toBuffer(buffer));
            }
        };
    }
    /**
     * The length of the array must be known and given to the composer, use varUIntArray if length is set as VarUInt.
     *
     * @param getter to read array of ComposableBuffer Object from to buffer
     * @param setter to set array of ComposableBuffer Object from buffer
     * @param asC map single object into ComposableBuffer Object
     * @param getLength of the array
     *
     * @see use varUIntArray if length is set as VarUInt
     */
    static array(getter, setter, asC, getLength) {
        return {
            fromBuffer: (buffer) => {
                const array = [];
                for (let i = 0; i < getLength(); i++) {
                    array.push(asC(buffer).data);
                }
                setter(array);
            },
            toBuffer: (buffer) => {
                const array = getter();
                array.forEach(data => asC(data).toBuffer(buffer));
            }
        };
    }
    /**
     * The length depends on the Composable buffer composer configuration
     *
     * @param getter to read single ComposableBuffer Object from to buffer
     * @param setter to set single ComposableBuffer Object from buffer
     * @param asC map object into ComposableBuffer Object
     */
    static single(getter, setter, asC) {
        return {
            fromBuffer: (buffer) => {
                setter(asC(buffer).data);
            },
            toBuffer: (buffer) => {
                asC(getter()).toBuffer(buffer);
            }
        };
    }
    /**
     * HEX String with length specified, encoded into Buffer as the same order of the Hex String.
     * In short this read a hex and push it into the Buffer. It will not re-order the endian.
     *
     * @param length of the bytes to read/set
     * @param getter to read HEX String and write as the same ordered Buffer
     * @param setter to read ordered Buffer and set as the same ordered HEX String
     * @throws Error if length != getter().length in set
     */
    static hex(length, getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const buff = Buffer.from(buffer.readBuffer(length));
                setter(buff.toString('hex'));
            },
            toBuffer: (buffer) => {
                const hex = getter();
                if (hex.length !== length * 2) {
                    throw new Error('ComposableBuffer.hex.toBuffer invalid as length != getter().length');
                }
                const buff = Buffer.from(hex, 'hex');
                buffer.writeBuffer(buff);
            }
        };
    }
    /**
     * HEX String with length specified, encoded into Buffer as the same order of the Hex String.
     * In short this read a hex and push it into the Buffer. It will not re-order the endian.
     *
     * When hex is `undefined` it will write `0x00` signifying zero byte length.
     *
     * @param getter to read HEX String. Writes its length then write the HEX string. Defaults to empty string.
     * @param setter to read ordered Buffer and set as the same ordered HEX String
     */
    static varUIntOptionalHex(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const length = varuint_1.readVarUInt(buffer);
                if (length > 0) {
                    const buff = Buffer.from(buffer.readBuffer(length));
                    setter(buff.toString('hex'));
                }
            },
            toBuffer: (buffer) => {
                const hex = getter();
                if (hex !== undefined) {
                    if (hex === '') {
                        throw new Error('ComposableBuffer.varUIntOptionalHex.toBuffer attempting to write empty buffer');
                    }
                    const buff = Buffer.from(hex, 'hex');
                    varuint_1.writeVarUInt(buff.length, buffer);
                    buffer.writeBuffer(buff);
                }
                else {
                    varuint_1.writeVarUInt(0x00, buffer);
                }
            }
        };
    }
    /**
     * Same behavior with `hex` when the field is defined
     * `toBuffer` resulted empty SmartBuffer
     *
     * @param length of the bytes to read/set
     * @param getter to read HEX String and write as the same ordered Buffer
     * @param setter to read ordered Buffer and set as the same ordered HEX String
     * @throws Error if getter() is defined && length != getter().length in set
     */
    static optionalHex(length, getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const buff = Buffer.from(buffer.readBuffer(length));
                if (buff.length > 0) {
                    setter(buff.toString('hex'));
                }
            },
            toBuffer: (buffer) => {
                const hex = getter();
                if (hex === undefined) {
                    return;
                }
                if (hex.length !== length * 2) {
                    throw new Error('ComposableBuffer.optionalHex.toBuffer invalid as length != getter().length');
                }
                buffer.writeBuffer(Buffer.from(hex, 'hex'));
            }
        };
    }
    /**
     * BE ordered HEX String with length specified, encoded in LE order buffer.
     * Different from BufferComposer.hex, this will reorder the Buffer from LE to BE and BE to LE.
     *
     * @param length of the bytes to read/set
     * @param getter to read BE ordered HEX String and write as LE ordered Buffer
     * @param setter to read LE ordered Buffer and set as BE ordered HEX String
     * @throws Error if length != getter().length in set
     */
    static hexBEBufferLE(length, getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const buff = Buffer.from(buffer.readBuffer(length)).reverse();
                setter(buff.toString('hex'));
            },
            toBuffer: (buffer) => {
                const hex = getter();
                if (hex.length !== length * 2) {
                    throw new Error('ComposableBuffer.hexBEBufferLE.toBuffer invalid as length != getter().length');
                }
                const buff = Buffer.from(hex, 'hex').reverse();
                buffer.writeBuffer(buff);
            }
        };
    }
    /**
     * UTF-8 string with length specified, encoded in LE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param length of the bytes to read/set
     * @param getter to read BE ordered String and write as LE ordered Buffer
     * @param setter to read LE ordered Buffer and set as BE ordered String
     * @throws Error if length != getter().length in set
     */
    static utf8LE(length, getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const buff = Buffer.from(buffer.readBuffer(length)).reverse();
                setter(buff.toString('utf-8'));
            },
            toBuffer: (buffer) => {
                const buff = Buffer.from(getter(), 'utf-8').reverse();
                if (buff.length !== length) {
                    throw new Error('ComposableBuffer.utf8LE.toBuffer invalid as length != getter().length');
                }
                buffer.writeBuffer(buff);
            }
        };
    }
    /**
     * UTF-8 string with length specified, encoded in BE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param length of the bytes to read/set
     * @param getter to read BE ordered String and write as BE ordered Buffer
     * @param setter to read BE ordered Buffer and set as BE ordered String
     * @throws Error if length != getter().length in set
     */
    static utf8BE(length, getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const buff = Buffer.from(buffer.readBuffer(length));
                setter(buff.toString('utf-8'));
            },
            toBuffer: (buffer) => {
                const buff = Buffer.from(getter(), 'utf-8');
                if (buff.length !== length) {
                    throw new Error('ComposableBuffer.utf8BE.toBuffer invalid as length != getter().length');
                }
                buffer.writeBuffer(buff);
            }
        };
    }
    /**
     * VarUInt sized UTF-8 string, encoded in LE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param getter to read BE ordered String and write as LE ordered Buffer
     * @param setter to read LE ordered Buffer and set as BE ordered String
     */
    static varUIntUtf8LE(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const length = varuint_1.readVarUInt(buffer);
                const buff = Buffer.from(buffer.readBuffer(length)).reverse();
                setter(buff.toString('utf-8'));
            },
            toBuffer: (buffer) => {
                const buff = Buffer.from(getter(), 'utf-8').reverse();
                varuint_1.writeVarUInt(buff.length, buffer);
                buffer.writeBuffer(buff);
            }
        };
    }
    /**
     * VarUInt sized UTF-8 string, encoded in BE order buffer.
     * String is always BE, as Javascript is uses BE by default.
     *
     * @param getter to read BE ordered String and write as BE ordered Buffer
     * @param setter to read BE ordered Buffer and set as BE ordered String
     */
    static varUIntUtf8BE(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const length = varuint_1.readVarUInt(buffer);
                const buff = Buffer.from(buffer.readBuffer(length));
                setter(buff.toString('utf-8'));
            },
            toBuffer: (buffer) => {
                const buff = Buffer.from(getter(), 'utf-8');
                varuint_1.writeVarUInt(buff.length, buffer);
                buffer.writeBuffer(buff);
            }
        };
    }
    /**
     * VarUInt sized hex string, encoded into Buffer as the same order of the hex String.
     * In short this read a VarUInt sized hex and push it into the Buffer. It will not re-order the endian.
     *
     * @param getter to read hex String and write as the same ordered Buffer
     * @param setter to read ordered Buffer and set as the same ordered hex String
     */
    static varUIntHex(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const length = varuint_1.readVarUInt(buffer);
                const buff = Buffer.from(buffer.readBuffer(length));
                setter(buff.toString('hex'));
            },
            toBuffer: (buffer) => {
                const buff = Buffer.from(getter(), 'hex');
                varuint_1.writeVarUInt(buff.length, buffer);
                buffer.writeBuffer(buff);
            }
        };
    }
    /**
     * Unsigned Int8, 1 byte
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uInt8(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(buffer.readUInt8());
            },
            toBuffer: (buffer) => {
                buffer.writeUInt8(getter());
            }
        };
    }
    /**
     * Unsigned Int16, 2 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uInt16(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(buffer.readUInt16LE());
            },
            toBuffer: (buffer) => {
                buffer.writeUInt16LE(getter());
            }
        };
    }
    /**
     * Signed Int32, 4 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static int32(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(buffer.readInt32LE());
            },
            toBuffer: (buffer) => {
                buffer.writeInt32LE(getter());
            }
        };
    }
    /**
     * Unsigned Int32, 4 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uInt32(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(buffer.readUInt32LE());
            },
            toBuffer: (buffer) => {
                buffer.writeUInt32LE(getter());
            }
        };
    }
    /**
     * Unsigned BigNumber, 8 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static bigNumberUInt64(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(bignumber_1.readBigNumberUInt64(buffer));
            },
            toBuffer: (buffer) => {
                bignumber_1.writeBigNumberUInt64(getter(), buffer);
            }
        };
    }
    /**
     * Unsigned satoshi as BigNumber, 8 bytes
     * BigNumber is multiplied/divided by 100,000,000
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static satoshiAsBigNumber(getter, setter) {
        return ComposableBuffer.bigNumberUInt64(() => {
            return getter().multipliedBy(bignumber_1.ONE_HUNDRED_MILLION);
        }, v => {
            setter(v.dividedBy(bignumber_1.ONE_HUNDRED_MILLION));
        });
    }
    /**
     * VarUInt helper method, 1 - 9 bytes
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static varUInt(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(varuint_1.readVarUInt(buffer));
            },
            toBuffer: (buffer) => {
                varuint_1.writeVarUInt(getter(), buffer);
            }
        };
    }
    /**
     * Imposing mask over bits method, 1 byte
     *
     * @param length of the input array to read/set
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static bitmask1Byte(length, getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const num = buffer.readUInt8();
                const array = [];
                for (let i = 0; i < length; i += 1) {
                    array.unshift(bitmask_1.getBitsFrom(num, i));
                }
                setter(array);
            },
            toBuffer: (buffer) => {
                const bools = getter().map(bool => bool.toString().toLowerCase() === 'true' ? 1 : 0);
                const num = parseInt(bools.join(''), 2);
                buffer.writeBuffer(Buffer.from([num]));
            }
        };
    }
    /**
     * Unsigned Boolean 1 byte, 1 = true, 0 = false
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uBool8(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(buffer.readUInt8() === 1);
            },
            toBuffer: (buffer) => {
                const v = getter() ? 1 : 0;
                buffer.writeBuffer(Buffer.from([v]));
            }
        };
    }
    /**
     * Unsigned Boolean 4 bytes, 1 = true, 0 = false
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static uBool32(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                setter(buffer.readInt32BE() === 1);
            },
            toBuffer: (buffer) => {
                const v = getter() ? 1 : 0;
                buffer.writeBuffer(Buffer.from([0, 0, 0, v]));
            }
        };
    }
    /**
     * maxPrice as BigNumber, first 8 bytes for integer, last 8 bytes for fraction
     *
     * @param getter to read from to buffer
     * @param setter to set to from buffer
     */
    static maxPriceAsBigNumber(getter, setter) {
        return {
            fromBuffer: (buffer) => {
                const integer = bignumber_1.readBigNumberUInt64(buffer);
                const fraction = bignumber_1.readBigNumberUInt64(buffer);
                // Disabled as it's not enforced
                // NOTE(canonbrother): max price default value is max int64 (9223372036854775807)
                // https://github.com/DeFiCh/ain/blob/aed00d09075094a3a0cedebde5248c006216ba09/src/masternodes/rpc_poolpair.cpp#L115-L123
                // if (fraction.gt(new BigNumber('99999999')) && !fraction.eq(MAX_INT64)) {
                //   throw new Error('Too many decimals read from buffer. Will lose precision with more than 8 decimals')
                // }
                if (integer.eq(bignumber_1.MAX_INT64) && fraction.eq(bignumber_1.MAX_INT64)) {
                    setter(bignumber_1.MAX_INT64);
                }
                else {
                    setter(integer.plus(fraction.dividedBy(bignumber_1.ONE_HUNDRED_MILLION)));
                }
            },
            toBuffer: (buffer) => {
                const maxPrice = getter();
                if (maxPrice.decimalPlaces() > 8) {
                    throw new Error('Too many decimals to be correctly represented. Will lose precision with more than 8 decimals');
                }
                if (maxPrice.eq(bignumber_1.MAX_INT64)) {
                    bignumber_1.writeBigNumberUInt64(bignumber_1.MAX_INT64, buffer);
                    bignumber_1.writeBigNumberUInt64(bignumber_1.MAX_INT64, buffer);
                }
                else {
                    const n = maxPrice.multipliedBy(bignumber_1.ONE_HUNDRED_MILLION);
                    const fraction = n.mod(bignumber_1.ONE_HUNDRED_MILLION);
                    const integer = n.minus(fraction).dividedBy(bignumber_1.ONE_HUNDRED_MILLION);
                    bignumber_1.writeBigNumberUInt64(integer, buffer);
                    bignumber_1.writeBigNumberUInt64(fraction, buffer);
                }
            }
        };
    }
}
exports.ComposableBuffer = ComposableBuffer;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bignumber":60,"./bitmask":61,"./varuint":64,"buffer":3,"smart-buffer":273}],63:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./bignumber"), exports);
__exportStar(require("./bitmask"), exports);
__exportStar(require("./composer"), exports);
__exportStar(require("./varuint"), exports);

},{"./bignumber":60,"./bitmask":61,"./composer":62,"./varuint":64}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.byteLength = exports.readVarUInt = exports.writeVarUInt = void 0;
/**
 * @param {number} num to write as VarUInt (1-9 bytes)
 * @param {SmartBuffer} buffer to write to
 */
function writeVarUInt(num, buffer) {
    validateUInt53(num);
    // 8 bit (1 byte)
    if (num < 0xfd) {
        buffer.writeUInt8(num);
        return;
    }
    // 16 bit (1 + 2 bytes)
    if (num <= 0xffff) {
        buffer.writeUInt8(0xfd);
        buffer.writeUInt16LE(num);
        return;
    }
    // 32 bit (1 + 4 bytes)
    if (num <= 0xffffffff) {
        buffer.writeUInt8(0xfe);
        buffer.writeUInt32LE(num);
        return;
    }
    // 64 bit (1 + 8 bytes)
    buffer.writeUInt8(0xff);
    buffer.writeUInt32LE(num >>> 0);
    buffer.writeUInt32LE((num / 0x100000000) | 0);
}
exports.writeVarUInt = writeVarUInt;
/**
 * Read VarUInt as number
 * @param {SmartBuffer} buffer to read VarUInt from (1-9 bytes)
 * @throws RangeError 'out of Number.MAX_SAFE_INTEGER range' when it's out of MAX_SAFE_INTEGER
 */
function readVarUInt(buffer) {
    const first = buffer.readUInt8();
    switch (first) {
        case 0xfd: // 16 bit (1 + 2 bytes)
            return buffer.readUInt16LE();
        case 0xfe: // 32 bit (1 + 4 bytes)
            return buffer.readUInt32LE();
        case 0xff: { // 64 bit (1 + 8 bytes)
            const lo = buffer.readUInt32LE();
            const hi = buffer.readUInt32LE();
            const num = (hi * 0x0100000000) + lo;
            validateUInt53(num);
            return num;
        }
        default: // 8 bit (1 byte)
            return first;
    }
}
exports.readVarUInt = readVarUInt;
/**
 * @param {number} num to get total number bytes (1-9 bytes)
 */
function byteLength(num) {
    validateUInt53(num);
    return num < 0xfd ? 1 : num <= 0xffff ? 3 : num <= 0xffffffff ? 5 : 9;
}
exports.byteLength = byteLength;
/**
 * @param {number} num to validate
 * @throws RangeError 'out of Number.MAX_SAFE_INTEGER range' when it's out of MAX_SAFE_INTEGER
 */
function validateUInt53(num) {
    if (num < 0 || num > Number.MAX_SAFE_INTEGER || num % 1 !== 0) {
        throw new RangeError('out of Number.MAX_SAFE_INTEGER range');
    }
}

},{}],65:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AES256 = void 0;
const randombytes_1 = __importDefault(require("randombytes"));
const browserify_aes_1 = __importDefault(require("browserify-aes"));
const hash_1 = require("./hash");
const CIPHER_ALGORITHM = 'aes-256-ctr';
/**
 * Encrypt a clear-text message using AES-256 plus a random Initialization Vector.
 * @see https://github.com/JamesMGreene/node-aes256
 *
 * @param {Buffer} key  A passphrase of any length to used to generate a symmetric session key.
 * @param {Buffer} data  The clear-text message or buffer to be encrypted.
 * @param {(number) => Buffer} [rng = randomBytes] cryptographically strong random values generator required for IV
 * @returns {Buffer}
 */
function encrypt(key, data, rng = randombytes_1.default) {
    const sha256 = hash_1.SHA256(key);
    const initVector = rng(16);
    if (initVector.length !== 16) {
        throw new Error('Initialization vector must be 16 bytes long');
    }
    const cipher = browserify_aes_1.default.createCipheriv(CIPHER_ALGORITHM, sha256, initVector);
    const ciphertext = cipher.update(data);
    return Buffer.concat([initVector, ciphertext, cipher.final()]);
}
/**
 * Decrypt an encrypted message back to clear-text using AES-256 plus a random Initialization Vector.
 * @see https://github.com/JamesMGreene/node-aes256
 *
 * @param {Buffer} key A passphrase of any length to used to generate a symmetric session key.
 * @param {Buffer} encrypted The encrypted message to be decrypted.
 * @returns {Buffer} The original plain-text message or buffer.
 */
function decrypt(key, encrypted) {
    if (encrypted.length < 17) {
        throw new Error('Provided "encrypted" must decrypt to a non-empty string or buffer');
    }
    const sha256 = hash_1.SHA256(key);
    const initVector = encrypted.slice(0, 16);
    const decipher = browserify_aes_1.default.createDecipheriv(CIPHER_ALGORITHM, sha256, initVector);
    const ciphertext = encrypted.slice(16);
    const deciphered = decipher.update(ciphertext);
    const decipherFinal = decipher.final();
    return Buffer.concat([deciphered, decipherFinal]);
}
exports.AES256 = {
    encrypt,
    decrypt
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./hash":70,"browserify-aes":179,"buffer":3,"randombytes":246}],66:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bech32 = void 0;
const bech32_1 = require("bech32");
const hash_1 = require("./hash");
/**
 * @param {Buffer} hash160 to format into bech32
 * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
 * @param {number} [version=0x00] witness version, OP_0
 * @return {string} bech32 encoded address
 * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 */
function toBech32(hash160, hrp, version = 0x00) {
    const words = bech32_1.bech32.toWords(hash160);
    words.unshift(version);
    return bech32_1.bech32.encode(hrp, words);
}
/**
 * @param {string} address to decode from bech32
 * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
 * @param {number} [version] witness version, OP_0
 * @return {Buffer} hash160 of the pubkey
 * @see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki
 */
function fromBech32(address, hrp, version) {
    const { prefix, words } = bech32_1.bech32.decode(address);
    if (hrp !== undefined && prefix !== hrp) {
        throw new Error('Invalid HRP: human readable part');
    }
    const witnessVersion = words.splice(0, 1)[0];
    if (version !== undefined && version !== witnessVersion) {
        throw new Error('Invalid witness version');
    }
    return Buffer.from(bech32_1.bech32.fromWords(words));
}
exports.Bech32 = {
    /**
     * @param {Buffer} pubKey to format into bech32
     * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
     * @param {number} [version=0x00] witness version, OP_0
     * @return {string} bech32 encoded address
     */
    fromPubKey(pubKey, hrp, version = 0x00) {
        if (pubKey.length !== 33) {
            throw new Error('InvalidPubKeyLength');
        }
        const hash = hash_1.HASH160(pubKey);
        return toBech32(hash, hrp, version);
    },
    /**
     * @param {Buffer} hash160 to format into bech32
     * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
     * @param {number} [version=0x00] witness version, OP_0
     * @return {string} bech32 encoded address
     */
    fromHash160(hash160, hrp, version = 0x00) {
        return toBech32(hash160, hrp, version);
    },
    /**
     * @param {string} address to decode from bech32
     * @param {'df'|'tf'|'bcrt'} hrp is the human readable part
     * @param {number} [version] witness version, OP_0
     * @return {Buffer} hash160 of the pubkey
     */
    toHash160(address, hrp, version) {
        return fromBech32(address, hrp, version);
    }
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./hash":70,"bech32":166,"buffer":3}],67:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bs58 = void 0;
const bs58_1 = __importDefault(require("bs58"));
const hash_1 = require("./hash");
function _checksum(twentyOneBytes) {
    return hash_1.SHA256(hash_1.SHA256(twentyOneBytes)).slice(0, 4);
}
/**
 * Decode a base58 address into 20 bytes data, for p2pkh and p2sh use
 * @param {string} base58 33 to 35 characters string (utf8)
 * @returns {DecodedB58} 20 bytes data + 1 byte prefix
 */
function toHash160(base58) {
    const buffer = bs58_1.default.decode(base58);
    if (buffer.length !== 25) {
        throw new Error('InvalidBase58Address');
    }
    const withPrefix = buffer.slice(0, 21);
    const checksum = buffer.slice(21, 25);
    const expectedChecksum = _checksum(withPrefix);
    if (checksum.compare(expectedChecksum) !== 0) {
        throw new Error('InvalidBase58Address');
    }
    return {
        prefix: withPrefix[0],
        buffer: withPrefix.slice(1, 21)
    };
}
/**
 * To create Base58 address using 20 bytes data + prefix, for p2pkh and p2sh use
 * @param {Buffer|string} data 20 bytes Buffer or 40 characters string
 * @param {number} prefix max = 255 = 1 byte
 * @returns Base58 address (in utf8)
 */
function fromHash160(data, prefix) {
    if (typeof data === 'string') {
        // 40 hex char string only
        if (data.length !== 40) {
            throw new Error('InvalidDataLength');
        }
    }
    else if (data.length !== 20) {
        // 20 bytes buffer only
        throw new Error('InvalidDataLength');
    }
    if (prefix > 255) {
        throw new Error('InvalidVersionPrefix');
    }
    const buffer = typeof data === 'string' ? Buffer.from(data, 'hex') : data;
    const withPrefix = Buffer.from([prefix, ...buffer]);
    const checksum = _checksum(withPrefix);
    return bs58_1.default.encode(Buffer.from([...withPrefix, ...checksum]));
}
/**
 * To create Base58 address using a raw 33 bytes (compressed) public key, for p2pkh and p2sh use
 * @param {Buffer} pubKey 33 bytes long public key
 * @param {number} prefix max = 255 = 1 byte
 * @returns {string} base58 encoded string
 */
function fromPubKey(pubKey, prefix) {
    if (pubKey.length !== 33) {
        throw new Error('InvalidPubKeyLength');
    }
    if (prefix > 255) {
        throw new Error('InvalidVersionPrefix');
    }
    const hash = hash_1.HASH160(pubKey);
    return fromHash160(hash, prefix);
}
exports.Bs58 = {
    toHash160,
    fromPubKey,
    fromHash160
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./hash":70,"bs58":194,"buffer":3}],68:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DERSignature = void 0;
const bip66_1 = __importDefault(require("bip66"));
/**
 * Distinguished Encoding Rules (DER) Signatures
 *
 * The MIT License (MIT)
 * Copyright (c) 2011-2020 bitcoinjs-lib contributors
 *
 * @see https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
 * @see https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/script_signature.ts
 */
exports.DERSignature = {
    /**
     * @param signature to encode into DER Signature
     */
    encode(signature) {
        const r = DER.to(signature.slice(0, 32));
        const s = DER.to(signature.slice(32, 64));
        return bip66_1.default.encode(r, s);
    },
    /**
     * @param derSignature to decode
     */
    decode(derSignature) {
        const { r, s } = bip66_1.default.decode(derSignature);
        return Buffer.concat([
            DER.from(r),
            DER.from(s)
        ], 64);
    }
};
const DER = {
    to(buffer) {
        let i = 0;
        while (buffer[i] === 0) {
            ++i;
        }
        if (i === buffer.length) {
            return Buffer.alloc(1, 0);
        }
        buffer = buffer.slice(i);
        if ((buffer[0] & 0x80) !== 0) {
            return Buffer.concat([
                Buffer.alloc(1, 0),
                buffer
            ], 1 + buffer.length);
        }
        return buffer;
    },
    from(der) {
        if (der[0] === 0x00) {
            der = der.slice(1);
        }
        const buffer = Buffer.alloc(32, 0);
        const copyStart = Math.max(0, 32 - der.length);
        der.copy(buffer, copyStart);
        return buffer;
    }
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"bip66":174,"buffer":3}],69:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Elliptic = void 0;
const randombytes_1 = __importDefault(require("randombytes"));
const tiny_secp256k1_1 = __importDefault(require("tiny-secp256k1"));
const der_1 = require("./der");
/**
 * Wraps secp256k1 from 'tiny-secp256k1' & 'bip66'
 */
class SECP256K1 {
    constructor(privKey) {
        this.privKey = privKey;
        const pubKey = tiny_secp256k1_1.default.pointFromScalar(privKey, true);
        if (pubKey === null) {
            throw new Error('point at infinity');
        }
        this.pubKey = pubKey;
    }
    privateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.privKey;
        });
    }
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.pubKey;
        });
    }
    sign(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            let signature = tiny_secp256k1_1.default.sign(hash, this.privKey);
            const extraData = Buffer.alloc(32, 0);
            let counter = 0;
            // if first try is lowR, skip the loop, for second try and on, add extra entropy counting up
            while (signature[0] > 0x7f) {
                counter++;
                extraData.writeUIntLE(counter, 0, 6);
                // @ts-expect-error
                signature = tiny_secp256k1_1.default.signWithEntropy(hash, this.privKey, extraData);
            }
            return der_1.DERSignature.encode(signature);
        });
    }
    verify(hash, derSignature) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = der_1.DERSignature.decode(derSignature);
            return tiny_secp256k1_1.default.verify(hash, this.pubKey, signature);
        });
    }
}
exports.Elliptic = {
    /**
     * @param {Buffer} buffer in little endian
     * @return {SECP256K1} EllipticPair
     */
    fromPrivKey(buffer) {
        return new SECP256K1(buffer);
    },
    /**
     * @param {(number) => Buffer} [rng = randomBytes] cryptographically strong random values generator required
     * @return {SECP256K1} EllipticPair
     */
    random(rng = randombytes_1.default) {
        const buffer = rng(32);
        if (buffer.length !== 32) {
            throw new Error('Buffer length must be 32 bytes long');
        }
        return new SECP256K1(buffer);
    }
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./der":68,"buffer":3,"randombytes":246,"tiny-secp256k1":276}],70:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dSHA256 = exports.HASH160 = exports.SHA256 = exports.RIPEMD160 = void 0;
const create_hash_1 = __importDefault(require("create-hash"));
/**
 * @param {Buffer} buffer to RIPEMD160(buffer)
 */
function RIPEMD160(buffer) {
    return create_hash_1.default('rmd160').update(buffer).digest();
}
exports.RIPEMD160 = RIPEMD160;
/**
 * @param {Buffer} buffer to SHA256(buffer)
 */
function SHA256(buffer) {
    return create_hash_1.default('sha256').update(buffer).digest();
}
exports.SHA256 = SHA256;
/**
 * @param {Buffer} buffer to RIPEMD160(SHA256(buffer))
 */
function HASH160(buffer) {
    return RIPEMD160(SHA256(buffer));
}
exports.HASH160 = HASH160;
/**
 * @param {Buffer} buffer to SHA256(SHA256(buffer))
 */
function dSHA256(buffer) {
    return SHA256(SHA256(buffer));
}
exports.dSHA256 = dSHA256;

},{"create-hash":199}],71:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./aes256"), exports);
__exportStar(require("./bech32"), exports);
__exportStar(require("./bs58"), exports);
__exportStar(require("./der"), exports);
__exportStar(require("./elliptic"), exports);
__exportStar(require("./hash"), exports);
__exportStar(require("./wif"), exports);

},{"./aes256":65,"./bech32":66,"./bs58":67,"./der":68,"./elliptic":69,"./hash":70,"./wif":72}],72:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WIF = void 0;
const wif_1 = __importDefault(require("wif"));
const elliptic_1 = require("./elliptic");
/**
 * @param {string} wifEncoded private key
 * @param {number} version network to optionally validate
 * @return {DecodedWIF}
 * @throws Error invalid network version if version mismatch
 */
function decode(wifEncoded, version) {
    return wif_1.default.decode(wifEncoded, version);
}
/**
 * Get a EllipticPair from WIF encoded private key
 *
 * @param {string} wifEncoded private key
 * @param {number} version network to optionally validate
 * @return {EllipticPair}
 * @throws Error invalid network version if version mismatch
 */
function decodeAsEllipticPair(wifEncoded, version) {
    const { privateKey } = decode(wifEncoded, version);
    return elliptic_1.Elliptic.fromPrivKey(privateKey);
}
/**
 * @param {number} version network version to encoded WIF with
 * @param {Buffer} privKey to encode
 * @return {string} encoded WIF
 */
function encode(version, privKey) {
    return wif_1.default.encode(version, privKey, true);
}
exports.WIF = {
    /**
     * @param {string} wif private key
     * @param {number} [version] network to optionally validate
     * @return {DecodedWIF}
     * @throws Error invalid network version if version mismatch
     */
    decode(wif, version) {
        return decode(wif, version);
    },
    /**
     * @param {number} version network version to encoded WIF with
     * @param {Buffer} privKey to encode
     * @return {string} encoded WIF
     */
    encode(version, privKey) {
        return encode(version, privKey);
    },
    /**
     * Get a EllipticPair from WIF encoded private key
     *
     * @param {string} wif private key
     * @param {number} [version] network to optionally validate
     * @return EllipticPair
     * @throws Error invalid network version if version mismatch
     */
    asEllipticPair(wif, version) {
        return decodeAsEllipticPair(wif, version);
    }
};

},{"./elliptic":69,"wif":284}],73:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JellyfishJSON = exports.LosslessNumber = exports.BigNumber = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
exports.BigNumber = bignumber_js_1.default;
const lossless_json_1 = require("lossless-json");
Object.defineProperty(exports, "LosslessNumber", { enumerable: true, get: function () { return lossless_json_1.LosslessNumber; } });
const remap_1 = require("./remap");
/**
 * Revive lossless as a type
 */
function reviveLosslessAs(transformer) {
    return (key, value) => {
        if (value instanceof lossless_json_1.LosslessNumber) {
            return transformer(value.toString());
        }
        return value;
    };
}
/**
 * JellyfishJSON allows parsing of JSON with 'lossless', 'bignumber' and 'number' numeric precision.
 */
exports.JellyfishJSON = {
    /**
     * Precision parses all numeric value as the given Precision.
     *
     * PrecisionPath selectively remap each numeric value based on the mapping provided,
     * defaults to number if precision is not provided for the key. This works deeply.
     *
     * @param {string} text JSON string to parse into object.
     * @param {Precision | PrecisionPath} precision Numeric precision to parse payload as.
     */
    parse(text, precision) {
        if (typeof precision === 'string') {
            switch (precision) {
                case 'lossless':
                    return lossless_json_1.parse(text);
                case 'bignumber':
                    return lossless_json_1.parse(text, reviveLosslessAs(string => new bignumber_js_1.default(string)));
                case 'number':
                    return lossless_json_1.parse(text, reviveLosslessAs(string => Number(string)));
                default:
                    throw new Error(`JellyfishJSON.parse ${precision} precision is not supported`);
            }
        }
        const losslessObj = lossless_json_1.parse(text);
        return remap_1.remap(losslessObj, precision);
    },
    /**
     * @param {any} value object to stringify, with no risk of losing precision.
     */
    stringify(value) {
        function replacer(key, value) {
            if (value instanceof bignumber_js_1.default) {
                return new lossless_json_1.LosslessNumber(value.toString());
            }
            return value;
        }
        return lossless_json_1.stringify(value, replacer);
    }
};

},{"./remap":74,"bignumber.js":167,"lossless-json":236}],74:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.remap = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lossless_json_1 = require("lossless-json");
/**
 * @param {any} losslessObj to deeply remap into bignumber or number.
 * @param {'bignumber' | PrecisionPath} precision path mapping
 */
function remap(losslessObj, precision) {
    return deepRemap(losslessObj, precision);
}
exports.remap = remap;
/**
 * @param {any} losslessObj to deeply remap
 * @param {'bignumber' | PrecisionPath} precision path mapping
 */
function deepRemap(losslessObj, precision) {
    if (losslessObj === null || losslessObj === undefined) {
        return losslessObj;
    }
    if (typeof precision !== 'object') {
        return reviveAs(losslessObj, precision);
    }
    if (Array.isArray(losslessObj)) {
        return losslessObj.map(obj => deepRemap(obj, precision));
    }
    if (losslessObj instanceof lossless_json_1.LosslessNumber) {
        return reviveLosslessAs(losslessObj);
    }
    for (const [key, value] of Object.entries(losslessObj)) {
        losslessObj[key] = deepRemap(value, precision[key]);
    }
    return losslessObj;
}
/**
 * Array will deeply remapped, object keys will be iterated on as keys.
 *
 * @param {any} losslessObj to revive
 * @param precision to use, specific 'bignumber' for BigNumber or values always ignored and default to number
 */
function reviveAs(losslessObj, precision) {
    if (losslessObj === null || losslessObj === undefined) {
        return losslessObj;
    }
    if (losslessObj instanceof lossless_json_1.LosslessNumber) {
        return reviveLosslessAs(losslessObj, precision);
    }
    if (Array.isArray(losslessObj)) {
        return losslessObj.map((v) => reviveAs(v, precision));
    }
    if (typeof losslessObj === 'object') {
        for (const [key, value] of Object.entries(losslessObj)) {
            losslessObj[key] = reviveAs(value, precision);
        }
    }
    return losslessObj;
}
/**
 * @param {LosslessNumber} losslessNum to revive as bignumber or number if precision != bignumber
 * @param {Precision} precision to use, specific 'bignumber' for BigNumber else always default to number
 */
function reviveLosslessAs(losslessNum, precision) {
    if (precision === 'lossless') {
        return losslessNum;
    }
    if (precision === 'bignumber') {
        return new bignumber_js_1.default(losslessNum.toString());
    }
    return Number(losslessNum.toString());
}

},{"bignumber.js":167,"lossless-json":236}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegTest = exports.TestNet = exports.MainNet = exports.getNetwork = void 0;
/**
 * @param network name
 * @return Network specific DeFi configuration
 */
function getNetwork(network) {
    switch (network) {
        case 'mainnet':
            return exports.MainNet;
        case 'testnet':
            return exports.TestNet;
        case 'regtest':
            return exports.RegTest;
        default:
            throw new Error(`${network} network not found`);
    }
}
exports.getNetwork = getNetwork;
/**
 * MainNet specific DeFi configuration.
 */
exports.MainNet = {
    name: 'mainnet',
    bech32: {
        hrp: 'df'
    },
    bip32: {
        publicPrefix: 0x0488b21e,
        privatePrefix: 0x0488ade4
    },
    wifPrefix: 0x80,
    pubKeyHashPrefix: 0x12,
    scriptHashPrefix: 0x5a,
    messagePrefix: '\x15Defi Signed Message:\n'
};
/**
 * TestNet specific DeFi configuration.
 */
exports.TestNet = {
    name: 'testnet',
    bech32: {
        hrp: 'tf'
    },
    bip32: {
        publicPrefix: 0x043587cf,
        privatePrefix: 0x04358394
    },
    wifPrefix: 0xef,
    pubKeyHashPrefix: 0xf,
    scriptHashPrefix: 0x80,
    messagePrefix: '\x15Defi Signed Message:\n'
};
/**
 * RegTest specific DeFi configuration.
 */
exports.RegTest = {
    name: 'regtest',
    bech32: {
        hrp: 'bcrt'
    },
    bip32: {
        publicPrefix: 0x043587cf,
        privatePrefix: 0x04358394
    },
    wifPrefix: 0xef,
    pubKeyHashPrefix: 0x6f,
    scriptHashPrefix: 0xc4,
    messagePrefix: '\x15Defi Signed Message:\n'
};

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegTestFoundationKeys = exports.RegTestGenesisKeys = void 0;
/**
 * As per:
 * https://github.com/DeFiCh/ain/blob/6dc990c45788d6806ea/src/chainparams.cpp#L664-L677
 * https://github.com/DeFiCh/ain/blob/6dc990c45788d6806ea/test/functional/test_framework/test_node.py#L121-L132
 *
 * 2 first and 2 last of genesis MNs acts as foundation members
 * @deprecated use RegTestFoundationKeys instead
 */
exports.RegTestGenesisKeys = [
    {
        owner: {
            address: 'mwsZw8nF7pKxWH8eoKL9tPxTpaFkz7QeLU',
            privKey: 'cRiRQ9cHmy5evDqNDdEV8f6zfbK6epi9Fpz4CRZsmLEmkwy54dWz'
        },
        operator: {
            address: 'mswsMVsyGMj1FzDMbbxw2QW3KvQAv2FKiy',
            privKey: 'cPGEaz8AGiM71NGMRybbCqFNRcuUhg3uGvyY4TFE1BZC26EW2PkC'
        }
    },
    {
        owner: {
            address: 'msER9bmJjyEemRpQoS8YYVL21VyZZrSgQ7',
            privKey: 'cSCmN1tjcR2yR1eaQo9WmjTMR85SjEoNPqMPWGAApQiTLJH8JF7W'
        },
        operator: {
            address: 'mps7BdmwEF2vQ9DREDyNPibqsuSRZ8LuwQ',
            privKey: 'cVNTRYV43guugJoDgaiPZESvNtnfnUW19YEjhybihwDbLKjyrZNV'
        }
    },
    {
        owner: {
            address: 'myF3aHuxtEuqqTw44EurtVs6mjyc1QnGUS',
            privKey: 'cSXiqwTiYzECugcvCT4PyPKz2yKaTST8HowFVBBjccZCPkX6wsE9'
        },
        operator: {
            address: 'mtbWisYQmw9wcaecvmExeuixG7rYGqKEU4',
            privKey: 'cPh5YaousYQ92tNd9FkiiS26THjSVBDHUMHZzUiBFbtGNS4Uw9AD'
        }
    },
    {
        owner: {
            address: 'mwyaBGGE7ka58F7aavH5hjMVdJENP9ZEVz',
            privKey: 'cVA52y8ABsUYNuXVJ17d44N1wuSmeyPtke9urw4LchTyKsaGDMbY'
        },
        operator: {
            address: 'n1n6Z5Zdoku4oUnrXeQ2feLz3t7jmVLG9t',
            privKey: 'cV9tJBgAnSfFmPaC6fWWvA9StLKkU3DKV7eXJHjWMUENQ8cKJDkL'
        }
    },
    {
        owner: {
            address: 'mgsE1SqrcfUhvuYuRjqy6rQCKmcCVKNhMu',
            privKey: 'cRJyBuQPuUhYzN5F2Uf35958oK9AzZ5UscRfVmaRr8ktWq6Ac23u'
        },
        operator: {
            address: 'mzqdipBJcKX9rXXxcxw2kTHC3Xjzd3siKg',
            privKey: 'cQYJ87qk39i3uFsXBZ2EkwdX1h72q1RQcX9V8X7PPydFPgujxrCy'
        }
    },
    {
        owner: {
            address: 'mud4VMfbBqXNpbt8ur33KHKx8pk3npSq8c',
            privKey: 'cPjeCNka7omVbKKfywPVQyBig9eopBHy6eJqLzrdJqMP4DXApkcb'
        },
        operator: {
            address: 'mk5DkY4qcV6CUpuxDVyD3AHzRq5XK9kbRN',
            privKey: 'cV6Hjhutf11RvFHaERkp52QNynm2ifNmtUfP8EwRRMg6NaaQsHTe'
        }
    },
    {
        owner: {
            address: 'bcrt1qyrfrpadwgw7p5eh3e9h3jmu4kwlz4prx73cqny',
            privKey: 'cR4qgUdPhANDVF3bprcp5N9PNW2zyogDx6DGu2wHh2qtJB1L1vQj'
        },
        operator: {
            address: 'bcrt1qmfvw3dp3u6fdvqkdc0y3lr0e596le9cf22vtsv',
            privKey: 'cVsa2wQvCjZZ54jGteQ8qiQbQLJQmZSBWriYUYyXbcaqUJFqK5HR'
        }
    },
    {
        owner: {
            address: 'bcrt1qyeuu9rvq8a67j86pzvh5897afdmdjpyankp4mu',
            privKey: 'cUX8AEUZYsZxNUh5fTS7ZGnF6SPQuTeTDTABGrp5dbPftCga2zcp'
        },
        operator: {
            address: 'bcrt1qurwyhta75n2g75u2u5nds9p6w9v62y8wr40d2r',
            privKey: 'cUp5EVEjuAGpemSuejP36TWWuFKzuCbUJ4QAKJTiSSB2vXzDLsJW'
        }
    }
];
exports.RegTestFoundationKeys = exports.RegTestGenesisKeys;

},{}],77:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Network"), exports);
__exportStar(require("./RegTestFoundationKeys"), exports);

},{"./Network":75,"./RegTestFoundationKeys":76}],78:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2WPKHTransactionBuilder = void 0;
const txn_builder_1 = require("./txn/txn_builder");
const txn_builder_dex_1 = require("./txn/txn_builder_dex");
const txn_builder_utxo_1 = require("./txn/txn_builder_utxo");
const txn_builder_account_1 = require("./txn/txn_builder_account");
const txn_builder_oracles_1 = require("./txn/txn_builder_oracles");
const txn_builder_liq_pool_1 = require("./txn/txn_builder_liq_pool");
const txn_builder_governance_1 = require("./txn/txn_builder_governance");
const txn_builder_icxorderbook_1 = require("./txn/txn_builder_icxorderbook");
const txn_builder_masternode_1 = require("./txn/txn_builder_masternode");
const txn_builder_loans_1 = require("./txn/txn_builder_loans");
__exportStar(require("./provider"), exports);
__exportStar(require("./txn/txn_fee"), exports);
__exportStar(require("./txn/txn_builder"), exports);
__exportStar(require("./txn/txn_builder_dex"), exports);
__exportStar(require("./txn/txn_builder_utxo"), exports);
__exportStar(require("./txn/txn_builder_account"), exports);
__exportStar(require("./txn/txn_builder_oracles"), exports);
__exportStar(require("./txn/txn_builder_loans"), exports);
__exportStar(require("./txn/txn_builder_liq_pool"), exports);
__exportStar(require("./txn/txn_builder_icxorderbook"), exports);
__exportStar(require("./txn/txn_builder_masternode"), exports);
/**
 * All in one transaction builder.
 * Currently only support sending from P2PKH operations.
 */
class P2WPKHTransactionBuilder extends txn_builder_1.P2WPKHTxnBuilder {
    constructor() {
        super(...arguments);
        this.dex = new txn_builder_dex_1.TxnBuilderDex(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.utxo = new txn_builder_utxo_1.TxnBuilderUtxo(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.account = new txn_builder_account_1.TxnBuilderAccount(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.liqPool = new txn_builder_liq_pool_1.TxnBuilderLiqPool(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.oracles = new txn_builder_oracles_1.TxnBuilderOracles(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.governance = new txn_builder_governance_1.TxnBuilderGovernance(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.icxorderbook = new txn_builder_icxorderbook_1.TxnBuilderICXOrderBook(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.masternode = new txn_builder_masternode_1.TxnBuilderMasternode(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
        this.loans = new txn_builder_loans_1.TxnBuilderLoans(this.feeProvider, this.prevoutProvider, this.ellipticPairProvider, this.network);
    }
}
exports.P2WPKHTransactionBuilder = P2WPKHTransactionBuilder;

},{"./provider":79,"./txn/txn_builder":80,"./txn/txn_builder_account":81,"./txn/txn_builder_dex":82,"./txn/txn_builder_governance":84,"./txn/txn_builder_icxorderbook":85,"./txn/txn_builder_liq_pool":86,"./txn/txn_builder_loans":87,"./txn/txn_builder_masternode":88,"./txn/txn_builder_oracles":89,"./txn/txn_builder_utxo":90,"./txn/txn_fee":91}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],80:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2WPKHTxnBuilder = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_transaction_signature_1 = require("@defichain/jellyfish-transaction-signature");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const txn_fee_1 = require("./txn_fee");
const txn_builder_error_1 = require("./txn_builder_error");
const MAX_FEE_RATE = new bignumber_js_1.default('0.00100000');
/**
 * Transaction builder for P2WPKH inputs.
 */
class P2WPKHTxnBuilder {
    constructor(feeProvider, prevoutProvider, ellipticPairProvider, network) {
        this.feeProvider = feeProvider;
        this.prevoutProvider = prevoutProvider;
        this.ellipticPairProvider = ellipticPairProvider;
        this.network = network;
    }
    /**
     * @return {Promise<Prevouts>}
     */
    allPrevouts() {
        return __awaiter(this, void 0, void 0, function* () {
            const prevouts = yield this.prevoutProvider.all();
            if (prevouts.length === 0) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.NO_PREVOUTS, 'no prevouts available to create a transaction');
            }
            return joinPrevouts(prevouts);
        });
    }
    /**
     * @param {BigNumber} minBalance to collect, required to form a transaction
     * @return {Promise<Prevouts>}
     */
    collectPrevouts(minBalance) {
        return __awaiter(this, void 0, void 0, function* () {
            const prevouts = yield this.prevoutProvider.collect(minBalance);
            if (prevouts.length === 0) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.NO_PREVOUTS, 'no prevouts available to create a transaction');
            }
            const joined = joinPrevouts(prevouts);
            if (minBalance.gt(joined.total)) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.MIN_BALANCE_NOT_ENOUGH, 'not enough balance after combing all prevouts');
            }
            return joined;
        });
    }
    /**
     * @param {Transaction} transaction to calculate P2WPKH fee for
     * @return {Promise<BigNumber>} fee for transaction
     */
    calculateFee(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const feeRate = yield this.feeProvider.estimate();
            if (MAX_FEE_RATE.lte(feeRate)) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.OVER_MAX_FEE_RATE, `attempting to use a fee rate higher than MAX_FEE_RATE of ${MAX_FEE_RATE.toFixed()} is not allowed`);
            }
            if (!feeRate.isFinite()) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_FEE_RATE, `fee rate ${feeRate.toString()} is invalid`);
            }
            return txn_fee_1.calculateFeeP2WPKH(feeRate, transaction);
        });
    }
    /**
     * Craft a transaction with OP_DEFI_TX from the output of OP_CODES.OP_DEFI_TX_.
     * This is a helper method for creating custom defi transactions.
     *
     * As DeFi custom transaction will always require small amount of DFI,
     * collectPrevouts() is set to search for at least 0.001 DFI amount of prevout.
     * This will also evidently merge small prevout during the operation.
     *
     * Do not use this if you don't know what you are doing. You might misplace funds.
     *
     * @param {OP_DEFI_TX} opDeFiTx to create
     * @param {Script} changeScript to send unspent to after deducting the fees
     * @param {BigNumber} [outValue=0] for the opDeFiTx, usually always be 0.
     */
    createDeFiTx(opDeFiTx, changeScript, outValue = new bignumber_js_1.default('0')) {
        return __awaiter(this, void 0, void 0, function* () {
            const minFee = outValue.plus(0.001); // see JSDoc above
            const { prevouts, vin, total } = yield this.collectPrevouts(minFee);
            const deFiOut = {
                value: outValue,
                script: {
                    stack: [jellyfish_transaction_1.OP_CODES.OP_RETURN, opDeFiTx]
                },
                tokenId: 0x00
            };
            const change = {
                value: total,
                script: changeScript,
                tokenId: 0x00
            };
            const txn = {
                version: jellyfish_transaction_1.DeFiTransactionConstants.Version,
                vin: vin,
                vout: [deFiOut, change],
                lockTime: 0x00000000
            };
            const fee = yield this.calculateFee(txn);
            change.value = total.minus(outValue).minus(fee);
            return yield this.sign(txn, prevouts);
        });
    }
    /**
     * @param {Transaction} transaction to sign
     * @param {Prevout[]} prevouts input to sign
     */
    sign(transaction, prevouts) {
        return __awaiter(this, void 0, void 0, function* () {
            const inputs = prevouts.map((prevout) => {
                const node = this.ellipticPairProvider.get(prevout);
                return {
                    prevout: prevout,
                    publicKey: () => __awaiter(this, void 0, void 0, function* () { return yield node.publicKey(); }),
                    sign: (hash) => __awaiter(this, void 0, void 0, function* () { return yield node.sign(hash); })
                };
            });
            try {
                return yield jellyfish_transaction_signature_1.TransactionSigner.sign(transaction, inputs);
            }
            catch (err) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.SIGN_TRANSACTION_ERROR, err.message);
            }
        });
    }
}
exports.P2WPKHTxnBuilder = P2WPKHTxnBuilder;
/**
 * @param {Prevout[]} prevouts to join
 * @return {Prevouts}
 */
function joinPrevouts(prevouts) {
    const vin = prevouts.map((prevout) => {
        return {
            txid: prevout.txid,
            index: prevout.vout,
            script: { stack: [] },
            sequence: 0xffffffff
        };
    });
    const total = prevouts
        .map(out => out.value)
        .reduce((a, b) => a.plus(b), new bignumber_js_1.default(0));
    return { prevouts, vin, total };
}

},{"./txn_builder_error":83,"./txn_fee":91,"@defichain/jellyfish-transaction":94,"@defichain/jellyfish-transaction-signature":92,"bignumber.js":167}],81:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderAccount = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
const txn_builder_error_1 = require("./txn_builder_error");
class TxnBuilderAccount extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Requires UTXO in the same amount + fees to create a transaction.
     *
     * @param {UtxosToAccount} utxosToAccount txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @throws {TxnBuilderError} if 'utxosToAccount.to' length is less than `1`
     * @throws {TxnBuilderError} if 'utxosToAccount.to[any].balances' length is not `1`
     * @throws {TxnBuilderError} if 'utxosToAccount.to[any].balances[0].token' is not `0`\
     * @returns {Promise<TransactionSegWit>}
     */
    utxosToAccount(utxosToAccount, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (utxosToAccount.to.length < 1) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_UTXOS_TO_ACCOUNT_OUTPUT, 'Conversion output `utxosToAccount.to` array length must be greater than or equal to one');
            }
            for (let i = 0; i < utxosToAccount.to.length; i++) {
                const sb = utxosToAccount.to[i];
                if (sb.balances.length !== 1) {
                    throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_UTXOS_TO_ACCOUNT_OUTPUT, 'Each `utxosToAccount.to` array `balances` array length must be one');
                }
                if (sb.balances[0].token !== 0x00) {
                    throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_UTXOS_TO_ACCOUNT_OUTPUT, 'Each `utxosToAccount.to` array `balances[0].token` must be 0x00, only DFI supported');
                }
            }
            const amountToConvert = utxosToAccount.to.reduce((total, dest) => (total.plus(dest.balances[0].amount)), new bignumber_js_1.default(0));
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_UTXOS_TO_ACCOUNT(utxosToAccount), changeScript, amountToConvert);
        });
    }
    /**
     *
     * @param {AccountToUtxos} accountToUtxos txn to create
     * @param {Script} destinationScript vout destination, for both utxos minted and change after deducted fee
     * @throws {TxnBuilderError} if 'accountToUtxos.balances' length is not `1`
     * @throws {TxnBuilderError} if 'accountToUtxos.balances[0].token' is not `0`
     * @throws {TxnBuilderError} if 'accountToUtxos.mintingOutputsStart' is not `2`, vout[0] = DfTx, vout[1] = change, vout[2] = new minted utxos
     * @returns {Promise<TransactionSegWit>}
     */
    accountToUtxos(accountToUtxos, destinationScript) {
        return __awaiter(this, void 0, void 0, function* () {
            if (accountToUtxos.balances.length !== 1) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ACCOUNT_TO_UTXOS_INPUT, 'Conversion output `accountToUtxos.balances` array length must be one');
            }
            if (accountToUtxos.balances[0].token !== 0x00) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ACCOUNT_TO_UTXOS_INPUT, '`accountToUtxos.balances[0].token` must be 0x00, only DFI support');
            }
            if (accountToUtxos.mintingOutputsStart !== 2) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ACCOUNT_TO_UTXOS_INPUT, '`accountToUtxos.mintingOutputsStart` must be `2` for simplicity');
            }
            const minFee = new bignumber_js_1.default(0.001);
            const { prevouts, vin, total } = yield this.collectPrevouts(minFee);
            const deFiOut = {
                value: new bignumber_js_1.default(0),
                script: {
                    stack: [
                        jellyfish_transaction_1.OP_CODES.OP_RETURN,
                        jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ACCOUNT_TO_UTXOS(accountToUtxos)
                    ]
                },
                tokenId: 0x00
            };
            const out = {
                value: accountToUtxos.balances[0].amount,
                script: destinationScript,
                tokenId: 0x00
            };
            const change = {
                value: total,
                script: destinationScript,
                tokenId: 0x00
            };
            const txn = {
                version: jellyfish_transaction_1.DeFiTransactionConstants.Version,
                vin: vin,
                vout: [deFiOut, change, out],
                lockTime: 0x00000000
            };
            const fee = yield this.calculateFee(txn);
            change.value = total.minus(fee);
            return yield this.sign(txn, prevouts);
        });
    }
    accountToAccount(accountToAccount, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ACCOUNT_TO_ACCOUNT(accountToAccount), changeScript);
        });
    }
}
exports.TxnBuilderAccount = TxnBuilderAccount;

},{"./txn_builder":80,"./txn_builder_error":83,"@defichain/jellyfish-transaction":94,"bignumber.js":167}],82:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderDex = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
class TxnBuilderDex extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Requires at least 0.01 DFI to create transaction, actual fees are much lower.
     *
     * @param {PoolSwap} poolSwap txn to create
     * @param {Script} changeScript to send unspent to after deducting the fees
     */
    poolSwap(poolSwap, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_POOL_SWAP(poolSwap), changeScript);
        });
    }
    /**
     * Requires at least 0.01 DFI to create transaction, actual fees are much lower.
     *
     * @param {CompositeSwap} compositeSwap txn to create
     * @param {Script} changeScript to send unspent to after deducting the fees
     */
    compositeSwap(compositeSwap, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_COMPOSITE_SWAP(compositeSwap), changeScript);
        });
    }
}
exports.TxnBuilderDex = TxnBuilderDex;

},{"./txn_builder":80,"@defichain/jellyfish-transaction":94}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderError = exports.TxnBuilderErrorType = void 0;
var TxnBuilderErrorType;
(function (TxnBuilderErrorType) {
    /**
     * No prevouts available to create a transaction
     */
    TxnBuilderErrorType[TxnBuilderErrorType["NO_PREVOUTS"] = 0] = "NO_PREVOUTS";
    /**
     * Required balance is not enough to create a transaction
     */
    TxnBuilderErrorType[TxnBuilderErrorType["MIN_BALANCE_NOT_ENOUGH"] = 1] = "MIN_BALANCE_NOT_ENOUGH";
    /**
     * Current fee is over the fixed MAX_FEE_RATE
     */
    TxnBuilderErrorType[TxnBuilderErrorType["OVER_MAX_FEE_RATE"] = 2] = "OVER_MAX_FEE_RATE";
    /**
     * Invalid fee rate
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_FEE_RATE"] = 3] = "INVALID_FEE_RATE";
    /**
     * Unable to sign transaction due to error in TransactionSigner
     */
    TxnBuilderErrorType[TxnBuilderErrorType["SIGN_TRANSACTION_ERROR"] = 4] = "SIGN_TRANSACTION_ERROR";
    /**
     * Invalid conversion output `TokenBalance`, must consist only valid DFI balance
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_UTXOS_TO_ACCOUNT_OUTPUT"] = 5] = "INVALID_UTXOS_TO_ACCOUNT_OUTPUT";
    /**
     * Invalid input `TokenBalances` array length must be one
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_ADD_LIQUIDITY_INPUT"] = 6] = "INVALID_ADD_LIQUIDITY_INPUT";
    /**
     * Invalid conversion input `TokenBalances`, must consist only valid DFI balance
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_ACCOUNT_TO_UTXOS_INPUT"] = 7] = "INVALID_ACCOUNT_TO_UTXOS_INPUT";
    /**
     * Invalid `AppointOracle` input
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_APPOINT_ORACLE_INPUT"] = 8] = "INVALID_APPOINT_ORACLE_INPUT";
    /**
     * Invalid `UpdateOracle` input
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_UPDATE_ORACLE_INPUT"] = 9] = "INVALID_UPDATE_ORACLE_INPUT";
    /**
     * Invalid public key length
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_PUB_KEY_LENGTH"] = 10] = "INVALID_PUB_KEY_LENGTH";
    /**
     * Invalid `CreateOrder` amountToFill
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_ICX_CREATE_ORDER_AMOUNT_TO_FILL"] = 11] = "INVALID_ICX_CREATE_ORDER_AMOUNT_TO_FILL";
    /**
     * Invalid `CreateVoc` amount, should be 0
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_VOC_AMOUNT"] = 12] = "INVALID_VOC_AMOUNT";
    /**
     * Invalid `CreateVoc` address, should be an empty stack
     */
    TxnBuilderErrorType[TxnBuilderErrorType["INVALID_VOC_ADDRESS"] = 13] = "INVALID_VOC_ADDRESS";
})(TxnBuilderErrorType = exports.TxnBuilderErrorType || (exports.TxnBuilderErrorType = {}));
/**
 * Error while constructing a transaction.
 */
class TxnBuilderError extends Error {
    constructor(type, message) {
        super(message);
        this.type = type;
    }
}
exports.TxnBuilderError = TxnBuilderError;

},{}],84:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderGovernance = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
const txn_builder_error_1 = require("./txn_builder_error");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
class TxnBuilderGovernance extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Creates a Community fund proposal.
     *
     * @param {CreateCfp} createCfp txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    createCfp(createCfp, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            const creationFee = this.network.name === 'regtest' ? new bignumber_js_1.default('1') : new bignumber_js_1.default('10');
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_CREATE_CFP(createCfp), changeScript, creationFee);
        });
    }
    /**
     * Creates a vote of confidence.
     *
     * @param {CreateVoc} createVoc txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    createVoc(createVoc, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!createVoc.amount.isEqualTo(new bignumber_js_1.default(0))) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_VOC_AMOUNT, 'CreateVoc amount should be 0');
            }
            if (createVoc.address.stack.length !== 0) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_VOC_ADDRESS, 'CreateVoc address stack should be empty');
            }
            const creationFee = this.network.name === 'regtest' ? new bignumber_js_1.default('5') : new bignumber_js_1.default('50');
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_CREATE_VOC(createVoc), changeScript, creationFee);
        });
    }
    /**
     * Vote on a community proposal.
     *
     * @param {Vote} vote txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    vote(vote, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_VOTE(vote), changeScript);
        });
    }
    /**
     * Set governance variable.
     *
     * @param {SetGovernance} setGov txn to create
     * @param {Script} changeScript to send unspent to after deducting the fee
     * @returns {Promise<TransactionSegWit>}
     */
    setGoverance(setGov, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_SET_GOVERNANCE(setGov), changeScript);
        });
    }
    /**
     * Set governance variable with activation height.
     *
     * @param {SetGovernanceHeight} setGovHeight txn to create
     * @param {Script} changeScript to send unspent to after deducting the fee
     * @returns {Promise<TransactionSegWit>}
     */
    setGoveranceHeight(setGovHeight, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_SET_GOVERNANCE_HEIGHT(setGovHeight), changeScript);
        });
    }
}
exports.TxnBuilderGovernance = TxnBuilderGovernance;

},{"./txn_builder":80,"./txn_builder_error":83,"@defichain/jellyfish-transaction":94,"bignumber.js":167}],85:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderICXOrderBook = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
const txn_builder_error_1 = require("./txn_builder_error");
class TxnBuilderICXOrderBook extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Creates ICXCreateOrder transaction.
     *
     * @param {ICXCreateOrder} createOrder Create order txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    createOrder(createOrder, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            if (createOrder.receivePubkey !== undefined) {
                const bufferLen = Buffer.from(createOrder.receivePubkey, 'hex').length;
                if (bufferLen !== 33 && bufferLen !== 65) {
                    throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_PUB_KEY_LENGTH, 'Create order receivePubkey buffer length should be 33 (COMPRESSED_PUBLIC_KEY_SIZE) or 65 (PUBLIC_KEY_SIZE)');
                }
            }
            if (!createOrder.amountToFill.isEqualTo(createOrder.amountFrom)) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ICX_CREATE_ORDER_AMOUNT_TO_FILL, 'Create order amountToFill should always equal amountFrom');
            }
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ICX_CREATE_ORDER(createOrder), changeScript);
        });
    }
    /**
     * Creates ICXMakeOffer transaction.
     *
     * @param {ICXMakeOffer} makeOffer txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    makeOffer(makeOffer, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            if (makeOffer.receivePubkey !== undefined) {
                const bufferLen = Buffer.from(makeOffer.receivePubkey, 'hex').length;
                if (bufferLen !== 33 && bufferLen !== 65) {
                    throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_PUB_KEY_LENGTH, 'Make offer receivePubkey buffer length should be 33 (COMPRESSED_PUBLIC_KEY_SIZE) or 65 (PUBLIC_KEY_SIZE)');
                }
            }
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ICX_MAKE_OFFER(makeOffer), changeScript);
        });
    }
    /**
     * Creates ICXCloseOrder transaction.
     *
     * @param {ICXCloseOrder} closeOrder txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    closeOrder(closeOrder, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ICX_CLOSE_ORDER(closeOrder), changeScript);
        });
    }
    /**
     * Creates ICXCloseOffer transaction.
     *
     * @param {ICXCloseOffer} closeOffer txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    closeOffer(closeOffer, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ICX_CLOSE_OFFER(closeOffer), changeScript);
        });
    }
    /**
     * Creates submitDFCHTLC transaction.
     *
     * @param {ICXSubmitDFCHTLC} icxSubmitDFCHTLC txn to create
     * @param {Script} changeScript to send unspent to after deducting the (transfer value + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    submitDFCHTLC(icxSubmitDFCHTLC, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ICX_SUBMIT_DFC_HTLC(icxSubmitDFCHTLC), changeScript);
        });
    }
    /**
     * Creates submitEXTHTLC transaction.
     *
     * @param {ICXSubmitEXTHTLC} icxSubmitEXTHTLC txn to create
     * @param {Script} changeScript to send unspent to after deducting the (transfer value + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    submitEXTHTLC(icxSubmitEXTHTLC, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ICX_SUBMIT_EXT_HTLC(icxSubmitEXTHTLC), changeScript);
        });
    }
    /**
     * Creates claimDFCHTLC transaction.
     *
     * @param {ICXClaimDFCHTLC} icxClaimDFCHTLC txn to create
     * @param {Script} changeScript to send unspent to after deducting the (transfer value + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    claimDFCHTLC(icxClaimDFCHTLC, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_ICX_CLAIM_DFC_HTLC(icxClaimDFCHTLC), changeScript);
        });
    }
}
exports.TxnBuilderICXOrderBook = TxnBuilderICXOrderBook;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./txn_builder":80,"./txn_builder_error":83,"@defichain/jellyfish-transaction":94,"buffer":3}],86:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderLiqPool = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
const txn_builder_error_1 = require("./txn_builder_error");
class TxnBuilderLiqPool extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Add to liquidity pool using token balances pair supplied in `addLiquidity`.from[0].balances.
     *
     * @param {PoolAddLiquidity} addLiquidity txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @throws {TxnBuilderError} if 'addLiquidity.from' length is not `1`
     * @throws {TxnBuilderError} if 'addLiquidity.from[0].balances' length is not `2`
     * @returns {Promise<TransactionSegWit>}
     */
    addLiquidity(addLiquidity, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            if (addLiquidity.from.length !== 1) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ADD_LIQUIDITY_INPUT, '`addLiquidity.from` array length must be ONE');
            }
            if (addLiquidity.from[0].balances.length !== 2) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ADD_LIQUIDITY_INPUT, '`addLiquidity.from[0].balances` array length must be TWO');
            }
            if (addLiquidity.from[0].balances[0].token === addLiquidity.from[0].balances[1].token) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_ADD_LIQUIDITY_INPUT, '`addLiquidity.from[0].balances` must consists of TWO different token');
            }
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_POOL_ADD_LIQUIDITY(addLiquidity), changeScript);
        });
    }
    /**
     * Remove from liquidity pool.
     *
     * @param {PoolRemoveLiquidity} removeLiquidity pool token p2pwkh scipt, token id and amount to remove
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    removeLiquidity(removeLiquidity, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_POOL_REMOVE_LIQUIDITY(removeLiquidity), changeScript);
        });
    }
}
exports.TxnBuilderLiqPool = TxnBuilderLiqPool;

},{"./txn_builder":80,"./txn_builder_error":83,"@defichain/jellyfish-transaction":94}],87:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderLoans = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
const jellyfish_json_1 = require("@defichain/jellyfish-json");
class TxnBuilderLoans extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Create or update a loan scheme. Currently requires Foundation Authorization.
     *
     * @param {SetLoanScheme} setLoanScheme txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    setLoanScheme(setLoanScheme, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_SET_LOAN_SCHEME(setLoanScheme), changeScript);
        });
    }
    /**
     * Destroy a loan scheme. Currently requires Foundation Authorization.
     *
     * @param {DestroyLoanScheme} destroyLoanScheme txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    destroyLoanScheme(destroyLoanScheme, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_DESTROY_LOAN_SCHEME(destroyLoanScheme), changeScript);
        });
    }
    /**
     * Set default loan scheme. Currently requires Foundation Authorization.
     *
     * @param {SetDefaultLoanScheme} setDefaultLoanScheme txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    setDefaultLoanScheme(setDefaultLoanScheme, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_SET_DEFAULT_LOAN_SCHEME(setDefaultLoanScheme), changeScript);
        });
    }
    /**
     * Set a collateral token. Currently requires Foundation Authorization.
     *
     * @param {SetCollateralToken} setCollateralToken txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    setCollateralToken(setCollateralToken, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_SET_COLLATERAL_TOKEN(setCollateralToken), changeScript);
        });
    }
    /**
     * Set loan token. Currently requires Foundation Authorization.
     *
     * @param {SetLoanToken} setLoanToken txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    setLoanToken(setLoanToken, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_SET_LOAN_TOKEN(setLoanToken), changeScript);
        });
    }
    /**
     * Update loan token. Currently requires Foundation Authorization.
     *
     * @param {UpdateLoanToken} updateLoanToken txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    updateLoanToken(updateLoanToken, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_UPDATE_LOAN_TOKEN(updateLoanToken), changeScript);
        });
    }
    /**
     * Creates vault transaction.
     *
     * @param {CreateVault} createVault txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    createVault(createVault, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const creationFee = this.network.name === 'regtest' ? new jellyfish_json_1.BigNumber('1') : new jellyfish_json_1.BigNumber('2');
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_CREATE_VAULT(createVault), changeScript, creationFee);
        });
    }
    /**
     * Create update vault transaction.
     *
     * @param {UpdateVault} updateVault txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    updateVault(updateVault, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_UPDATE_VAULT(updateVault), changeScript);
        });
    }
    /**
     * Deposit to vault transaction.
     *
     * @param {DepositToVault} depositToVault txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    depositToVault(depositToVault, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_DEPOSIT_TO_VAULT(depositToVault), changeScript);
        });
    }
    /**
     * Withdraw from vault transaction.
     *
     * @param {withdrawFromVault} withdrawFromVault txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    withdrawFromVault(withdrawFromVault, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_WITHDRAW_FROM_VAULT(withdrawFromVault), changeScript);
        });
    }
    /**
     * Close a vault.
     *
     * @param {CloseVault} closeVault txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    closeVault(closeVault, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_CLOSE_VAULT(closeVault), changeScript);
        });
    }
    /**
     * Take loan transaction.
     *
     * @param {TakeLoan} takeLoan txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    takeLoan(takeLoan, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_TAKE_LOAN(takeLoan), changeScript);
        });
    }
    /**
     * PaybackLoan to vault transaction.
     *
     * @param {PaybackLoan} paybackLoan txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    paybackLoan(paybackLoan, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_PAYBACK_LOAN(paybackLoan), changeScript);
        });
    }
    /**
     * placeAuctionBid transaction.
     *
     * @param {PlaceAuctionBid} placeAuctionBid txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    placeAuctionBid(placeAuctionBid, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_AUCTION_BID(placeAuctionBid), changeScript);
        });
    }
}
exports.TxnBuilderLoans = TxnBuilderLoans;

},{"./txn_builder":80,"@defichain/jellyfish-json":73,"@defichain/jellyfish-transaction":94}],88:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderMasternode = void 0;
const jellyfish_json_1 = require("@defichain/jellyfish-json");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
class TxnBuilderMasternode extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Build create masternode transaction
     *
     * @param {CreateMasternode} createMasternode transaction to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @return {Promise<TransactionSegWit>}
     */
    create(createMasternode, changeScript) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const creationFee = this.network.name === 'regtest' ? new jellyfish_json_1.BigNumber('1') : new jellyfish_json_1.BigNumber('10');
            // NOTE(canonbrother): adding a force default timelock handling here for better ux as from now on, timelock is mandatory
            // https://github.com/DeFiCh/ain/blob/ff53dcee23db2ffe0da9b147a0a53956f4e7ee31/src/masternodes/mn_checks.h#L159
            createMasternode.timelock = (_a = createMasternode.timelock) !== null && _a !== void 0 ? _a : 0x0000;
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_CREATE_MASTER_NODE(createMasternode), changeScript, creationFee);
        });
    }
    /**
     * Build resign masternode transaction
     *
     * @param {ResignMasternode} resignMasternode transaction to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @return {Promise<TransactionSegWit>}
     */
    resign(resignMasternode, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.createDeFiTx(jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_RESIGN_MASTER_NODE(resignMasternode), changeScript);
        });
    }
}
exports.TxnBuilderMasternode = TxnBuilderMasternode;

},{"./txn_builder":80,"@defichain/jellyfish-json":73,"@defichain/jellyfish-transaction":94}],89:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderOracles = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const txn_builder_1 = require("./txn_builder");
const txn_builder_error_1 = require("./txn_builder_error");
class TxnBuilderOracles extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Appoints an oracle. Currently requires Foundation Authorization.
     *
     * @param {AppointOracle} appointOracle txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @throws {TxnBuilderError} if 'appointOracle.weightage' is below `1` or over `100`
     * @returns {Promise<TransactionSegWit>}
     */
    appointOracle(appointOracle, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (appointOracle.weightage < 1 || appointOracle.weightage > 100) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_APPOINT_ORACLE_INPUT, 'Conversion input `appointOracle.weightage` must be above `0` and below `101`');
            }
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_APPOINT_ORACLE(appointOracle), changeScript);
        });
    }
    /**
     * Removes an oracle. Currently requires Foundation Authorization.
     *
     * @param {RemoveOracle} removeOracle txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    removeOracle(removeOracle, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_REMOVE_ORACLE(removeOracle), changeScript);
        });
    }
    /**
     * Updates an oracle. Currently requires Foundation Authorization.
     *
     * @param {UpdateOracle} updateOracle txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @throws {TxnBuilderError} if 'updateOracle.weightage' is below `1` or over `100`
     * @returns {Promise<TransactionSegWit>}
     */
    updateOracle(updateOracle, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (updateOracle.weightage < 1 || updateOracle.weightage > 100) {
                throw new txn_builder_error_1.TxnBuilderError(txn_builder_error_1.TxnBuilderErrorType.INVALID_UPDATE_ORACLE_INPUT, 'Conversion input `updateOracle.weightage` must be above `0` and below `101`');
            }
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_UPDATE_ORACLE(updateOracle), changeScript);
        });
    }
    /**
     * Sets data on an oracle. Currently requires Foundation Authorization.
     *
     * @param {SetOracleData} setOracleData txn to create
     * @param {Script} changeScript to send unspent to after deducting the (converted + fees)
     * @returns {Promise<TransactionSegWit>}
     */
    setOracleData(setOracleData, changeScript) {
        const _super = Object.create(null, {
            createDeFiTx: { get: () => super.createDeFiTx }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield _super.createDeFiTx.call(this, jellyfish_transaction_1.OP_CODES.OP_DEFI_TX_SET_ORACLE_DATA(setOracleData), changeScript);
        });
    }
}
exports.TxnBuilderOracles = TxnBuilderOracles;

},{"./txn_builder":80,"./txn_builder_error":83,"@defichain/jellyfish-transaction":94}],90:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderUtxo = void 0;
const txn_builder_1 = require("./txn_builder");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
class TxnBuilderUtxo extends txn_builder_1.P2WPKHTxnBuilder {
    /**
     * Send all UTXO provided by prevoutProvider.all() to script.
     *
     * @param {Script} toScript to send output to
     */
    sendAll(toScript) {
        return __awaiter(this, void 0, void 0, function* () {
            const { prevouts, vin, total } = yield this.allPrevouts();
            const to = {
                value: total,
                script: toScript,
                tokenId: 0x00
            };
            const txn = {
                version: jellyfish_transaction_1.DeFiTransactionConstants.Version,
                vin: vin,
                vout: [to],
                lockTime: 0x00000000
            };
            const fee = yield this.calculateFee(txn);
            to.value = total.minus(fee);
            return yield this.sign(txn, prevouts);
        });
    }
    /**
     * Send a specific amount of UTXO provided by prevoutProvider.collect(amount, fee) to script.
     * If you are not sending the full amount via sendAll, you will need at least 0.001 DFI more
     * than the specific amount for sending. This will also evidently merge small prevout during
     * the operation.
     *
     * @param {BigNumber} amount of UTXO to send to script
     * @param {Script} toScript to send UTXO to
     * @param {Script} changeScript to send unspent to after deducting the fees
     */
    send(amount, toScript, changeScript) {
        return __awaiter(this, void 0, void 0, function* () {
            const minAmount = amount.plus(0.001);
            const { prevouts, vin, total } = yield this.collectPrevouts(minAmount);
            const changeAmount = total.minus(amount);
            const to = {
                value: amount,
                script: toScript,
                tokenId: 0x00
            };
            const change = {
                value: changeAmount,
                script: changeScript,
                tokenId: 0x00
            };
            const txn = {
                version: jellyfish_transaction_1.DeFiTransactionConstants.Version,
                vin: vin,
                vout: [to, change],
                lockTime: 0x00000000
            };
            const fee = yield this.calculateFee(txn);
            change.value = changeAmount.minus(fee);
            return yield this.sign(txn, prevouts);
        });
    }
}
exports.TxnBuilderUtxo = TxnBuilderUtxo;

},{"./txn_builder":80,"@defichain/jellyfish-transaction":94}],91:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateWeight = exports.calculateVirtual = exports.calculateFee = exports.calculateFeeP2WPKH = exports.isDustAmount = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const smart_buffer_1 = require("smart-buffer");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
/**
 * Consider dust if output is < 0.00003000
 * This is not the cleanest way to calculate but it's the easiest.
 */
const DUST_AMOUNT = new bignumber_js_1.default('0.00003000');
// const DUST_RELAY_TX_FEE = new BigNumber('0.00003000')
/**
 * A P2PKH witness example for estimating txn size before signing transaction.
 */
const P2WPKH_WITNESS_EXAMPLE = {
    scripts: [
        { hex: '3044022000000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000001' },
        { hex: '000000000000000000000000000000000000000000000000000000000000000000' }
    ]
};
/**
 * TODO(jellyfish): consider refactoring this implementation
 *
 * @param {BigNumber} amount that is considered dust if it's too little
 * @return {boolean}
 */
function isDustAmount(amount) {
    return amount.lte(DUST_AMOUNT);
}
exports.isDustAmount = isDustAmount;
/**
 * Calculate fee of a transaction where inputs are all P2WPKH.
 *
 * @param {BigNumber} feeRate in DFI/kb
 * @param {Transaction} transaction
 * @return {BigNumber} fee amount to use for transaction with provided fee rate
 */
function calculateFeeP2WPKH(feeRate, transaction) {
    const witness = transaction.vin.map(_ => P2WPKH_WITNESS_EXAMPLE);
    const size = calculateVirtual(transaction, witness);
    return feeRate.multipliedBy(size).dividedBy(1000);
}
exports.calculateFeeP2WPKH = calculateFeeP2WPKH;
/**
 * @param {BigNumber} feeRate in DFI/kb
 * @param {Transaction} transaction
 * @param {Witness} witness of the transaction, separated to allow unsigned calculation
 * @return {BigNumber} fee amount to use for transaction with provided fee rate
 */
function calculateFee(feeRate, transaction, witness) {
    const size = calculateVirtual(transaction, witness);
    return feeRate.multipliedBy(size).dividedBy(1000);
}
exports.calculateFee = calculateFee;
/**
 * @param {Transaction} transaction
 * @param {Witness} witness of the transaction, separated to allow unsigned calculation
 * @return {number} calculated virtual size of transaction
 */
function calculateVirtual(transaction, witness) {
    return Math.ceil(calculateWeight(transaction, witness) / 4);
}
exports.calculateVirtual = calculateVirtual;
/**
 * @param {Transaction} transaction
 * @param {Witness} witness of the transaction, separated to allow unsigned calculation
 * @return {number} calculated weight of transaction
 */
function calculateWeight(transaction, witness) {
    const base = calculate(transaction);
    const total = calculateWitness({
        version: transaction.version,
        marker: 0x00,
        flag: 0x01,
        vin: transaction.vin,
        vout: transaction.vout,
        lockTime: transaction.lockTime,
        witness: witness
    });
    return base * 3 + total;
}
exports.calculateWeight = calculateWeight;
function calculate(transaction) {
    const buffer = new smart_buffer_1.SmartBuffer();
    new jellyfish_transaction_1.CTransaction(transaction).toBuffer(buffer);
    return buffer.length;
}
function calculateWitness(transaction) {
    const buffer = new smart_buffer_1.SmartBuffer();
    new jellyfish_transaction_1.CTransactionSegWit(transaction).toBuffer(buffer);
    return buffer.length;
}

},{"@defichain/jellyfish-transaction":94,"bignumber.js":167,"smart-buffer":273}],92:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./tx_signature"), exports);

},{"./tx_signature":93}],93:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionSigner = void 0;
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const smart_buffer_1 = require("smart-buffer");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
function hashPrevouts(transaction, sigHashType) {
    if (sigHashType !== jellyfish_transaction_1.SIGHASH.ALL) {
        throw new Error('currently only SIGHASH.ALL is supported');
    }
    const buffer = new smart_buffer_1.SmartBuffer();
    for (const vin of transaction.vin) {
        const txid = Buffer.from(vin.txid, 'hex').reverse();
        buffer.writeBuffer(txid);
        buffer.writeUInt32LE(vin.index);
    }
    return jellyfish_crypto_1.dSHA256(buffer.toBuffer()).toString('hex');
}
function hashSequence(transaction, sigHashType) {
    if (sigHashType !== jellyfish_transaction_1.SIGHASH.ALL) {
        throw new Error('currently only SIGHASH.ALL is supported');
    }
    const buffer = new smart_buffer_1.SmartBuffer();
    for (const vin of transaction.vin) {
        buffer.writeUInt32LE(vin.sequence);
    }
    return jellyfish_crypto_1.dSHA256(buffer.toBuffer()).toString('hex');
}
function hashOutputs(transaction, sigHashType) {
    if (sigHashType !== jellyfish_transaction_1.SIGHASH.ALL) {
        throw new Error('currently only SIGHASH.ALL is supported');
    }
    const buffer = new smart_buffer_1.SmartBuffer();
    transaction.vout.forEach(vout => (new jellyfish_transaction_1.CVoutV4(vout)).toBuffer(buffer));
    return jellyfish_crypto_1.dSHA256(buffer.toBuffer()).toString('hex');
}
/**
 *
 * The witness must consist of exactly 2 items.
 * The '0' in scriptPubKey indicates the following push is a version 0 witness program.
 * The length of 20 indicates that it is a P2WPKH type.
 *
 * @param {SignInputOption} signInputOption to check is is V0 P2WPKH
 */
function isV0P2WPKH(signInputOption) {
    return __awaiter(this, void 0, void 0, function* () {
        const stack = signInputOption.prevout.script.stack;
        if (stack.length !== 2) {
            return false;
        }
        if (stack[0].type !== 'OP_0') {
            return false;
        }
        if (stack[1].type !== 'OP_PUSHDATA') {
            return false;
        }
        if (stack[1].length() !== 20) {
            return false;
        }
        const pubkey = yield signInputOption.publicKey();
        const pubkeyHashHex = jellyfish_crypto_1.HASH160(pubkey).toString('hex');
        const pushDataHex = stack[1].hex;
        if (pubkeyHashHex === pushDataHex) {
            return true;
        }
        throw new Error('invalid input option - attempting to sign a mismatch vout and publicKey is not allowed');
    });
}
/**
 * If script is not provided, it needs to be guessed
 *
 * @param {Vin} vin of the script
 * @param {SignInputOption} signInputOption to sign the vin
 */
function getScriptCode(vin, signInputOption) {
    return __awaiter(this, void 0, void 0, function* () {
        if (signInputOption.witnessScript !== undefined) {
            return signInputOption.witnessScript;
        }
        if (yield isV0P2WPKH(signInputOption)) {
            const pubkey = yield signInputOption.publicKey();
            const pubkeyHash = jellyfish_crypto_1.HASH160(pubkey);
            return {
                stack: [
                    jellyfish_transaction_1.OP_CODES.OP_DUP,
                    jellyfish_transaction_1.OP_CODES.OP_HASH160,
                    jellyfish_transaction_1.OP_CODES.OP_PUSHDATA(pubkeyHash, 'little'),
                    jellyfish_transaction_1.OP_CODES.OP_EQUALVERIFY,
                    jellyfish_transaction_1.OP_CODES.OP_CHECKSIG
                ]
            };
        }
        throw new Error('witnessScript required, only P2WPKH can be guessed');
    });
}
function asWitnessProgram(transaction, vin, signInputOption, sigHashType) {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            version: transaction.version,
            hashPrevouts: hashPrevouts(transaction, sigHashType),
            hashSequence: hashSequence(transaction, sigHashType),
            outpointTxId: vin.txid,
            outpointIndex: vin.index,
            scriptCode: yield getScriptCode(vin, signInputOption),
            value: signInputOption.prevout.value,
            sequence: vin.sequence,
            hashOutputs: hashOutputs(transaction, sigHashType),
            lockTime: transaction.lockTime,
            hashType: sigHashType
        };
    });
}
/**
 * TransactionSigner
 * 1. you can sign an unsigned transaction and get a signed transaction.
 * 2. you can sign a vin and get a witness in tx for that vin
 *
 * https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki
 * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki
 * https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki
 */
exports.TransactionSigner = {
    /**
     * @param {Transaction} transaction to sign
     * @param {number} index of the vin to sign
     * @param {SignInputOption} option input option
     * @param {SIGHASH} sigHashType SIGHASH type
     */
    signInput(transaction, index, option, sigHashType = jellyfish_transaction_1.SIGHASH.ALL) {
        return __awaiter(this, void 0, void 0, function* () {
            const vin = transaction.vin[index];
            const program = yield asWitnessProgram(transaction, vin, option, sigHashType);
            const preimage = new jellyfish_transaction_1.CWitnessProgram(program).asBuffer();
            const sigHash = jellyfish_crypto_1.dSHA256(preimage);
            const derSignature = yield option.sign(sigHash);
            const sigHashBuffer = Buffer.alloc(1, sigHashType);
            // signature + pubKey
            const signature = Buffer.concat([derSignature, Buffer.alloc(1, sigHashBuffer)]);
            const pubkey = yield option.publicKey();
            return {
                scripts: [
                    {
                        hex: signature.toString('hex')
                    },
                    {
                        hex: pubkey.toString('hex')
                    }
                ]
            };
        });
    },
    sign(transaction, inputOptions, option = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            exports.TransactionSigner.validate(transaction, inputOptions, option);
            const { sigHashType = jellyfish_transaction_1.SIGHASH.ALL } = option;
            const witnesses = [];
            for (let i = 0; i < transaction.vin.length; i++) {
                const witness = yield this.signInput(transaction, i, inputOptions[i], sigHashType);
                witnesses.push(witness);
            }
            return {
                version: transaction.version,
                marker: jellyfish_transaction_1.DeFiTransactionConstants.WitnessMarker,
                flag: jellyfish_transaction_1.DeFiTransactionConstants.WitnessFlag,
                vin: transaction.vin,
                vout: transaction.vout,
                witness: witnesses,
                lockTime: transaction.lockTime
            };
        });
    },
    signPrevoutsWithEllipticPairs(transaction, prevouts, ellipticPairs, option = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const inputs = prevouts.map((prevout, index) => {
                const ellipticPair = ellipticPairs[index];
                return {
                    prevout: prevout,
                    publicKey: () => __awaiter(this, void 0, void 0, function* () { return yield ellipticPair.publicKey(); }),
                    sign: (hash) => __awaiter(this, void 0, void 0, function* () { return yield ellipticPair.sign(hash); })
                };
            });
            return yield exports.TransactionSigner.sign(transaction, inputs, option);
        });
    },
    validate(transaction, inputOptions, option) {
        const { version = true, lockTime = true } = (option.validate !== undefined) ? option.validate : {};
        if (transaction.vin.length === 0) {
            throw new Error('vin.length = 0 - attempting to sign transaction without vin is not allowed');
        }
        if (transaction.vin.length !== inputOptions.length) {
            throw new Error('vin.length and inputOptions.length must match');
        }
        if (version && transaction.version !== jellyfish_transaction_1.DeFiTransactionConstants.Version) {
            throw new Error(`option.validate.version = true - trying to sign a txn ${transaction.version} different from ${jellyfish_transaction_1.DeFiTransactionConstants.Version} is not supported`);
        }
        if (lockTime && transaction.lockTime !== 0) {
            throw new Error(`option.validate.lockTime = true - lockTime: ${transaction.lockTime} must be zero`);
        }
    }
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"@defichain/jellyfish-crypto":71,"@defichain/jellyfish-transaction":94,"buffer":3,"smart-buffer":273}],94:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromOPCodes = exports.toOPCodes = exports.DeFiTransactionConstants = void 0;
/**
 * DeFi Blockchain Transaction Constants
 * https://github.com/DeFiCh/ain/blob/master/src/primitives/transaction.h
 */
exports.DeFiTransactionConstants = {
    Version: 0x00000004,
    WitnessMarker: 0x00,
    WitnessFlag: 0x01 // 1 byte
};
__exportStar(require("./script"), exports);
__exportStar(require("./tx"), exports);
__exportStar(require("./tx_composer"), exports);
__exportStar(require("./tx_segwit"), exports);
/**
 * Need to refactor this interface, it's not consistent
 */
var _buffer_1 = require("./script/_buffer");
Object.defineProperty(exports, "toOPCodes", { enumerable: true, get: function () { return _buffer_1.toOPCodes; } });
Object.defineProperty(exports, "fromOPCodes", { enumerable: true, get: function () { return _buffer_1.toBuffer; } });

},{"./script":117,"./script/_buffer":95,"./tx":123,"./tx_composer":124,"./tx_segwit":125}],95:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toOPCodes = exports.toBuffer = void 0;
const mapping_1 = require("./mapping");
const data_1 = require("./data");
const dftx_1 = require("./dftx");
/**
 * @param {OPCode[]} stack of OPCode
 * @return Buffer presentation of OPCode[]
 */
function toBuffer(stack) {
    let len = 0;
    const buffers = [];
    for (const opCode of stack) {
        const buf = opCode.asBuffer();
        buffers.push(buf);
        len += buf.length;
    }
    return Buffer.concat(buffers, len);
}
exports.toBuffer = toBuffer;
/**
 * @param {Buffer} buffer to read without VarUInt
 * @return OPCode[]
 */
function toOPCodes(buffer) {
    const stack = [];
    while (buffer.remaining() > 0) {
        stack.push(toOpCode(buffer));
    }
    // remap if isDeFiScript to identify DeFi Scripting
    return dftx_1.remapDeFiScript(stack);
}
exports.toOPCodes = toOPCodes;
function toOpCode(buffer) {
    const code = buffer.readUInt8();
    if (code !== 0x00 && code <= 0x4e) {
        return new data_1.OP_PUSHDATA(code, buffer);
    }
    return mapping_1.numAsOPCode(code);
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./data":101,"./dftx":115,"./mapping":119,"buffer":3}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_WITHIN = exports.OP_MAX = exports.OP_MIN = exports.OP_GREATERTHANOREQUAL = exports.OP_LESSTHANOREQUAL = exports.OP_GREATERTHAN = exports.OP_LESSTHAN = exports.OP_NUMNOTEQUAL = exports.OP_NUMEQUALVERIFY = exports.OP_NUMEQUAL = exports.OP_BOOLOR = exports.OP_BOOLAND = exports.OP_RSHIFT = exports.OP_LSHIFT = exports.OP_MOD = exports.OP_DIV = exports.OP_MUL = exports.OP_SUB = exports.OP_ADD = exports.OP_0NOTEQUAL = exports.OP_NOT = exports.OP_ABS = exports.OP_NEGATE = exports.OP_2DIV = exports.OP_2MUL = exports.OP_1SUB = exports.OP_1ADD = void 0;
const opcode_1 = require("./opcode");
/**
 * 1 is added to the input.
 */
class OP_1ADD extends opcode_1.StaticCode {
    constructor() {
        super(0x8b, 'OP_1ADD');
    }
}
exports.OP_1ADD = OP_1ADD;
/**
 * 1 is subtracted from the input.
 */
class OP_1SUB extends opcode_1.StaticCode {
    constructor() {
        super(0x8c, 'OP_1SUB');
    }
}
exports.OP_1SUB = OP_1SUB;
/**
 * The input is multiplied by 2. disabled.
 */
class OP_2MUL extends opcode_1.StaticCode {
    constructor() {
        super(0x8d, 'OP_2MUL');
    }
}
exports.OP_2MUL = OP_2MUL;
/**
 * The input is divided by 2. disabled.
 */
class OP_2DIV extends opcode_1.StaticCode {
    constructor() {
        super(0x8e, 'OP_2DIV');
    }
}
exports.OP_2DIV = OP_2DIV;
/**
 * The sign of the input is flipped.
 */
class OP_NEGATE extends opcode_1.StaticCode {
    constructor() {
        super(0x8f, 'OP_NEGATE');
    }
}
exports.OP_NEGATE = OP_NEGATE;
/**
 *  The input is made positive.
 */
class OP_ABS extends opcode_1.StaticCode {
    constructor() {
        super(0x90, 'OP_ABS');
    }
}
exports.OP_ABS = OP_ABS;
/**
 * If the input is 0 or 1, it is flipped. Otherwise the output will be 0.
 */
class OP_NOT extends opcode_1.StaticCode {
    constructor() {
        super(0x91, 'OP_NOT');
    }
}
exports.OP_NOT = OP_NOT;
/**
 * Returns 0 if the input is 0. 1 otherwise.
 */
class OP_0NOTEQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x92, 'OP_0NOTEQUAL');
    }
}
exports.OP_0NOTEQUAL = OP_0NOTEQUAL;
/**
 * a is added to b.
 */
class OP_ADD extends opcode_1.StaticCode {
    constructor() {
        super(0x93, 'OP_ADD');
    }
}
exports.OP_ADD = OP_ADD;
/**
 * b is subtracted from a.
 */
class OP_SUB extends opcode_1.StaticCode {
    constructor() {
        super(0x94, 'OP_SUB');
    }
}
exports.OP_SUB = OP_SUB;
/**
 * a is multiplied by b. disabled.
 */
class OP_MUL extends opcode_1.StaticCode {
    constructor() {
        super(0x95, 'OP_MUL');
    }
}
exports.OP_MUL = OP_MUL;
/**
 * a is divided by b. disabled.
 */
class OP_DIV extends opcode_1.StaticCode {
    constructor() {
        super(0x96, 'OP_DIV');
    }
}
exports.OP_DIV = OP_DIV;
/**
 * Returns the remainder after dividing a by b. disabled.
 */
class OP_MOD extends opcode_1.StaticCode {
    constructor() {
        super(0x97, 'OP_MOD');
    }
}
exports.OP_MOD = OP_MOD;
/**
 * Shifts a left b bits, preserving sign. disabled.
 */
class OP_LSHIFT extends opcode_1.StaticCode {
    constructor() {
        super(0x98, 'OP_LSHIFT');
    }
}
exports.OP_LSHIFT = OP_LSHIFT;
/**
 * Shifts a right b bits, preserving sign. disabled.
 */
class OP_RSHIFT extends opcode_1.StaticCode {
    constructor() {
        super(0x99, 'OP_RSHIFT');
    }
}
exports.OP_RSHIFT = OP_RSHIFT;
/**
 * If both a and b are not 0, the output is 1. Otherwise 0.
 */
class OP_BOOLAND extends opcode_1.StaticCode {
    constructor() {
        super(0x9a, 'OP_BOOLAND');
    }
}
exports.OP_BOOLAND = OP_BOOLAND;
/**
 * If a or b is not 0, the output is 1. Otherwise 0.
 */
class OP_BOOLOR extends opcode_1.StaticCode {
    constructor() {
        super(0x9b, 'OP_BOOLOR');
    }
}
exports.OP_BOOLOR = OP_BOOLOR;
/**
 * Returns 1 if the numbers are equal, 0 otherwise.
 */
class OP_NUMEQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x9c, 'OP_NUMEQUAL');
    }
}
exports.OP_NUMEQUAL = OP_NUMEQUAL;
/**
 * Same as OP_NUMEQUAL, but runs OP_VERIFY afterward.
 */
class OP_NUMEQUALVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0x9d, 'OP_NUMEQUALVERIFY');
    }
}
exports.OP_NUMEQUALVERIFY = OP_NUMEQUALVERIFY;
/**
 * Returns 1 if the numbers are not equal, 0 otherwise.
 */
class OP_NUMNOTEQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x9e, 'OP_NUMNOTEQUAL');
    }
}
exports.OP_NUMNOTEQUAL = OP_NUMNOTEQUAL;
/**
 * Returns 1 if a is less than b, 0 otherwise.
 */
class OP_LESSTHAN extends opcode_1.StaticCode {
    constructor() {
        super(0x9f, 'OP_LESSTHAN');
    }
}
exports.OP_LESSTHAN = OP_LESSTHAN;
/**
 * Returns 1 if a is greater than b, 0 otherwise.
 */
class OP_GREATERTHAN extends opcode_1.StaticCode {
    constructor() {
        super(0xa0, 'OP_GREATERTHAN');
    }
}
exports.OP_GREATERTHAN = OP_GREATERTHAN;
/**
 * Returns 1 if a is less than or equal to b, 0 otherwise.
 */
class OP_LESSTHANOREQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0xa1, 'OP_LESSTHANOREQUAL');
    }
}
exports.OP_LESSTHANOREQUAL = OP_LESSTHANOREQUAL;
/**
 *  Returns 1 if a is greater than or equal to b, 0 otherwise.
 */
class OP_GREATERTHANOREQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0xa2, 'OP_GREATERTHANOREQUAL');
    }
}
exports.OP_GREATERTHANOREQUAL = OP_GREATERTHANOREQUAL;
/**
 *  Returns the smaller of a and b.
 */
class OP_MIN extends opcode_1.StaticCode {
    constructor() {
        super(0xa3, 'OP_MIN');
    }
}
exports.OP_MIN = OP_MIN;
/**
 *  Returns the larger of a and b.
 */
class OP_MAX extends opcode_1.StaticCode {
    constructor() {
        super(0xa4, 'OP_MAX');
    }
}
exports.OP_MAX = OP_MAX;
/**
 *   Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.
 */
class OP_WITHIN extends opcode_1.StaticCode {
    constructor() {
        super(0xa5, 'OP_WITHIN');
    }
}
exports.OP_WITHIN = OP_WITHIN;

},{"./opcode":120}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_RESERVED2 = exports.OP_RESERVED1 = exports.OP_EQUALVERIFY = exports.OP_EQUAL = exports.OP_XOR = exports.OP_OR = exports.OP_AND = exports.OP_INVERT = void 0;
const opcode_1 = require("./opcode");
/**
 * Flips all of the bits in the input.
 */
class OP_INVERT extends opcode_1.StaticCode {
    constructor() {
        super(0x83, 'OP_INVERT');
    }
}
exports.OP_INVERT = OP_INVERT;
/**
 * Boolean AND between each bit in the inputs.
 */
class OP_AND extends opcode_1.StaticCode {
    constructor() {
        super(0x84, 'OP_AND');
    }
}
exports.OP_AND = OP_AND;
/**
 * Boolean OR between each bit in the inputs.
 */
class OP_OR extends opcode_1.StaticCode {
    constructor() {
        super(0x85, 'OP_OR');
    }
}
exports.OP_OR = OP_OR;
/**
 * Boolean exclusive OR between each bit in the inputs.
 */
class OP_XOR extends opcode_1.StaticCode {
    constructor() {
        super(0x86, 'OP_XOR');
    }
}
exports.OP_XOR = OP_XOR;
/**
 * Returns 1 if the inputs are exactly equal, 0 otherwise.
 */
class OP_EQUAL extends opcode_1.StaticCode {
    constructor() {
        super(0x87, 'OP_EQUAL');
    }
}
exports.OP_EQUAL = OP_EQUAL;
/**
 * Same as OP_EQUAL, but runs OP_VERIFY afterward.
 */
class OP_EQUALVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0x88, 'OP_EQUALVERIFY');
    }
}
exports.OP_EQUALVERIFY = OP_EQUALVERIFY;
/**
 * Transaction is invalid unless occuring in an unexecuted OP_IF branch.
 */
class OP_RESERVED1 extends opcode_1.StaticCode {
    constructor() {
        super(0x89, 'OP_RESERVED1');
    }
}
exports.OP_RESERVED1 = OP_RESERVED1;
/**
 * Transaction is invalid unless occuring in an unexecuted OP_IF branch.
 */
class OP_RESERVED2 extends opcode_1.StaticCode {
    constructor() {
        super(0x8a, 'OP_RESERVED2');
    }
}
exports.OP_RESERVED2 = OP_RESERVED2;

},{"./opcode":120}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_16 = exports.OP_15 = exports.OP_14 = exports.OP_13 = exports.OP_12 = exports.OP_11 = exports.OP_10 = exports.OP_9 = exports.OP_8 = exports.OP_7 = exports.OP_6 = exports.OP_5 = exports.OP_4 = exports.OP_3 = exports.OP_2 = exports.OP_TRUE = exports.OP_1 = exports.OP_RESERVED = exports.OP_1NEGATE = exports.OP_FALSE = exports.OP_0 = void 0;
const opcode_1 = require("./opcode");
/**
 * An empty array of bytes is pushed onto the stack.
 * (This is not a no-op: an item is added to the stack.)
 * @see OP_FALSE
 */
class OP_0 extends opcode_1.StaticCode {
    constructor() {
        super(0x00, 'OP_0');
    }
}
exports.OP_0 = OP_0;
/**
 * An empty array of bytes is pushed onto the stack.
 * (This is not a no-op: an item is added to the stack.)
 * @see OP_0
 */
class OP_FALSE extends OP_0 {
}
exports.OP_FALSE = OP_FALSE;
/**
 * The number -1 is pushed onto the stack.
 */
class OP_1NEGATE extends opcode_1.StaticCode {
    constructor() {
        super(0x4f, 'OP_1NEGATE');
    }
}
exports.OP_1NEGATE = OP_1NEGATE;
/**
 * Transaction is invalid unless occuring in an unexecuted OP_IF branch.
 */
class OP_RESERVED extends opcode_1.StaticCode {
    constructor() {
        super(0x50, 'OP_RESERVED');
    }
}
exports.OP_RESERVED = OP_RESERVED;
/**
 * The number 1 is pushed onto the stack.
 * @see OP_TRUE
 */
class OP_1 extends opcode_1.StaticCode {
    constructor() {
        super(0x51, 'OP_1');
    }
}
exports.OP_1 = OP_1;
/**
 * The number 1 is pushed onto the stack.
 * @see OP_1
 */
class OP_TRUE extends OP_1 {
}
exports.OP_TRUE = OP_TRUE;
/**
 * The number 2 is pushed onto the stack.
 */
class OP_2 extends opcode_1.StaticCode {
    constructor() {
        super(0x52, 'OP_2');
    }
}
exports.OP_2 = OP_2;
/**
 * The number 3 is pushed onto the stack.
 */
class OP_3 extends opcode_1.StaticCode {
    constructor() {
        super(0x53, 'OP_3');
    }
}
exports.OP_3 = OP_3;
/**
 * The number 4 is pushed onto the stack.
 */
class OP_4 extends opcode_1.StaticCode {
    constructor() {
        super(0x54, 'OP_4');
    }
}
exports.OP_4 = OP_4;
/**
 * The number 5 is pushed onto the stack.
 */
class OP_5 extends opcode_1.StaticCode {
    constructor() {
        super(0x55, 'OP_5');
    }
}
exports.OP_5 = OP_5;
/**
 * The number 6 is pushed onto the stack.
 */
class OP_6 extends opcode_1.StaticCode {
    constructor() {
        super(0x56, 'OP_6');
    }
}
exports.OP_6 = OP_6;
/**
 * The number 7 is pushed onto the stack.
 */
class OP_7 extends opcode_1.StaticCode {
    constructor() {
        super(0x57, 'OP_7');
    }
}
exports.OP_7 = OP_7;
/**
 * The number 8 is pushed onto the stack.
 */
class OP_8 extends opcode_1.StaticCode {
    constructor() {
        super(0x58, 'OP_8');
    }
}
exports.OP_8 = OP_8;
/**
 * The number 9 is pushed onto the stack.
 */
class OP_9 extends opcode_1.StaticCode {
    constructor() {
        super(0x59, 'OP_9');
    }
}
exports.OP_9 = OP_9;
/**
 * The number 10 is pushed onto the stack.
 */
class OP_10 extends opcode_1.StaticCode {
    constructor() {
        super(0x5a, 'OP_10');
    }
}
exports.OP_10 = OP_10;
/**
 * The number 11 is pushed onto the stack.
 */
class OP_11 extends opcode_1.StaticCode {
    constructor() {
        super(0x5b, 'OP_11');
    }
}
exports.OP_11 = OP_11;
/**
 * The number 12 is pushed onto the stack.
 */
class OP_12 extends opcode_1.StaticCode {
    constructor() {
        super(0x5c, 'OP_12');
    }
}
exports.OP_12 = OP_12;
/**
 * The number 13 is pushed onto the stack.
 */
class OP_13 extends opcode_1.StaticCode {
    constructor() {
        super(0x5d, 'OP_13');
    }
}
exports.OP_13 = OP_13;
/**
 * The number 14 is pushed onto the stack.
 */
class OP_14 extends opcode_1.StaticCode {
    constructor() {
        super(0x5e, 'OP_14');
    }
}
exports.OP_14 = OP_14;
/**
 * The number 15 is pushed onto the stack.
 */
class OP_15 extends opcode_1.StaticCode {
    constructor() {
        super(0x5f, 'OP_15');
    }
}
exports.OP_15 = OP_15;
/**
 * The number 16 is pushed onto the stack.
 */
class OP_16 extends opcode_1.StaticCode {
    constructor() {
        super(0x60, 'OP_16');
    }
}
exports.OP_16 = OP_16;

},{"./opcode":120}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_RETURN = exports.OP_VERIFY = exports.OP_ENDIF = exports.OP_ELSE = exports.OP_VERNOTIF = exports.OP_VERIF = exports.OP_NOTIF = exports.OP_IF = exports.OP_VER = exports.OP_NOP = void 0;
const opcode_1 = require("./opcode");
/**
 * Does nothing.
 */
class OP_NOP extends opcode_1.StaticCode {
    constructor() {
        super(0x61, 'OP_NOP');
    }
}
exports.OP_NOP = OP_NOP;
/**
 * Puts the version of the protocol under which this transaction will be evaluated onto the stack.
 */
class OP_VER extends opcode_1.StaticCode {
    constructor() {
        super(0x62, 'OP_VER');
    }
}
exports.OP_VER = OP_VER;
/**
 * If the top stack value is true, the statements are executed
 */
class OP_IF extends opcode_1.StaticCode {
    constructor() {
        super(0x63, 'OP_IF');
    }
}
exports.OP_IF = OP_IF;
/**
 * If the top stack value is false, the statements are executed.
 */
class OP_NOTIF extends opcode_1.StaticCode {
    constructor() {
        super(0x64, 'OP_NOTIF');
    }
}
exports.OP_NOTIF = OP_NOTIF;
/**
 * If the top stack value is equal to the version of the protocol under which
 * this transaction will be evaluated, the statements between IF and ELSE are executed.
 */
class OP_VERIF extends opcode_1.StaticCode {
    constructor() {
        super(0x65, 'OP_VERIF');
    }
}
exports.OP_VERIF = OP_VERIF;
/**
 *  If the top stack value is not equal to the version of the protocol under which this
 *  transaction will be evaluated, the statements between IF and ELSE are executed.
 */
class OP_VERNOTIF extends opcode_1.StaticCode {
    constructor() {
        super(0x66, 'OP_VERNOTIF');
    }
}
exports.OP_VERNOTIF = OP_VERNOTIF;
/**
 * If the preceding OP_IF or OP_NOTIF or OP_ELSE was not executed then these
 * statements are and otherwise if executed.
 */
class OP_ELSE extends opcode_1.StaticCode {
    constructor() {
        super(0x67, 'OP_ELSE');
    }
}
exports.OP_ELSE = OP_ELSE;
/**
 * Ends an if/else block. All blocks must end, or the transaction is invalid.
 */
class OP_ENDIF extends opcode_1.StaticCode {
    constructor() {
        super(0x68, 'OP_ENDIF');
    }
}
exports.OP_ENDIF = OP_ENDIF;
/**
 * Marks transaction as invalid if top stack value is not true.
 */
class OP_VERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0x69, 'OP_VERIFY');
    }
}
exports.OP_VERIFY = OP_VERIFY;
/**
 * Marks transaction as invalid.
 */
class OP_RETURN extends opcode_1.StaticCode {
    constructor() {
        super(0x6a, 'OP_RETURN');
    }
}
exports.OP_RETURN = OP_RETURN;

},{"./opcode":120}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_CHECKMULTISIGVERIFY = exports.OP_CHECKMULTISIG = exports.OP_CHECKSIGVERIFY = exports.OP_CHECKSIG = exports.OP_CODESEPARATOR = exports.OP_HASH256 = exports.OP_HASH160 = exports.OP_SHA256 = exports.OP_SHA1 = exports.OP_RIPEMD160 = void 0;
const opcode_1 = require("./opcode");
/**
 * The input is hashed using RIPEMD-160.
 */
class OP_RIPEMD160 extends opcode_1.StaticCode {
    constructor() {
        super(0xa6, 'OP_RIPEMD160');
    }
}
exports.OP_RIPEMD160 = OP_RIPEMD160;
/**
 * The input is hashed using SHA-1.
 */
class OP_SHA1 extends opcode_1.StaticCode {
    constructor() {
        super(0xa7, 'OP_SHA1');
    }
}
exports.OP_SHA1 = OP_SHA1;
/**
 * The input is hashed using SHA-256.
 */
class OP_SHA256 extends opcode_1.StaticCode {
    constructor() {
        super(0xa8, 'OP_SHA256');
    }
}
exports.OP_SHA256 = OP_SHA256;
/**
 * The input is hashed twice: first with SHA-256 and then with RIPEMD-160.
 */
class OP_HASH160 extends opcode_1.StaticCode {
    constructor() {
        super(0xa9, 'OP_HASH160');
    }
}
exports.OP_HASH160 = OP_HASH160;
/**
 * The input is hashed two times with SHA-256.
 */
class OP_HASH256 extends opcode_1.StaticCode {
    constructor() {
        super(0xaa, 'OP_HASH256');
    }
}
exports.OP_HASH256 = OP_HASH256;
/**
 * All of the signature checking words will only match
 * signatures to the data after the most recently-executed
 * OP_CODESEPARATOR.
 */
class OP_CODESEPARATOR extends opcode_1.StaticCode {
    constructor() {
        super(0xab, 'OP_CODESEPARATOR');
    }
}
exports.OP_CODESEPARATOR = OP_CODESEPARATOR;
/**
 * The entire transaction's outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end)
 * are hashed.
 * The signature used by OP_CHECKSIG must be a valid signature for this hash and public key.
 * If it is, 1 is returned, 0 otherwise.
 */
class OP_CHECKSIG extends opcode_1.StaticCode {
    constructor() {
        super(0xac, 'OP_CHECKSIG');
    }
}
exports.OP_CHECKSIG = OP_CHECKSIG;
/**
 * Same as OP_CHECKSIG, but OP_VERIFY is executed afterward.
 */
class OP_CHECKSIGVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0xad, 'OP_CHECKSIGVERIFY');
    }
}
exports.OP_CHECKSIGVERIFY = OP_CHECKSIGVERIFY;
/**
 * Compares the first signature against each public key
 * until it finds an ECDSA match. Starting with the
 * subsequent public key, it compares the second
 * signature against each remaining public key until it
 * finds an ECDSA match. The process is repeated until
 * all signatures have been checked or not enough public
 * keys remain to produce a successful result.
 * All signatures need to match a public key.
 * Because public keys are not checked again if they
 * fail any signature comparison, signatures must be
 * placed in the scriptSig using the same order as their
 * corresponding public keys were placed in the
 * scriptPubKey or redeemScript.If all signatures are
 * valid, 1 is returned, 0 otherwise. Due to a bug, one
 * extra unused value is removed from the stack.
 */
class OP_CHECKMULTISIG extends opcode_1.StaticCode {
    constructor() {
        super(0xae, 'OP_CHECKMULTISIG');
    }
}
exports.OP_CHECKMULTISIG = OP_CHECKMULTISIG;
/**
 * Same as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.
 */
class OP_CHECKMULTISIGVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0xaf, 'OP_CHECKMULTISIGVERIFY');
    }
}
exports.OP_CHECKMULTISIGVERIFY = OP_CHECKMULTISIGVERIFY;

},{"./opcode":120}],101:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_PUSHDATA = void 0;
const smart_buffer_1 = require("smart-buffer");
const opcode_1 = require("./opcode");
/**
 * These are opcode from 1-75, 76, 77, 78.
 * Effectively this opcode carry data.
 *
 * OP_CODE      | HEX         | DESCRIPTION
 * -------------|-------------|----------------------------------------------------------------------
 * N/A          | 0x01-0x4b   | The next opcode bytes is data to be pushed onto the stack
 * OP_PUSHDATA1 | 0x4c        | The next byte contains the number of bytes to be pushed onto the stack.
 * OP_PUSHDATA2 | 0x4d        | The next 2 bytes contain the number of bytes to be pushed onto the stack in LE order.
 * OP_PUSHDATA4 | 0x4e        | The next 4 bytes contain the number of bytes to be pushed onto the stack in LE order.
 *
 * OPCODE will automatically be appended in asBuffer().
 * The constructor only accepts the bytes to be pushed in the stack.
 */
class OP_PUSHDATA extends opcode_1.OPCode {
    constructor(p1, p2) {
        super('OP_PUSHDATA');
        if (Buffer.isBuffer(p1) && (p2 === 'little' || p2 === 'big')) {
            if (p2 === 'big') {
                this.hex = Buffer.from(p1).reverse().toString('hex');
            }
            else {
                this.hex = Buffer.from(p1).toString('hex');
            }
            return;
        }
        if (typeof p1 === 'number' && p2 instanceof smart_buffer_1.SmartBuffer) {
            const buff = OP_PUSHDATA.readData(p1, p2);
            this.hex = Buffer.from(buff).toString('hex');
            return;
        }
        throw new Error('OP_PUSHDATA invalid constructor parameters');
    }
    /**
     * Read data from buffer
     */
    static readData(code, buffer) {
        if (code < 0x4c) {
            return buffer.readBuffer(code);
        }
        if (code === 0x4c) {
            return buffer.readBuffer(buffer.readUInt8());
        }
        if (code === 0x4d) {
            return buffer.readBuffer(buffer.readUInt16LE());
        }
        if (code === 0x4e) {
            return buffer.readBuffer(buffer.readUInt32LE());
        }
        throw new RangeError(`OP_PUSHDATA ${code} is not between 0x01 or 0x4e inclusive`);
    }
    /**
     * Length of bytes
     */
    length() {
        return this.hex.length / 2;
    }
    /**
     * @return [0x01-0x4e, [>0x4b ?? length], [push data]]
     */
    asBuffer() {
        const buffer = new smart_buffer_1.SmartBuffer();
        buffer.writeBuffer(OP_PUSHDATA.getLenOpBuffer(this.length()));
        buffer.writeString(this.hex, 'hex');
        return buffer.toBuffer();
    }
    static getLenOpBuffer(length) {
        const buffer = new smart_buffer_1.SmartBuffer();
        if (length < 76) {
            buffer.writeUInt8(length);
        }
        else if (length <= 255) {
            buffer.writeUInt8(0x4c);
            buffer.writeUInt8(length);
        }
        else if (length <= 65535) {
            buffer.writeUInt8(0x4d);
            buffer.writeUInt16LE(length);
        }
        else if (length <= 16777215) {
            buffer.writeUInt8(0x4e);
            buffer.writeUInt32LE(length);
        }
        else {
            throw new RangeError('OP_PUSHDATA buffer is larger than 16777215');
        }
        return buffer.toBuffer();
    }
}
exports.OP_PUSHDATA = OP_PUSHDATA;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./opcode":120,"buffer":3,"smart-buffer":273}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CDfTx = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const dftx_account_1 = require("./dftx_account");
const dftx_masternode_1 = require("./dftx_masternode");
const dftx_misc_1 = require("./dftx_misc");
const dftx_pool_1 = require("./dftx_pool");
const dftx_token_1 = require("./dftx_token");
const dftx_oracles_1 = require("./dftx_oracles");
const dftx_unmapped_1 = require("./dftx_unmapped");
const dftx_icxorderbook_1 = require("./dftx_icxorderbook");
const dftx_governance_1 = require("./dftx_governance");
const dftx_loans_1 = require("./dftx_loans");
/**
 * Composable DfTx, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CDfTx extends jellyfish_buffer_1.ComposableBuffer {
    composers(dftx) {
        return [
            CDfTx.signature(dftx),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => dftx.type, v => dftx.type = v),
            {
                // This is not exactly an performant design, but it is succinct
                fromBuffer(buffer) {
                    return CDfTx.data(dftx).fromBuffer(buffer);
                },
                toBuffer(buffer) {
                    return CDfTx.data(dftx).toBuffer(buffer);
                }
            }
        ];
    }
    /**
     * Signature read/write with error handling if not recognized
     */
    static signature(dftx) {
        return {
            fromBuffer(buffer) {
                const signature = buffer.readUInt32BE();
                if (signature !== CDfTx.SIGNATURE) {
                    throw new Error(`CDfTx attempt to read a signature that is not recognized: ${signature}`);
                }
                dftx.signature = signature;
            },
            toBuffer(buffer) {
                if (dftx.signature !== CDfTx.SIGNATURE) {
                    throw new Error(`CDfTx attempt to write a signature that is not recognized: ${dftx.signature}`);
                }
                buffer.writeUInt32BE(dftx.signature);
            }
        };
    }
    /**
     * Operation data read/write composing
     */
    static data(dftx) {
        function compose(name, asC) {
            dftx.name = name;
            return jellyfish_buffer_1.ComposableBuffer.single(() => dftx.data, v => dftx.data = v, asC);
        }
        switch (dftx.type) {
            case dftx_pool_1.CPoolSwap.OP_CODE:
                return compose(dftx_pool_1.CPoolSwap.OP_NAME, d => new dftx_pool_1.CPoolSwap(d));
            case dftx_pool_1.CCompositeSwap.OP_CODE:
                return compose(dftx_pool_1.CCompositeSwap.OP_NAME, d => new dftx_pool_1.CCompositeSwap(d));
            case dftx_pool_1.CPoolAddLiquidity.OP_CODE:
                return compose(dftx_pool_1.CPoolAddLiquidity.OP_NAME, d => new dftx_pool_1.CPoolAddLiquidity(d));
            case dftx_pool_1.CPoolRemoveLiquidity.OP_CODE:
                return compose(dftx_pool_1.CPoolRemoveLiquidity.OP_NAME, d => new dftx_pool_1.CPoolRemoveLiquidity(d));
            case dftx_pool_1.CPoolCreatePair.OP_CODE:
                return compose(dftx_pool_1.CPoolCreatePair.OP_NAME, d => new dftx_pool_1.CPoolCreatePair(d));
            case dftx_pool_1.CPoolUpdatePair.OP_CODE:
                return compose(dftx_pool_1.CPoolUpdatePair.OP_NAME, d => new dftx_pool_1.CPoolUpdatePair(d));
            case dftx_token_1.CTokenMint.OP_CODE:
                return compose(dftx_token_1.CTokenMint.OP_NAME, d => new dftx_token_1.CTokenMint(d));
            case dftx_token_1.CTokenCreate.OP_CODE:
                return compose(dftx_token_1.CTokenCreate.OP_NAME, d => new dftx_token_1.CTokenCreate(d));
            case dftx_token_1.CTokenUpdate.OP_CODE:
                return compose(dftx_token_1.CTokenUpdate.OP_NAME, d => new dftx_token_1.CTokenUpdate(d));
            case dftx_token_1.CTokenUpdateAny.OP_CODE:
                return compose(dftx_token_1.CTokenUpdateAny.OP_NAME, d => new dftx_token_1.CTokenUpdateAny(d));
            case dftx_account_1.CUtxosToAccount.OP_CODE:
                return compose(dftx_account_1.CUtxosToAccount.OP_NAME, d => new dftx_account_1.CUtxosToAccount(d));
            case dftx_account_1.CAccountToUtxos.OP_CODE:
                return compose(dftx_account_1.CAccountToUtxos.OP_NAME, d => new dftx_account_1.CAccountToUtxos(d));
            case dftx_account_1.CAccountToAccount.OP_CODE:
                return compose(dftx_account_1.CAccountToAccount.OP_NAME, d => new dftx_account_1.CAccountToAccount(d));
            case dftx_account_1.CAnyAccountToAccount.OP_CODE:
                return compose(dftx_account_1.CAnyAccountToAccount.OP_NAME, d => new dftx_account_1.CAnyAccountToAccount(d));
            case dftx_oracles_1.CAppointOracle.OP_CODE:
                return compose(dftx_oracles_1.CAppointOracle.OP_NAME, d => new dftx_oracles_1.CAppointOracle(d));
            case dftx_oracles_1.CRemoveOracle.OP_CODE:
                return compose(dftx_oracles_1.CRemoveOracle.OP_NAME, d => new dftx_oracles_1.CRemoveOracle(d));
            case dftx_oracles_1.CUpdateOracle.OP_CODE:
                return compose(dftx_oracles_1.CUpdateOracle.OP_NAME, d => new dftx_oracles_1.CUpdateOracle(d));
            case dftx_oracles_1.CSetOracleData.OP_CODE:
                return compose(dftx_oracles_1.CSetOracleData.OP_NAME, d => new dftx_oracles_1.CSetOracleData(d));
            case dftx_misc_1.CAutoAuthPrep.OP_CODE:
                return compose(dftx_misc_1.CAutoAuthPrep.OP_NAME, () => new dftx_misc_1.CAutoAuthPrep());
            case dftx_masternode_1.CCreateMasternode.OP_CODE:
                return compose(dftx_masternode_1.CCreateMasternode.OP_NAME, d => new dftx_masternode_1.CCreateMasternode(d));
            case dftx_masternode_1.CResignMasternode.OP_CODE:
                return compose(dftx_masternode_1.CResignMasternode.OP_NAME, d => new dftx_masternode_1.CResignMasternode(d));
            case dftx_governance_1.CSetGovernance.OP_CODE:
                return compose(dftx_governance_1.CSetGovernance.OP_NAME, d => new dftx_governance_1.CSetGovernance(d));
            case dftx_governance_1.CSetGovernanceHeight.OP_CODE:
                return compose(dftx_governance_1.CSetGovernanceHeight.OP_NAME, d => new dftx_governance_1.CSetGovernanceHeight(d));
            case dftx_icxorderbook_1.CICXCreateOrder.OP_CODE:
                return compose(dftx_icxorderbook_1.CICXCreateOrder.OP_NAME, d => new dftx_icxorderbook_1.CICXCreateOrder(d));
            case dftx_icxorderbook_1.CICXMakeOffer.OP_CODE:
                return compose(dftx_icxorderbook_1.CICXMakeOffer.OP_NAME, d => new dftx_icxorderbook_1.CICXMakeOffer(d));
            case dftx_icxorderbook_1.CICXCloseOrder.OP_CODE:
                return compose(dftx_icxorderbook_1.CICXCloseOrder.OP_NAME, d => new dftx_icxorderbook_1.CICXCloseOrder(d));
            case dftx_icxorderbook_1.CICXCloseOffer.OP_CODE:
                return compose(dftx_icxorderbook_1.CICXCloseOffer.OP_NAME, d => new dftx_icxorderbook_1.CICXCloseOffer(d));
            case dftx_governance_1.CCreateCfp.OP_CODE:
                return compose(dftx_governance_1.CCreateCfp.OP_NAME, d => new dftx_governance_1.CCreateCfp(d));
            case dftx_governance_1.CCreateVoc.OP_CODE:
                return compose(dftx_governance_1.CCreateVoc.OP_NAME, d => new dftx_governance_1.CCreateVoc(d));
            case dftx_governance_1.CVote.OP_CODE:
                return compose(dftx_governance_1.CVote.OP_NAME, d => new dftx_governance_1.CVote(d));
            case dftx_icxorderbook_1.CICXSubmitDFCHTLC.OP_CODE:
                return compose(dftx_icxorderbook_1.CICXSubmitDFCHTLC.OP_NAME, d => new dftx_icxorderbook_1.CICXSubmitDFCHTLC(d));
            case dftx_icxorderbook_1.CICXSubmitEXTHTLC.OP_CODE:
                return compose(dftx_icxorderbook_1.CICXSubmitEXTHTLC.OP_NAME, d => new dftx_icxorderbook_1.CICXSubmitEXTHTLC(d));
            case dftx_icxorderbook_1.CICXClaimDFCHTLC.OP_CODE:
                return compose(dftx_icxorderbook_1.CICXClaimDFCHTLC.OP_NAME, d => new dftx_icxorderbook_1.CICXClaimDFCHTLC(d));
            case dftx_loans_1.CSetLoanScheme.OP_CODE:
                return compose(dftx_loans_1.CSetLoanScheme.OP_NAME, d => new dftx_loans_1.CSetLoanScheme(d));
            case dftx_loans_1.CDestroyLoanScheme.OP_CODE:
                return compose(dftx_loans_1.CDestroyLoanScheme.OP_NAME, d => new dftx_loans_1.CDestroyLoanScheme(d));
            case dftx_loans_1.CSetDefaultLoanScheme.OP_CODE:
                return compose(dftx_loans_1.CSetDefaultLoanScheme.OP_NAME, d => new dftx_loans_1.CSetDefaultLoanScheme(d));
            case dftx_loans_1.CSetCollateralToken.OP_CODE:
                return compose(dftx_loans_1.CSetCollateralToken.OP_NAME, d => new dftx_loans_1.CSetCollateralToken(d));
            case dftx_loans_1.CSetLoanToken.OP_CODE:
                return compose(dftx_loans_1.CSetLoanToken.OP_NAME, d => new dftx_loans_1.CSetLoanToken(d));
            case dftx_loans_1.CUpdateLoanToken.OP_CODE:
                return compose(dftx_loans_1.CUpdateLoanToken.OP_NAME, d => new dftx_loans_1.CUpdateLoanToken(d));
            case dftx_loans_1.CCreateVault.OP_CODE:
                return compose(dftx_loans_1.CCreateVault.OP_NAME, d => new dftx_loans_1.CCreateVault(d));
            case dftx_loans_1.CUpdateVault.OP_CODE:
                return compose(dftx_loans_1.CUpdateVault.OP_NAME, d => new dftx_loans_1.CUpdateVault(d));
            case dftx_loans_1.CDepositToVault.OP_CODE:
                return compose(dftx_loans_1.CDepositToVault.OP_NAME, d => new dftx_loans_1.CDepositToVault(d));
            case dftx_loans_1.CWithdrawFromVault.OP_CODE:
                return compose(dftx_loans_1.CWithdrawFromVault.OP_NAME, d => new dftx_loans_1.CWithdrawFromVault(d));
            case dftx_loans_1.CCloseVault.OP_CODE:
                return compose(dftx_loans_1.CCloseVault.OP_NAME, d => new dftx_loans_1.CCloseVault(d));
            case dftx_loans_1.CTakeLoan.OP_CODE:
                return compose(dftx_loans_1.CTakeLoan.OP_NAME, d => new dftx_loans_1.CTakeLoan(d));
            case dftx_loans_1.CPaybackLoan.OP_CODE:
                return compose(dftx_loans_1.CPaybackLoan.OP_NAME, d => new dftx_loans_1.CPaybackLoan(d));
            case dftx_loans_1.CPlaceAuctionBid.OP_CODE:
                return compose(dftx_loans_1.CPlaceAuctionBid.OP_NAME, d => new dftx_loans_1.CPlaceAuctionBid(d));
            default:
                return compose(dftx_unmapped_1.CDeFiOpUnmapped.OP_NAME, d => new dftx_unmapped_1.CDeFiOpUnmapped(d));
        }
    }
}
exports.CDfTx = CDfTx;
CDfTx.SIGNATURE = 0x44665478;

},{"./dftx_account":103,"./dftx_governance":105,"./dftx_icxorderbook":106,"./dftx_loans":107,"./dftx_masternode":108,"./dftx_misc":109,"./dftx_oracles":110,"./dftx_pool":111,"./dftx_token":113,"./dftx_unmapped":114,"@defichain/jellyfish-buffer":63}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CAnyAccountToAccount = exports.CAccountToAccount = exports.CAccountToUtxos = exports.CUtxosToAccount = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const tx_composer_1 = require("../../tx_composer");
const dftx_balance_1 = require("./dftx_balance");
/**
 * Composable UtxosToAccount, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CUtxosToAccount extends jellyfish_buffer_1.ComposableBuffer {
    composers(u2a) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => u2a.to, v => u2a.to = v, v => new dftx_balance_1.CScriptBalances(v))
        ];
    }
}
exports.CUtxosToAccount = CUtxosToAccount;
CUtxosToAccount.OP_CODE = 0x55; // 'U'
CUtxosToAccount.OP_NAME = 'OP_DEFI_TX_UTXOS_TO_ACCOUNT';
/**
 * Composable UtxosToAccount, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CAccountToUtxos extends jellyfish_buffer_1.ComposableBuffer {
    composers(a2u) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => a2u.from, v => a2u.from = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => a2u.balances, v => a2u.balances = v, v => new dftx_balance_1.CTokenBalance(v)),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => a2u.mintingOutputsStart, v => a2u.mintingOutputsStart = v)
        ];
    }
}
exports.CAccountToUtxos = CAccountToUtxos;
CAccountToUtxos.OP_CODE = 0x62; // 'b'
CAccountToUtxos.OP_NAME = 'OP_DEFI_TX_ACCOUNT_TO_UTXOS';
/**
 * Composable UtxosToAccount, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CAccountToAccount extends jellyfish_buffer_1.ComposableBuffer {
    composers(a2a) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => a2a.from, v => a2a.from = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => a2a.to, v => a2a.to = v, v => new dftx_balance_1.CScriptBalances(v))
        ];
    }
}
exports.CAccountToAccount = CAccountToAccount;
CAccountToAccount.OP_CODE = 0x42; // 'B'
CAccountToAccount.OP_NAME = 'OP_DEFI_TX_ACCOUNT_TO_ACCOUNT';
/**
 * Composable UtxosToAccount, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CAnyAccountToAccount extends jellyfish_buffer_1.ComposableBuffer {
    composers(aa2a) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => aa2a.from, v => aa2a.from = v, v => new dftx_balance_1.CScriptBalances(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => aa2a.to, v => aa2a.to = v, v => new dftx_balance_1.CScriptBalances(v))
        ];
    }
}
exports.CAnyAccountToAccount = CAnyAccountToAccount;
CAnyAccountToAccount.OP_CODE = 0x61; // 'a'
CAnyAccountToAccount.OP_NAME = 'OP_DEFI_TX_ANY_ACCOUNT_TO_ACCOUNT';

},{"../../tx_composer":124,"./dftx_balance":104,"@defichain/jellyfish-buffer":63}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTokenBalanceVarInt = exports.CScriptBalances = exports.CTokenBalance = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const tx_composer_1 = require("../../tx_composer");
/**
 * Composable TokenBalance, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenBalance extends jellyfish_buffer_1.ComposableBuffer {
    composers(tb) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => tb.token, v => tb.token = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => tb.amount, v => tb.amount = v)
        ];
    }
}
exports.CTokenBalance = CTokenBalance;
/**
 * Composable ScriptBalances, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CScriptBalances extends jellyfish_buffer_1.ComposableBuffer {
    composers(sb) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => sb.script, v => sb.script = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => sb.balances, v => sb.balances = v, v => new CTokenBalance(v))
        ];
    }
}
exports.CScriptBalances = CScriptBalances;
/**
 * Composable TokenBalanceVarInt, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenBalanceVarInt extends jellyfish_buffer_1.ComposableBuffer {
    composers(tb) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => tb.token, v => tb.token = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => tb.amount, v => tb.amount = v)
        ];
    }
}
exports.CTokenBalanceVarInt = CTokenBalanceVarInt;

},{"../../tx_composer":124,"@defichain/jellyfish-buffer":63}],105:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CVote = exports.CCreateVoc = exports.CCreateCfp = exports.CCreateProposal = exports.CSetGovernanceHeight = exports.CSetGovernance = exports.CGovernanceVarWithHeight = exports.CGovernanceVarWithoutHeight = exports.CGovernanceVar = exports.CLiqPoolSplit = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const tx_composer_1 = require("../../tx_composer");
class CLiqPoolSplit extends jellyfish_buffer_1.ComposableBuffer {
    composers(lps) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => lps.tokenId, v => lps.tokenId = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => lps.value, v => lps.value = v)
        ];
    }
}
exports.CLiqPoolSplit = CLiqPoolSplit;
class CGovernanceVar extends jellyfish_buffer_1.ComposableBuffer {
    composers(gv) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => gv.key, v => gv.key = v),
            {
                fromBuffer: (buffer) => {
                    if (gv.key === 'LP_DAILY_DFI_REWARD') {
                        gv.value = jellyfish_buffer_1.readBigNumberUInt64(buffer).div('1e8');
                    }
                    else if (gv.key === 'LP_SPLITS') {
                        gv.value = [];
                        const configLen = buffer.readUInt8();
                        for (let i = 0; i < configLen; i++) {
                            gv.value.push(new CLiqPoolSplit(buffer).toObject());
                        }
                    }
                    else {
                        let remainingLength = buffer.remaining();
                        if (this.isWithHeight()) {
                            remainingLength -= 4; // 4 bytes reserved for SetGovernanceHeight's height data
                        }
                        gv.value = buffer.readBuffer(remainingLength).toString('hex');
                    }
                },
                toBuffer: (buffer) => {
                    if (gv.key === 'LP_DAILY_DFI_REWARD') {
                        jellyfish_buffer_1.writeBigNumberUInt64(gv.value.times('1e8'), buffer);
                    }
                    else if (gv.key === 'LP_SPLITS') {
                        const lpss = gv.value;
                        buffer.writeUInt8(lpss.length);
                        lpss.forEach(lps => new CLiqPoolSplit(lps).toBuffer(buffer));
                    }
                    else { // UNMAPPED
                        buffer.writeBuffer(Buffer.from(gv.value, 'hex'));
                    }
                }
            }
        ];
    }
}
exports.CGovernanceVar = CGovernanceVar;
class CGovernanceVarWithoutHeight extends CGovernanceVar {
    isWithHeight() {
        return false;
    }
}
exports.CGovernanceVarWithoutHeight = CGovernanceVarWithoutHeight;
class CGovernanceVarWithHeight extends CGovernanceVar {
    isWithHeight() {
        return true;
    }
}
exports.CGovernanceVarWithHeight = CGovernanceVarWithHeight;
/**
 * Composable CSetGovernance, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CSetGovernance extends jellyfish_buffer_1.ComposableBuffer {
    composers(gvs) {
        return [
            {
                fromBuffer: (buffer) => {
                    gvs.governanceVars = [];
                    while (buffer.remaining() > 0) {
                        const govVar = new CGovernanceVarWithoutHeight(buffer);
                        gvs.governanceVars.push(govVar.toObject());
                    }
                },
                toBuffer: (buffer) => {
                    gvs.governanceVars.forEach(gv => new CGovernanceVarWithoutHeight(gv).toBuffer(buffer));
                }
            }
        ];
    }
}
exports.CSetGovernance = CSetGovernance;
CSetGovernance.OP_CODE = 0x47; // 'G'
CSetGovernance.OP_NAME = 'OP_DEFI_TX_SET_GOVERNANCE';
/**
 * Composable CSetGovernanceHeight, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CSetGovernanceHeight extends jellyfish_buffer_1.ComposableBuffer {
    composers(gvs) {
        return [
            {
                fromBuffer: (buffer) => {
                    gvs.governanceVars = [];
                    // entries count in GovVar array is unknown
                    // we have to hardcode the remaining length here to determine the end
                    while (buffer.remaining() > 4) {
                        const govVar = new CGovernanceVarWithHeight(buffer);
                        gvs.governanceVars.push(govVar.toObject());
                    }
                },
                toBuffer: (buffer) => {
                    gvs.governanceVars.forEach(gv => new CGovernanceVarWithHeight(gv).toBuffer(buffer));
                }
            },
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => gvs.activationHeight, v => gvs.activationHeight = v)
        ];
    }
}
exports.CSetGovernanceHeight = CSetGovernanceHeight;
CSetGovernanceHeight.OP_CODE = 0x6a; // 'j'
CSetGovernanceHeight.OP_NAME = 'OP_DEFI_TX_SET_GOVERNANCE_HEIGHT';
/**
 * Composable CCreateProposal, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CCreateProposal extends jellyfish_buffer_1.ComposableBuffer {
    composers(ccp) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => ccp.type, v => ccp.type = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => ccp.address, v => ccp.address = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => ccp.amount, v => ccp.amount = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => ccp.cycles, v => ccp.cycles = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => ccp.title, v => ccp.title = v)
        ];
    }
}
exports.CCreateProposal = CCreateProposal;
class CCreateCfp extends CCreateProposal {
}
exports.CCreateCfp = CCreateCfp;
CCreateCfp.OP_CODE = 0x50; // 'P'
CCreateCfp.OP_NAME = 'OP_DEFI_TX_CREATE_CFP';
class CCreateVoc extends CCreateProposal {
}
exports.CCreateVoc = CCreateVoc;
CCreateVoc.OP_CODE = 0x45; // 'E'
CCreateVoc.OP_NAME = 'OP_DEFI_TX_CREATE_VOC';
/**
 * Composable CVote, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CVote extends jellyfish_buffer_1.ComposableBuffer {
    composers(vote) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => vote.proposalId, v => vote.proposalId = v),
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => vote.masternodeId, v => vote.masternodeId = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => vote.voteDecision, v => vote.voteDecision = v)
        ];
    }
}
exports.CVote = CVote;
CVote.OP_CODE = 0x4f; // 'O'
CVote.OP_NAME = 'OP_DEFI_TX_CREATE_CFP';

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../tx_composer":124,"@defichain/jellyfish-buffer":63,"buffer":3}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CICXCloseOffer = exports.CICXCloseOrder = exports.CICXClaimDFCHTLC = exports.CICXSubmitEXTHTLC = exports.CICXSubmitDFCHTLC = exports.CICXMakeOffer = exports.CICXCreateOrder = exports.ICXOrderType = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const tx_composer_1 = require("../../tx_composer");
var ICXOrderType;
(function (ICXOrderType) {
    /** type for DFI/BTC orders */
    ICXOrderType[ICXOrderType["INTERNAL"] = 1] = "INTERNAL";
    /** type for BTC/DFI orders */
    ICXOrderType[ICXOrderType["EXTERNAL"] = 2] = "EXTERNAL";
})(ICXOrderType = exports.ICXOrderType || (exports.ICXOrderType = {}));
/**
 * Composable ICXCreateOrder, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CICXCreateOrder extends jellyfish_buffer_1.ComposableBuffer {
    composers(cco) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => cco.orderType, v => cco.orderType = v),
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => cco.tokenId, v => cco.tokenId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => cco.ownerAddress, v => cco.ownerAddress = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntOptionalHex(() => cco.receivePubkey, v => cco.receivePubkey = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => cco.amountFrom, v => cco.amountFrom = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => cco.amountToFill, v => cco.amountToFill = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => cco.orderPrice, v => cco.orderPrice = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => cco.expiry, v => cco.expiry = v)
        ];
    }
}
exports.CICXCreateOrder = CICXCreateOrder;
CICXCreateOrder.OP_CODE = 0x31; // '1'
CICXCreateOrder.OP_NAME = 'OP_DEFI_TX_ICX_CREATE_ORDER';
/**
 * Composable ICXMakeOffer, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CICXMakeOffer extends jellyfish_buffer_1.ComposableBuffer {
    composers(cmo) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => cmo.orderTx, v => cmo.orderTx = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => cmo.amount, v => cmo.amount = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => cmo.ownerAddress, v => cmo.ownerAddress = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntOptionalHex(() => cmo.receivePubkey, v => cmo.receivePubkey = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => cmo.expiry, v => cmo.expiry = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => cmo.takerFee, v => cmo.takerFee = v)
        ];
    }
}
exports.CICXMakeOffer = CICXMakeOffer;
CICXMakeOffer.OP_CODE = 0x32; // '2'
CICXMakeOffer.OP_NAME = 'OP_DEFI_TX_ICX_MAKE_OFFER';
/**
 * Composable ICXSubmitDFCHTLC, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CICXSubmitDFCHTLC extends jellyfish_buffer_1.ComposableBuffer {
    composers(msg) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => msg.offerTx, v => msg.offerTx = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => msg.amount, v => msg.amount = v),
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => msg.hash, v => msg.hash = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => msg.timeout, v => msg.timeout = v)
        ];
    }
}
exports.CICXSubmitDFCHTLC = CICXSubmitDFCHTLC;
CICXSubmitDFCHTLC.OP_CODE = 0x33; // '3'
CICXSubmitDFCHTLC.OP_NAME = 'OP_DEFI_TX_ICX_SUBMIT_DFC_HTLC';
/**
 * Composable ICXSubmitEXTHTLC, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CICXSubmitEXTHTLC extends jellyfish_buffer_1.ComposableBuffer {
    composers(msg) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => msg.offerTx, v => msg.offerTx = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => msg.amount, v => msg.amount = v),
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => msg.hash, v => msg.hash = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => msg.htlcScriptAddress, v => msg.htlcScriptAddress = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntHex(() => msg.ownerPubkey, v => msg.ownerPubkey = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => msg.timeout, v => msg.timeout = v)
        ];
    }
}
exports.CICXSubmitEXTHTLC = CICXSubmitEXTHTLC;
CICXSubmitEXTHTLC.OP_CODE = 0x34; // '4'
CICXSubmitEXTHTLC.OP_NAME = 'OP_DEFI_TX_ICX_SUBMIT_EXT_HTLC';
/**
 * Composable ICXClaimDFCHTLC, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CICXClaimDFCHTLC extends jellyfish_buffer_1.ComposableBuffer {
    composers(msg) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => msg.dfcHTLCTx, v => msg.dfcHTLCTx = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntHex(() => msg.seed, v => msg.seed = v)
        ];
    }
}
exports.CICXClaimDFCHTLC = CICXClaimDFCHTLC;
CICXClaimDFCHTLC.OP_CODE = 0x35; // '5'
CICXClaimDFCHTLC.OP_NAME = 'OP_DEFI_TX_ICX_CLAIM_DFC_HTLC';
/**
 * Composable ICXCloseOrder, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CICXCloseOrder extends jellyfish_buffer_1.ComposableBuffer {
    composers(co) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => co.orderTx, v => co.orderTx = v)
        ];
    }
}
exports.CICXCloseOrder = CICXCloseOrder;
CICXCloseOrder.OP_CODE = 0x36; // '6'
CICXCloseOrder.OP_NAME = 'OP_DEFI_TX_ICX_CLOSE_ORDER';
/**
 * Composable ICXCloseOffer, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CICXCloseOffer extends jellyfish_buffer_1.ComposableBuffer {
    composers(co) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => co.offerTx, v => co.offerTx = v)
        ];
    }
}
exports.CICXCloseOffer = CICXCloseOffer;
CICXCloseOffer.OP_CODE = 0x37; // '7'
CICXCloseOffer.OP_NAME = 'OP_DEFI_TX_ICX_CLOSE_OFFER';

},{"../../tx_composer":124,"@defichain/jellyfish-buffer":63}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CPlaceAuctionBid = exports.CCloseVault = exports.CPaybackLoan = exports.CTakeLoan = exports.CWithdrawFromVault = exports.CDepositToVault = exports.CUpdateVault = exports.CCreateVault = exports.CUpdateLoanToken = exports.CSetLoanToken = exports.CSetCollateralToken = exports.CSetDefaultLoanScheme = exports.CDestroyLoanScheme = exports.CSetLoanScheme = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const dftx_balance_1 = require("./dftx_balance");
const tx_composer_1 = require("../../tx_composer");
const dftx_price_1 = require("./dftx_price");
/**
 * Composable CreateLoanScheme and UpdateLoanScheme, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CSetLoanScheme extends jellyfish_buffer_1.ComposableBuffer {
    composers(sls) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => sls.ratio, v => sls.ratio = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => sls.rate, v => sls.rate = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => sls.identifier, v => sls.identifier = v),
            jellyfish_buffer_1.ComposableBuffer.bigNumberUInt64(() => sls.update, v => sls.update = v)
        ];
    }
}
exports.CSetLoanScheme = CSetLoanScheme;
CSetLoanScheme.OP_CODE = 0x4c; // 'L'
CSetLoanScheme.OP_NAME = 'OP_DEFI_TX_SET_LOAN_SCHEME';
/**
 * Composable DestroyLoanScheme, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CDestroyLoanScheme extends jellyfish_buffer_1.ComposableBuffer {
    composers(dls) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => dls.identifier, v => dls.identifier = v),
            jellyfish_buffer_1.ComposableBuffer.bigNumberUInt64(() => dls.height, v => dls.height = v)
        ];
    }
}
exports.CDestroyLoanScheme = CDestroyLoanScheme;
CDestroyLoanScheme.OP_CODE = 0x44; // 'D'
CDestroyLoanScheme.OP_NAME = 'OP_DEFI_TX_DESTROY_LOAN_SCHEME';
/**
 * Composable SetDefaultLoanScheme, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CSetDefaultLoanScheme extends jellyfish_buffer_1.ComposableBuffer {
    composers(sdls) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => sdls.identifier, v => sdls.identifier = v)
        ];
    }
}
exports.CSetDefaultLoanScheme = CSetDefaultLoanScheme;
CSetDefaultLoanScheme.OP_CODE = 0x64; // 'd'
CSetDefaultLoanScheme.OP_NAME = 'OP_DEFI_TX_SET_DEFAULT_LOAN_SCHEME';
/**
 * Composable SetCollateralToken, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CSetCollateralToken extends jellyfish_buffer_1.ComposableBuffer {
    composers(sct) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => sct.token, v => sct.token = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => sct.factor, v => sct.factor = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => sct.currencyPair, v => sct.currencyPair = v, sct => new dftx_price_1.CCurrencyPair(sct)),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => sct.activateAfterBlock, v => sct.activateAfterBlock = v)
        ];
    }
}
exports.CSetCollateralToken = CSetCollateralToken;
CSetCollateralToken.OP_CODE = 0x63; // 'c'
CSetCollateralToken.OP_NAME = 'OP_DEFI_TX_SET_COLLATERAL_TOKEN';
/**
 * Composable SetLoanToken, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CSetLoanToken extends jellyfish_buffer_1.ComposableBuffer {
    composers(slt) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => slt.symbol, v => slt.symbol = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => slt.name, v => slt.name = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => slt.currencyPair, v => slt.currencyPair = v, v => new dftx_price_1.CCurrencyPair(v)),
            jellyfish_buffer_1.ComposableBuffer.uBool8(() => slt.mintable, v => slt.mintable = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => slt.interest, v => slt.interest = v)
        ];
    }
}
exports.CSetLoanToken = CSetLoanToken;
CSetLoanToken.OP_CODE = 0x67; // 'g'
CSetLoanToken.OP_NAME = 'OP_DEFI_TX_SET_LOAN_TOKEN';
/**
 * Composable UpdateLoanToken, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CUpdateLoanToken extends jellyfish_buffer_1.ComposableBuffer {
    composers(ult) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => ult.symbol, v => ult.symbol = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => ult.name, v => ult.name = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => ult.currencyPair, v => ult.currencyPair = v, v => new dftx_price_1.CCurrencyPair(v)),
            jellyfish_buffer_1.ComposableBuffer.uBool8(() => ult.mintable, v => ult.mintable = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => ult.interest, v => ult.interest = v),
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => ult.tokenTx, v => ult.tokenTx = v)
        ];
    }
}
exports.CUpdateLoanToken = CUpdateLoanToken;
CUpdateLoanToken.OP_CODE = 0x78; // 'x'
CUpdateLoanToken.OP_NAME = 'OP_DEFI_TX_UPDATE_LOAN_TOKEN';
/**
 * Composable CreateVault, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CCreateVault extends jellyfish_buffer_1.ComposableBuffer {
    composers(cv) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => cv.ownerAddress, v => cv.ownerAddress = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => cv.schemeId, v => cv.schemeId = v)
        ];
    }
}
exports.CCreateVault = CCreateVault;
CCreateVault.OP_CODE = 0x56; // 'V'
CCreateVault.OP_NAME = 'OP_DEFI_TX_CREATE_VAULT';
/**
 * Composable UpdateVault, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CUpdateVault extends jellyfish_buffer_1.ComposableBuffer {
    composers(uv) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => uv.vaultId, v => uv.vaultId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => uv.ownerAddress, v => uv.ownerAddress = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => uv.schemeId, v => uv.schemeId = v)
        ];
    }
}
exports.CUpdateVault = CUpdateVault;
CUpdateVault.OP_CODE = 0x76; // 'v'
CUpdateVault.OP_NAME = 'OP_DEFI_TX_UPDATE_VAULT';
/**
 * Composable DepositToVault, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CDepositToVault extends jellyfish_buffer_1.ComposableBuffer {
    composers(dtv) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => dtv.vaultId, v => dtv.vaultId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => dtv.from, v => dtv.from = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.single(() => dtv.tokenAmount, v => dtv.tokenAmount = v, v => new dftx_balance_1.CTokenBalanceVarInt(v))
        ];
    }
}
exports.CDepositToVault = CDepositToVault;
CDepositToVault.OP_CODE = 0x53; // 'S'
CDepositToVault.OP_NAME = 'OP_DEFI_TX_DEPOSIT_TO_VAULT';
/**
 * Composable WithdrawFromVault, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CWithdrawFromVault extends jellyfish_buffer_1.ComposableBuffer {
    composers(dtv) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => dtv.vaultId, v => dtv.vaultId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => dtv.to, v => dtv.to = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.single(() => dtv.tokenAmount, v => dtv.tokenAmount = v, v => new dftx_balance_1.CTokenBalanceVarInt(v))
        ];
    }
}
exports.CWithdrawFromVault = CWithdrawFromVault;
CWithdrawFromVault.OP_CODE = 0x4A; // 'J'
CWithdrawFromVault.OP_NAME = 'OP_DEFI_TX_WITHDRAW_FROM_VAULT';
/**
 * Composable TakeLoan, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTakeLoan extends jellyfish_buffer_1.ComposableBuffer {
    composers(tl) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => tl.vaultId, v => tl.vaultId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => tl.to, v => tl.to = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => tl.tokenAmounts, v => tl.tokenAmounts = v, v => new dftx_balance_1.CTokenBalance(v))
        ];
    }
}
exports.CTakeLoan = CTakeLoan;
CTakeLoan.OP_CODE = 0x58; // 'X'
CTakeLoan.OP_NAME = 'OP_DEFI_TX_TAKE_LOAN';
/**
 * Composable PaybackLoan, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CPaybackLoan extends jellyfish_buffer_1.ComposableBuffer {
    composers(pl) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => pl.vaultId, v => pl.vaultId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => pl.from, v => pl.from = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => pl.tokenAmounts, v => pl.tokenAmounts = v, v => new dftx_balance_1.CTokenBalance(v))
        ];
    }
}
exports.CPaybackLoan = CPaybackLoan;
CPaybackLoan.OP_CODE = 0x48; // 'H'
CPaybackLoan.OP_NAME = 'OP_DEFI_TX_PAYBACK_LOAN';
/**
 * Composable CloseVault, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CCloseVault extends jellyfish_buffer_1.ComposableBuffer {
    composers(cv) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => cv.vaultId, v => cv.vaultId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => cv.to, v => cv.to = v, v => new tx_composer_1.CScript(v))
        ];
    }
}
exports.CCloseVault = CCloseVault;
CCloseVault.OP_CODE = 0x65; // 'e'
CCloseVault.OP_NAME = 'OP_DEFI_TX_CLOSE_VAULT';
/**
 * Composable PlaceAuctionBid, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CPlaceAuctionBid extends jellyfish_buffer_1.ComposableBuffer {
    composers(pab) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => pab.vaultId, v => pab.vaultId = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => pab.index, v => pab.index = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => pab.from, v => pab.from = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.single(() => pab.tokenAmount, v => pab.tokenAmount = v, v => new dftx_balance_1.CTokenBalanceVarInt(v))
        ];
    }
}
exports.CPlaceAuctionBid = CPlaceAuctionBid;
CPlaceAuctionBid.OP_CODE = 0x49; // 'I'
CPlaceAuctionBid.OP_NAME = 'OP_DEFI_TX_AUCTION_BID';

},{"../../tx_composer":124,"./dftx_balance":104,"./dftx_price":112,"@defichain/jellyfish-buffer":63}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CResignMasternode = exports.CCreateMasternode = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
/**
 * Composable CreateMasternode, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CCreateMasternode extends jellyfish_buffer_1.ComposableBuffer {
    composers(cmn) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => cmn.operatorType, v => cmn.operatorType = v),
            jellyfish_buffer_1.ComposableBuffer.hex(20, () => cmn.operatorPubKeyHash, v => cmn.operatorPubKeyHash = v),
            {
                fromBuffer: (buffer) => {
                    if (buffer.remaining() > 0) {
                        cmn.timelock = buffer.readUInt16LE();
                    }
                },
                toBuffer: (buffer) => {
                    if (cmn.timelock !== undefined) {
                        buffer.writeUInt16LE(cmn.timelock);
                    }
                }
            }
        ];
    }
}
exports.CCreateMasternode = CCreateMasternode;
CCreateMasternode.OP_CODE = 0x43; // 'C'
CCreateMasternode.OP_NAME = 'OP_DEFI_TX_CREATE_MASTER_NODE';
/**
 * Composable ResignMasternode, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CResignMasternode extends jellyfish_buffer_1.ComposableBuffer {
    composers(cmn) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => cmn.nodeId, v => cmn.nodeId = v)
        ];
    }
}
exports.CResignMasternode = CResignMasternode;
CResignMasternode.OP_CODE = 0x52; // 'R'
CResignMasternode.OP_NAME = 'OP_DEFI_TX_RESIGN_MASTER_NODE';

},{"@defichain/jellyfish-buffer":63}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CAutoAuthPrep = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
/**
 * Composable UtxosToAccount, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CAutoAuthPrep extends jellyfish_buffer_1.ComposableBuffer {
    constructor() {
        super({});
    }
    composers() {
        return [];
    }
}
exports.CAutoAuthPrep = CAutoAuthPrep;
CAutoAuthPrep.OP_CODE = 0x41; // 'A'
CAutoAuthPrep.OP_NAME = 'OP_DEFI_TX_AUTO_AUTH_PREP';

},{"@defichain/jellyfish-buffer":63}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CSetOracleData = exports.CUpdateOracle = exports.CRemoveOracle = exports.CAppointOracle = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const dftx_price_1 = require("./dftx_price");
const tx_composer_1 = require("../../tx_composer");
/**
 * Composable AppointOracle, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CAppointOracle extends jellyfish_buffer_1.ComposableBuffer {
    composers(ao) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => ao.script, v => ao.script = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => ao.weightage, v => ao.weightage = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => ao.priceFeeds, v => ao.priceFeeds = v, v => new dftx_price_1.CCurrencyPair(v))
        ];
    }
}
exports.CAppointOracle = CAppointOracle;
CAppointOracle.OP_CODE = 0x6f;
CAppointOracle.OP_NAME = 'OP_DEFI_TX_APPOINT_ORACLE';
/**
 * Composable RemoveOracle, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CRemoveOracle extends jellyfish_buffer_1.ComposableBuffer {
    composers(ao) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => ao.oracleId, v => ao.oracleId = v)
        ];
    }
}
exports.CRemoveOracle = CRemoveOracle;
CRemoveOracle.OP_CODE = 0x68;
CRemoveOracle.OP_NAME = 'OP_DEFI_TX_REMOVE_ORACLE';
/**
 * Composable UpdateOracle, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CUpdateOracle extends jellyfish_buffer_1.ComposableBuffer {
    composers(ao) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => ao.oracleId, v => ao.oracleId = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => ao.script, v => ao.script = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => ao.weightage, v => ao.weightage = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => ao.priceFeeds, v => ao.priceFeeds = v, v => new dftx_price_1.CCurrencyPair(v))
        ];
    }
}
exports.CUpdateOracle = CUpdateOracle;
CUpdateOracle.OP_CODE = 0x74;
CUpdateOracle.OP_NAME = 'OP_DEFI_TX_UPDATE_ORACLE';
/**
 * Composable SetOracleData, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CSetOracleData extends jellyfish_buffer_1.ComposableBuffer {
    composers(ao) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => ao.oracleId, v => ao.oracleId = v),
            jellyfish_buffer_1.ComposableBuffer.bigNumberUInt64(() => ao.timestamp, v => ao.timestamp = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => ao.tokens, v => ao.tokens = v, v => new dftx_price_1.CTokenPrice(v))
        ];
    }
}
exports.CSetOracleData = CSetOracleData;
CSetOracleData.OP_CODE = 0x79;
CSetOracleData.OP_NAME = 'OP_DEFI_TX_SET_ORACLE_DATA';

},{"../../tx_composer":124,"./dftx_price":112,"@defichain/jellyfish-buffer":63}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CPoolUpdatePair = exports.CPoolCreatePair = exports.CPoolRemoveLiquidity = exports.CPoolAddLiquidity = exports.CCompositeSwap = exports.CPoolId = exports.CPoolSwap = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const tx_composer_1 = require("../../tx_composer");
const dftx_balance_1 = require("./dftx_balance");
/**
 * Composable PoolSwap, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 * @throws Error if more than 8 decimals
 */
class CPoolSwap extends jellyfish_buffer_1.ComposableBuffer {
    composers(ps) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => ps.fromScript, v => ps.fromScript = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => ps.fromTokenId, v => ps.fromTokenId = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => ps.fromAmount, v => ps.fromAmount = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => ps.toScript, v => ps.toScript = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => ps.toTokenId, v => ps.toTokenId = v),
            jellyfish_buffer_1.ComposableBuffer.maxPriceAsBigNumber(() => ps.maxPrice, v => ps.maxPrice = v)
        ];
    }
}
exports.CPoolSwap = CPoolSwap;
CPoolSwap.OP_CODE = 0x73;
CPoolSwap.OP_NAME = 'OP_DEFI_TX_POOL_SWAP';
/**
 * Composable PoolId, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CPoolId extends jellyfish_buffer_1.ComposableBuffer {
    composers(pi) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => pi.id, v => pi.id = v)
        ];
    }
}
exports.CPoolId = CPoolId;
/**
 * Composable CompositeSwap, C stands for Composable.
 * Extends from CPoolSwap as it contains same data structure but with different DfTx OP_CODE.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 * @throws Error if more than 8 decimals
 */
class CCompositeSwap extends jellyfish_buffer_1.ComposableBuffer {
    composers(cs) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => cs.poolSwap, v => cs.poolSwap = v, v => new CPoolSwap(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => cs.pools, v => cs.pools = v, v => new CPoolId(v))
        ];
    }
}
exports.CCompositeSwap = CCompositeSwap;
CCompositeSwap.OP_CODE = 0x69; // 'i'
CCompositeSwap.OP_NAME = 'OP_DEFI_TX_COMPOSITE_SWAP';
/**
 * Composable PoolAddLiquidity, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CPoolAddLiquidity extends jellyfish_buffer_1.ComposableBuffer {
    composers(p) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => p.from, v => p.from = v, v => new dftx_balance_1.CScriptBalances(v)),
            jellyfish_buffer_1.ComposableBuffer.single(() => p.shareAddress, v => p.shareAddress = v, v => new tx_composer_1.CScript(v))
        ];
    }
}
exports.CPoolAddLiquidity = CPoolAddLiquidity;
CPoolAddLiquidity.OP_CODE = 0x6c;
CPoolAddLiquidity.OP_NAME = 'OP_DEFI_TX_POOL_ADD_LIQUIDITY';
/**
 * Composable PoolRemoveLiquidity, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CPoolRemoveLiquidity extends jellyfish_buffer_1.ComposableBuffer {
    composers(p) {
        return [
            jellyfish_buffer_1.ComposableBuffer.single(() => p.script, v => p.script = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => p.tokenId, v => p.tokenId = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => p.amount, v => p.amount = v)
        ];
    }
}
exports.CPoolRemoveLiquidity = CPoolRemoveLiquidity;
CPoolRemoveLiquidity.OP_CODE = 0x72;
CPoolRemoveLiquidity.OP_NAME = 'OP_DEFI_TX_POOL_REMOVE_LIQUIDITY';
/**
 * Composable PoolCreatePair, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CPoolCreatePair extends jellyfish_buffer_1.ComposableBuffer {
    composers(p) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => p.tokenA, v => p.tokenA = v),
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => p.tokenB, v => p.tokenB = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => p.commission, v => p.commission = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => p.ownerAddress, v => p.ownerAddress = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.uBool8(() => p.status, v => p.status = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => p.pairSymbol, v => p.pairSymbol = v),
            // Note(canonbrother): special fix for inconsistent bytes in "block height >= ClarkeQuayHeight" condition
            // https://github.com/DeFiCh/ain/blob/4b70ecd8ee32d00c75be04a786dc75ec4a3c91dd/src/masternodes/rpc_poolpair.cpp#L571-L573
            {
                fromBuffer: (buffer) => {
                    if (buffer.remaining() > 0) {
                        const length = jellyfish_buffer_1.readVarUInt(buffer);
                        p.customRewards = [];
                        for (let i = 0; i < length; i++) {
                            p.customRewards.push(new dftx_balance_1.CTokenBalance(buffer).toObject());
                        }
                    }
                },
                toBuffer: (buffer) => {
                    if (p.customRewards !== undefined) {
                        jellyfish_buffer_1.writeVarUInt(p.customRewards.length, buffer);
                        p.customRewards.forEach(data => new dftx_balance_1.CTokenBalance(data).toBuffer(buffer));
                    }
                }
            }
        ];
    }
}
exports.CPoolCreatePair = CPoolCreatePair;
CPoolCreatePair.OP_CODE = 0x70;
CPoolCreatePair.OP_NAME = 'OP_DEFI_TX_POOL_CREATE_PAIR';
/**
 * Composable PoolUpdatePair, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CPoolUpdatePair extends jellyfish_buffer_1.ComposableBuffer {
    composers(p) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => p.poolId, v => p.poolId = v),
            jellyfish_buffer_1.ComposableBuffer.uBool32(() => p.status, v => p.status = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => p.commission, v => p.commission = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => p.ownerAddress, v => p.ownerAddress = v, v => new tx_composer_1.CScript(v)),
            // Note(canonbrother): special fix for inconsistent bytes in "block height >= ClarkeQuayHeight" condition
            // https://github.com/DeFiCh/ain/blob/4b70ecd8ee32d00c75be04a786dc75ec4a3c91dd/src/masternodes/rpc_poolpair.cpp#L719-721
            {
                fromBuffer: (buffer) => {
                    if (buffer.remaining() > 0) {
                        const length = jellyfish_buffer_1.readVarUInt(buffer);
                        p.customRewards = [];
                        for (let i = 0; i < length; i++) {
                            p.customRewards.push(new dftx_balance_1.CTokenBalance(buffer).toObject());
                        }
                    }
                },
                toBuffer: (buffer) => {
                    if (p.customRewards !== undefined) {
                        jellyfish_buffer_1.writeVarUInt(p.customRewards.length, buffer);
                        p.customRewards.forEach(data => new dftx_balance_1.CTokenBalance(data).toBuffer(buffer));
                    }
                }
            }
        ];
    }
}
exports.CPoolUpdatePair = CPoolUpdatePair;
CPoolUpdatePair.OP_CODE = 0x75;
CPoolUpdatePair.OP_NAME = 'OP_DEFI_TX_POOL_UPDATE_PAIR';

},{"../../tx_composer":124,"./dftx_balance":104,"@defichain/jellyfish-buffer":63}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTokenPrice = exports.CTokenAmount = exports.CCurrencyPair = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
/**
 * Composable CurrencyPair, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CCurrencyPair extends jellyfish_buffer_1.ComposableBuffer {
    composers(cp) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => cp.token, v => cp.token = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => cp.currency, v => cp.currency = v)
        ];
    }
}
exports.CCurrencyPair = CCurrencyPair;
/**
 * Composable TokenAmount, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenAmount extends jellyfish_buffer_1.ComposableBuffer {
    composers(tp) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => tp.currency, v => tp.currency = v),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => tp.amount, v => tp.amount = v)
        ];
    }
}
exports.CTokenAmount = CTokenAmount;
/**
 * Composable TokenPrice, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenPrice extends jellyfish_buffer_1.ComposableBuffer {
    composers(sb) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => sb.token, v => sb.token = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => sb.prices, v => sb.prices = v, v => new CTokenAmount(v))
        ];
    }
}
exports.CTokenPrice = CTokenPrice;

},{"@defichain/jellyfish-buffer":63}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTokenUpdateAny = exports.CTokenUpdate = exports.CTokenCreate = exports.CTokenMint = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const dftx_balance_1 = require("./dftx_balance");
/**
 * Composable TokenMint, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenMint extends jellyfish_buffer_1.ComposableBuffer {
    composers(tm) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => tm.balances, v => tm.balances = v, v => new dftx_balance_1.CTokenBalance(v))
        ];
    }
}
exports.CTokenMint = CTokenMint;
CTokenMint.OP_CODE = 0x4d; // 'M'
CTokenMint.OP_NAME = 'OP_DEFI_TX_TOKEN_MINT';
/**
 * Composable TokenCreate, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenCreate extends jellyfish_buffer_1.ComposableBuffer {
    composers(tc) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => tc.symbol, v => tc.symbol = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => tc.name, v => tc.name = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => tc.decimal, v => tc.decimal = v),
            jellyfish_buffer_1.ComposableBuffer.bigNumberUInt64(() => tc.limit, v => tc.limit = v),
            jellyfish_buffer_1.ComposableBuffer.bitmask1Byte(3, () => [tc.isDAT, tc.tradeable, tc.mintable], v => {
                tc.isDAT = v[0];
                tc.tradeable = v[1];
                tc.mintable = v[2];
            })
        ];
    }
}
exports.CTokenCreate = CTokenCreate;
CTokenCreate.OP_CODE = 0x54; /// 'T'
CTokenCreate.OP_NAME = 'OP_DEFI_TX_TOKEN_CREATE';
/**
 * Composable CTokenUpdate, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenUpdate extends jellyfish_buffer_1.ComposableBuffer {
    composers(tu) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => tu.creationTx, v => tu.creationTx = v),
            jellyfish_buffer_1.ComposableBuffer.bitmask1Byte(1, () => [tu.isDAT], v => {
                tu.isDAT = v[0];
            })
        ];
    }
}
exports.CTokenUpdate = CTokenUpdate;
CTokenUpdate.OP_CODE = 0x4e; /// 'N'
CTokenUpdate.OP_NAME = 'OP_DEFI_TX_TOKEN_UPDATE';
/**
 * Composable TokenUpdateAny, C stands for Composable.
 * Immutable by design, bi-directional fromBuffer, toBuffer deep composer.
 */
class CTokenUpdateAny extends jellyfish_buffer_1.ComposableBuffer {
    composers(tua) {
        return [
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => tua.creationTx, v => tua.creationTx = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => tua.symbol, v => tua.symbol = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntUtf8BE(() => tua.name, v => tua.name = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => tua.decimal, v => tua.decimal = v),
            jellyfish_buffer_1.ComposableBuffer.bigNumberUInt64(() => tua.limit, v => tua.limit = v),
            jellyfish_buffer_1.ComposableBuffer.bitmask1Byte(3, () => [tua.isDAT, tua.tradeable, tua.mintable], v => {
                tua.isDAT = v[0];
                tua.tradeable = v[1];
                tua.mintable = v[2];
            })
        ];
    }
}
exports.CTokenUpdateAny = CTokenUpdateAny;
CTokenUpdateAny.OP_CODE = 0x6e; /// 'n'
CTokenUpdateAny.OP_NAME = 'OP_DEFI_TX_TOKEN_UPDATE_ANY';

},{"./dftx_balance":104,"@defichain/jellyfish-buffer":63}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CDeFiOpUnmapped = void 0;
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
class CDeFiOpUnmapped extends jellyfish_buffer_1.ComposableBuffer {
    composers(op) {
        return [
            {
                fromBuffer: (buffer) => {
                    op.hex = buffer.readBuffer(buffer.remaining()).toString('hex');
                },
                toBuffer: (buffer) => {
                    buffer.writeString(op.hex, 'hex');
                }
            }
        ];
    }
}
exports.CDeFiOpUnmapped = CDeFiOpUnmapped;
CDeFiOpUnmapped.OP_NAME = 'OP_DEFI_TX_UNMAPPED';

},{"@defichain/jellyfish-buffer":63}],115:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_DEFI_TX = exports.remapDeFiScript = exports.isDeFiScript = void 0;
const smart_buffer_1 = require("smart-buffer");
const opcode_1 = require("../opcode");
const data_1 = require("../data");
const control_1 = require("../control");
const dftx_1 = require("./dftx");
const mapping_1 = require("../mapping");
__exportStar(require("./dftx_account"), exports);
__exportStar(require("./dftx_balance"), exports);
__exportStar(require("./dftx_governance"), exports);
__exportStar(require("./dftx_masternode"), exports);
__exportStar(require("./dftx_misc"), exports);
__exportStar(require("./dftx_oracles"), exports);
__exportStar(require("./dftx_pool"), exports);
__exportStar(require("./dftx_price"), exports);
__exportStar(require("./dftx_token"), exports);
__exportStar(require("./dftx_loans"), exports);
__exportStar(require("./dftx_unmapped"), exports);
__exportStar(require("./dftx_icxorderbook"), exports);
__exportStar(require("./dftx"), exports);
const DEFI_SIGNATURE = '44665478'; // DfTx
/**
 * @param {OPCode[]} stack to check if it is a dftx script
 */
function isDeFiScript(stack) {
    if (stack.length < 2) {
        return false;
    }
    if (!(stack[0] instanceof control_1.OP_RETURN && stack[1] instanceof data_1.OP_PUSHDATA)) {
        return false;
    }
    const pushData = stack[1];
    const hex = pushData.hex;
    return hex.length >= 10 && hex.startsWith(DEFI_SIGNATURE);
}
exports.isDeFiScript = isDeFiScript;
/**
 * @param {OPCode[]} stack to check and remap into OP_DEFI_TX if valid
 */
function remapDeFiScript(stack) {
    if (!isDeFiScript(stack)) {
        return stack;
    }
    const pushData = stack[1];
    const hex = pushData.hex;
    const buffer = smart_buffer_1.SmartBuffer.fromBuffer(Buffer.from(hex, 'hex'));
    const dftx = new dftx_1.CDfTx(buffer);
    return [
        mapping_1.OP_CODES.OP_RETURN,
        mapping_1.OP_CODES.OP_DEFI_TX(dftx.toObject()),
        ...stack.slice(2)
    ];
}
exports.remapDeFiScript = remapDeFiScript;
/**
 * DeFi Transaction wrapped as an OpCode
 */
class OP_DEFI_TX extends opcode_1.OPCode {
    constructor(tx) {
        super('OP_DEFI_TX');
        this.tx = tx;
    }
    asBuffer() {
        const buffer = new smart_buffer_1.SmartBuffer();
        new dftx_1.CDfTx(this.tx).toBuffer(buffer);
        return Buffer.concat([
            data_1.OP_PUSHDATA.getLenOpBuffer(buffer.length),
            buffer.toBuffer()
        ]);
    }
}
exports.OP_DEFI_TX = OP_DEFI_TX;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../control":99,"../data":101,"../mapping":119,"../opcode":120,"./dftx":102,"./dftx_account":103,"./dftx_balance":104,"./dftx_governance":105,"./dftx_icxorderbook":106,"./dftx_loans":107,"./dftx_masternode":108,"./dftx_misc":109,"./dftx_oracles":110,"./dftx_pool":111,"./dftx_price":112,"./dftx_token":113,"./dftx_unmapped":114,"buffer":3,"smart-buffer":273}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_NOP10 = exports.OP_NOP9 = exports.OP_NOP8 = exports.OP_NOP7 = exports.OP_NOP6 = exports.OP_NOP5 = exports.OP_NOP4 = exports.OP_NOP3 = exports.OP_CHECKSEQUENCEVERIFY = exports.OP_NOP2 = exports.OP_CHECKLOCKTIMEVERIFY = exports.OP_NOP1 = void 0;
const opcode_1 = require("./opcode");
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP1 extends opcode_1.StaticCode {
    constructor() {
        super(0xb0, 'OP_NOP1');
    }
}
exports.OP_NOP1 = OP_NOP1;
/**
 * This instruction allows a transaction output to be made unspendable until some point in the future.
 */
class OP_CHECKLOCKTIMEVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0xb1, 'OP_CHECKLOCKTIMEVERIFY');
    }
}
exports.OP_CHECKLOCKTIMEVERIFY = OP_CHECKLOCKTIMEVERIFY;
/**
 * This instruction allows a transaction output to be made unspendable until some point in the future.
 * @See OP_CHECKLOCKTIMEVERIFY
 */
class OP_NOP2 extends OP_CHECKLOCKTIMEVERIFY {
}
exports.OP_NOP2 = OP_NOP2;
/**
 * This instruction allows execution pathways of a script to be restricted based on the age of the output being spent.
 */
class OP_CHECKSEQUENCEVERIFY extends opcode_1.StaticCode {
    constructor() {
        super(0xb2, 'OP_CHECKSEQUENCEVERIFY');
    }
}
exports.OP_CHECKSEQUENCEVERIFY = OP_CHECKSEQUENCEVERIFY;
/**
 * This instruction allows execution pathways of a script to be restricted based on the age of the output being spent.
 * @See OP_CHECKSEQUENCEVERIFY
 */
class OP_NOP3 extends OP_CHECKSEQUENCEVERIFY {
}
exports.OP_NOP3 = OP_NOP3;
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP4 extends opcode_1.StaticCode {
    constructor() {
        super(0xb3, 'OP_NOP4');
    }
}
exports.OP_NOP4 = OP_NOP4;
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP5 extends opcode_1.StaticCode {
    constructor() {
        super(0xb4, 'OP_NOP5');
    }
}
exports.OP_NOP5 = OP_NOP5;
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP6 extends opcode_1.StaticCode {
    constructor() {
        super(0xb5, 'OP_NOP6');
    }
}
exports.OP_NOP6 = OP_NOP6;
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP7 extends opcode_1.StaticCode {
    constructor() {
        super(0xb6, 'OP_NOP7');
    }
}
exports.OP_NOP7 = OP_NOP7;
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP8 extends opcode_1.StaticCode {
    constructor() {
        super(0xb7, 'OP_NOP8');
    }
}
exports.OP_NOP8 = OP_NOP8;
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP9 extends opcode_1.StaticCode {
    constructor() {
        super(0xb8, 'OP_NOP9');
    }
}
exports.OP_NOP9 = OP_NOP9;
/**
 * This instruction performs no operation.
 * No items are added to the stack.
 */
class OP_NOP10 extends opcode_1.StaticCode {
    constructor() {
        super(0xb9, 'OP_NOP10');
    }
}
exports.OP_NOP10 = OP_NOP10;

},{"./opcode":120}],117:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./data"), exports);
__exportStar(require("./constants"), exports);
__exportStar(require("./control"), exports);
__exportStar(require("./stack"), exports);
__exportStar(require("./splice"), exports);
__exportStar(require("./bitwise"), exports);
__exportStar(require("./arithmetic"), exports);
__exportStar(require("./crypto"), exports);
__exportStar(require("./expansion"), exports);
__exportStar(require("./invalid"), exports);
__exportStar(require("./mapping"), exports);
__exportStar(require("./opcode"), exports);
__exportStar(require("./dftx"), exports);

},{"./arithmetic":96,"./bitwise":97,"./constants":98,"./control":99,"./crypto":100,"./data":101,"./dftx":115,"./expansion":116,"./invalid":118,"./mapping":119,"./opcode":120,"./splice":121,"./stack":122}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_INVALIDOPCODE = void 0;
const opcode_1 = require("./opcode");
/**
 * Represents any OP code not currently assigned
 */
class OP_INVALIDOPCODE extends opcode_1.StaticCode {
    constructor() {
        super(0xff, 'OP_INVALIDOPCODE');
    }
}
exports.OP_INVALIDOPCODE = OP_INVALIDOPCODE;

},{"./opcode":120}],119:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_CODES = exports.OP_UNMAPPED = exports.numAsOPCode = void 0;
const smart_buffer_1 = require("smart-buffer");
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const _buffer_1 = require("./_buffer");
const opcode_1 = require("./opcode");
const data_1 = require("./data");
const dftx_1 = require("./dftx");
const dftx_2 = require("./dftx/dftx");
const constants = __importStar(require("./constants"));
const control = __importStar(require("./control"));
const stack = __importStar(require("./stack"));
const splice = __importStar(require("./splice"));
const bitwise = __importStar(require("./bitwise"));
const arithmetic = __importStar(require("./arithmetic"));
const crypto = __importStar(require("./crypto"));
const expansion = __importStar(require("./expansion"));
const invalid = __importStar(require("./invalid"));
const dftx_pool_1 = require("./dftx/dftx_pool");
const dftx_token_1 = require("./dftx/dftx_token");
const dftx_account_1 = require("./dftx/dftx_account");
const dftx_oracles_1 = require("./dftx/dftx_oracles");
const dftx_loans_1 = require("./dftx/dftx_loans");
const dftx_misc_1 = require("./dftx/dftx_misc");
const dftx_governance_1 = require("./dftx/dftx_governance");
const dftx_icxorderbook_1 = require("./dftx/dftx_icxorderbook");
const dftx_masternode_1 = require("./dftx/dftx_masternode");
/**
 * @param num to map as OPCode, 1 byte long
 */
function numAsOPCode(num) {
    if (num > 0xff) {
        throw new Error('OPCode should be 1 byte.');
    }
    const opCode = HEX_MAPPING[num];
    if (opCode !== undefined) {
        return opCode;
    }
    return new OP_UNMAPPED(num);
}
exports.numAsOPCode = numAsOPCode;
/**
 * Unmapped OPCode are codes that don't yet have a class for it yet.
 */
class OP_UNMAPPED extends opcode_1.StaticCode {
    constructor(code) {
        super(code, `OP_UNMAPPED_CODE_${code.toString()}`);
    }
}
exports.OP_UNMAPPED = OP_UNMAPPED;
/**
 * All static OP_CODES & DEFI Custom Tx scripting
 * @see https://github.com/DeFiCh/ain/blob/master/src/script/script.h
 */
exports.OP_CODES = {
    /**
     * Read SmartBuffer and create OPCode[] stack.
     *
     * Using P2WPKH redeem script as an example.
     *
     * Input Example: 1600140e7c0ab18b305bc987a266dc06de26fcfab4b56a
     *   0x16 (VarUInt)
     *   0x00 (OP_0)
     *   6ab5b4fafc26de06dc66a287c95b308bb10a7c0e (formatted as big endian)
     *
     * Output Example:
     *   OP_0
     *   OP_PUSHDATA<RIPEMD160(SHA256(pubkey))>
     *
     * @param {SmartBuffer} buffer to read from
     * @return {OPCode[]} read from buffer to OPCode
     */
    fromBuffer(buffer) {
        const length = jellyfish_buffer_1.readVarUInt(buffer);
        if (length === 0) {
            return [];
        }
        return _buffer_1.toOPCodes(smart_buffer_1.SmartBuffer.fromBuffer(buffer.readBuffer(length)));
    },
    /**
     * Converts OPCode[] and write it into SmartBuffer.
     *
     * Using P2PKH redeem script as an example.
     *
     * Input Example:
     *   OP_DUP
     *   OP_HASH160
     *   OP_PUSHDATA<RIPEMD160(SHA256(pubkey))>
     *   OP_EQUALVERIFY
     *   OP_CHECKSIG
     *
     * Output Example: 1976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac
     *   0x19 (VarUInt)
     *   0x76 (OP_DUP)
     *   0xa9 (OP_HASH160)
     *   5981aa7f16f0e20cd5b2216abe4d7eeedb42de3b (formatted as big endian)
     *   0x88 (OP_EQUALVERIFY)
     *   0xac (OP_CHECKSIG)
     *
     * @param {OPCode[]} stack to convert into raw buffer
     * @param {SmartBuffer} buffer to write to
     */
    toBuffer(stack, buffer) {
        const buffs = _buffer_1.toBuffer(stack);
        // Write the len of buffer in bytes and then all the buffer
        jellyfish_buffer_1.writeVarUInt(buffs.length, buffer);
        buffer.writeBuffer(buffs);
    },
    OP_DEFI_TX: (dftx) => {
        return new dftx_1.OP_DEFI_TX(dftx);
    },
    OP_DEFI_TX_POOL_SWAP: (poolSwap) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_pool_1.CPoolSwap.OP_CODE,
            name: dftx_pool_1.CPoolSwap.OP_NAME,
            data: poolSwap
        });
    },
    OP_DEFI_TX_COMPOSITE_SWAP: (compositeSwap) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_pool_1.CCompositeSwap.OP_CODE,
            name: dftx_pool_1.CCompositeSwap.OP_NAME,
            data: compositeSwap
        });
    },
    OP_DEFI_TX_POOL_ADD_LIQUIDITY: (poolAddLiquidity) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_pool_1.CPoolAddLiquidity.OP_CODE,
            name: dftx_pool_1.CPoolAddLiquidity.OP_NAME,
            data: poolAddLiquidity
        });
    },
    OP_DEFI_TX_POOL_REMOVE_LIQUIDITY: (poolRemoveLiquidity) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_pool_1.CPoolRemoveLiquidity.OP_CODE,
            name: dftx_pool_1.CPoolRemoveLiquidity.OP_NAME,
            data: poolRemoveLiquidity
        });
    },
    OP_DEFI_TX_POOL_CREATE_PAIR: (poolCreatePair) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_pool_1.CPoolCreatePair.OP_CODE,
            name: dftx_pool_1.CPoolCreatePair.OP_NAME,
            data: poolCreatePair
        });
    },
    OP_DEFI_TX_POOL_UPDATE_PAIR: (poolCreatePair) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_pool_1.CPoolUpdatePair.OP_CODE,
            name: dftx_pool_1.CPoolUpdatePair.OP_NAME,
            data: poolCreatePair
        });
    },
    OP_DEFI_TX_TOKEN_MINT: (tokenMint) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_token_1.CTokenMint.OP_CODE,
            name: dftx_token_1.CTokenMint.OP_NAME,
            data: tokenMint
        });
    },
    OP_DEFI_TX_TOKEN_CREATE: (tokenCreate) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_token_1.CTokenCreate.OP_CODE,
            name: dftx_token_1.CTokenCreate.OP_NAME,
            data: tokenCreate
        });
    },
    OP_DEFI_TX_TOKEN_UPDATE: (tokenUpdate) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_token_1.CTokenUpdate.OP_CODE,
            name: dftx_token_1.CTokenUpdate.OP_NAME,
            data: tokenUpdate
        });
    },
    OP_DEFI_TX_TOKEN_UPDATE_ANY: (tokenUpdateAny) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_token_1.CTokenUpdateAny.OP_CODE,
            name: dftx_token_1.CTokenUpdateAny.OP_NAME,
            data: tokenUpdateAny
        });
    },
    OP_DEFI_TX_UTXOS_TO_ACCOUNT: (utxosToAccount) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_account_1.CUtxosToAccount.OP_CODE,
            name: dftx_account_1.CUtxosToAccount.OP_NAME,
            data: utxosToAccount
        });
    },
    OP_DEFI_TX_ACCOUNT_TO_UTXOS: (accountToUtxos) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_account_1.CAccountToUtxos.OP_CODE,
            name: dftx_account_1.CAccountToUtxos.OP_NAME,
            data: accountToUtxos
        });
    },
    OP_DEFI_TX_ACCOUNT_TO_ACCOUNT: (accountToAccount) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_account_1.CAccountToAccount.OP_CODE,
            name: dftx_account_1.CAccountToAccount.OP_NAME,
            data: accountToAccount
        });
    },
    OP_DEFI_TX_ANY_ACCOUNT_TO_ACCOUNT: (anyAccountToAccount) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_account_1.CAnyAccountToAccount.OP_CODE,
            name: dftx_account_1.CAnyAccountToAccount.OP_NAME,
            data: anyAccountToAccount
        });
    },
    OP_DEFI_TX_APPOINT_ORACLE: (appointOracle) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_oracles_1.CAppointOracle.OP_CODE,
            name: dftx_oracles_1.CAppointOracle.OP_NAME,
            data: appointOracle
        });
    },
    OP_DEFI_TX_REMOVE_ORACLE: (removeOracle) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_oracles_1.CRemoveOracle.OP_CODE,
            name: dftx_oracles_1.CRemoveOracle.OP_NAME,
            data: removeOracle
        });
    },
    OP_DEFI_TX_UPDATE_ORACLE: (updateOracle) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_oracles_1.CUpdateOracle.OP_CODE,
            name: dftx_oracles_1.CUpdateOracle.OP_NAME,
            data: updateOracle
        });
    },
    OP_DEFI_TX_SET_ORACLE_DATA: (setOracleData) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_oracles_1.CSetOracleData.OP_CODE,
            name: dftx_oracles_1.CSetOracleData.OP_NAME,
            data: setOracleData
        });
    },
    OP_DEFI_TX_AUTO_AUTH_PREP: () => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_misc_1.CAutoAuthPrep.OP_CODE,
            name: dftx_misc_1.CAutoAuthPrep.OP_NAME,
            data: null
        });
    },
    OP_DEFI_TX_CREATE_MASTER_NODE: (createMasterNode) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_masternode_1.CCreateMasternode.OP_CODE,
            name: dftx_masternode_1.CCreateMasternode.OP_NAME,
            data: createMasterNode
        });
    },
    OP_DEFI_TX_RESIGN_MASTER_NODE: (resignMasternode) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_masternode_1.CResignMasternode.OP_CODE,
            name: dftx_masternode_1.CResignMasternode.OP_NAME,
            data: resignMasternode
        });
    },
    OP_DEFI_TX_SET_GOVERNANCE: (setGovernance) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_governance_1.CSetGovernance.OP_CODE,
            name: dftx_governance_1.CSetGovernance.OP_NAME,
            data: setGovernance
        });
    },
    OP_DEFI_TX_SET_GOVERNANCE_HEIGHT: (setGovernanceHeight) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_governance_1.CSetGovernanceHeight.OP_CODE,
            name: dftx_governance_1.CSetGovernanceHeight.OP_NAME,
            data: setGovernanceHeight
        });
    },
    OP_DEFI_TX_ICX_CREATE_ORDER: (createOrder) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_icxorderbook_1.CICXCreateOrder.OP_CODE,
            name: dftx_icxorderbook_1.CICXCreateOrder.OP_NAME,
            data: createOrder
        });
    },
    OP_DEFI_TX_ICX_MAKE_OFFER: (makeOffer) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_icxorderbook_1.CICXMakeOffer.OP_CODE,
            name: dftx_icxorderbook_1.CICXMakeOffer.OP_NAME,
            data: makeOffer
        });
    },
    OP_DEFI_TX_ICX_CLOSE_ORDER: (closeOrder) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_icxorderbook_1.CICXCloseOrder.OP_CODE,
            name: dftx_icxorderbook_1.CICXCloseOrder.OP_NAME,
            data: closeOrder
        });
    },
    OP_DEFI_TX_ICX_CLOSE_OFFER: (closeOffer) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_icxorderbook_1.CICXCloseOffer.OP_CODE,
            name: dftx_icxorderbook_1.CICXCloseOffer.OP_NAME,
            data: closeOffer
        });
    },
    OP_DEFI_TX_CREATE_CFP: (createCfp) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_governance_1.CCreateCfp.OP_CODE,
            name: dftx_governance_1.CCreateCfp.OP_NAME,
            data: createCfp
        });
    },
    OP_DEFI_TX_CREATE_VOC: (createVoc) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_governance_1.CCreateVoc.OP_CODE,
            name: dftx_governance_1.CCreateVoc.OP_NAME,
            data: createVoc
        });
    },
    OP_DEFI_TX_VOTE: (vote) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_governance_1.CVote.OP_CODE,
            name: dftx_governance_1.CVote.OP_NAME,
            data: vote
        });
    },
    OP_DEFI_TX_ICX_SUBMIT_DFC_HTLC: (icxSubmitDFCHTLC) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_icxorderbook_1.CICXSubmitDFCHTLC.OP_CODE,
            name: dftx_icxorderbook_1.CICXSubmitDFCHTLC.OP_NAME,
            data: icxSubmitDFCHTLC
        });
    },
    OP_DEFI_TX_ICX_SUBMIT_EXT_HTLC: (icxSubmitEXTHTLC) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_icxorderbook_1.CICXSubmitEXTHTLC.OP_CODE,
            name: dftx_icxorderbook_1.CICXSubmitEXTHTLC.OP_NAME,
            data: icxSubmitEXTHTLC
        });
    },
    OP_DEFI_TX_ICX_CLAIM_DFC_HTLC: (icxClaimDFCHTLC) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_icxorderbook_1.CICXClaimDFCHTLC.OP_CODE,
            name: dftx_icxorderbook_1.CICXClaimDFCHTLC.OP_NAME,
            data: icxClaimDFCHTLC
        });
    },
    OP_DEFI_TX_SET_LOAN_SCHEME: (setLoanScheme) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CSetLoanScheme.OP_CODE,
            name: dftx_loans_1.CSetLoanScheme.OP_NAME,
            data: setLoanScheme
        });
    },
    OP_DEFI_TX_DESTROY_LOAN_SCHEME: (destroyLoanScheme) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CDestroyLoanScheme.OP_CODE,
            name: dftx_loans_1.CDestroyLoanScheme.OP_NAME,
            data: destroyLoanScheme
        });
    },
    OP_DEFI_TX_SET_DEFAULT_LOAN_SCHEME: (setDefaultLoanScheme) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CSetDefaultLoanScheme.OP_CODE,
            name: dftx_loans_1.CSetDefaultLoanScheme.OP_NAME,
            data: setDefaultLoanScheme
        });
    },
    OP_DEFI_TX_SET_COLLATERAL_TOKEN: (setCollateralToken) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CSetCollateralToken.OP_CODE,
            name: dftx_loans_1.CSetCollateralToken.OP_NAME,
            data: setCollateralToken
        });
    },
    OP_DEFI_TX_SET_LOAN_TOKEN: (setLoanToken) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CSetLoanToken.OP_CODE,
            name: dftx_loans_1.CSetLoanToken.OP_NAME,
            data: setLoanToken
        });
    },
    OP_DEFI_TX_UPDATE_LOAN_TOKEN: (updateLoanToken) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CUpdateLoanToken.OP_CODE,
            name: dftx_loans_1.CUpdateLoanToken.OP_NAME,
            data: updateLoanToken
        });
    },
    OP_DEFI_TX_CREATE_VAULT: (createVault) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CCreateVault.OP_CODE,
            name: dftx_loans_1.CCreateVault.OP_NAME,
            data: createVault
        });
    },
    OP_DEFI_TX_UPDATE_VAULT: (updateVault) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CUpdateVault.OP_CODE,
            name: dftx_loans_1.CUpdateVault.OP_NAME,
            data: updateVault
        });
    },
    OP_DEFI_TX_DEPOSIT_TO_VAULT: (depositToVault) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CDepositToVault.OP_CODE,
            name: dftx_loans_1.CDepositToVault.OP_NAME,
            data: depositToVault
        });
    },
    OP_DEFI_TX_WITHDRAW_FROM_VAULT: (WithdrawFromVault) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CWithdrawFromVault.OP_CODE,
            name: dftx_loans_1.CWithdrawFromVault.OP_NAME,
            data: WithdrawFromVault
        });
    },
    OP_DEFI_TX_CLOSE_VAULT: (closeVault) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CCloseVault.OP_CODE,
            name: dftx_loans_1.CCloseVault.OP_NAME,
            data: closeVault
        });
    },
    OP_DEFI_TX_TAKE_LOAN: (takeLoan) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CTakeLoan.OP_CODE,
            name: dftx_loans_1.CTakeLoan.OP_NAME,
            data: takeLoan
        });
    },
    OP_DEFI_TX_PAYBACK_LOAN: (paybackLoan) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CPaybackLoan.OP_CODE,
            name: dftx_loans_1.CPaybackLoan.OP_NAME,
            data: paybackLoan
        });
    },
    OP_DEFI_TX_AUCTION_BID: (placeAuctionBid) => {
        return new dftx_1.OP_DEFI_TX({
            signature: dftx_2.CDfTx.SIGNATURE,
            type: dftx_loans_1.CPlaceAuctionBid.OP_CODE,
            name: dftx_loans_1.CPlaceAuctionBid.OP_NAME,
            data: placeAuctionBid
        });
    },
    OP_0: new constants.OP_0(),
    OP_FALSE: new constants.OP_FALSE(),
    /**
     * OP_PUSHDATA1 use OP_PUSHDATA
     * OP_PUSHDATA2 use OP_PUSHDATA
     * OP_PUSHDATA4 use OP_PUSHDATA
     * @param {Buffer} buffer
     * @param {'little' | 'big'} endian order
     */
    OP_PUSHDATA: (buffer, endian) => {
        return new data_1.OP_PUSHDATA(buffer, endian);
    },
    /**
     * @param {Buffer} buffer in little endian
     */
    OP_PUSHDATA_LE: (buffer) => {
        return new data_1.OP_PUSHDATA(buffer, 'little');
    },
    /**
     * @param {string} hex in little endian
     */
    OP_PUSHDATA_HEX_LE: (hex) => {
        return new data_1.OP_PUSHDATA(Buffer.from(hex, 'hex'), 'little');
    },
    // TODO: to map everything as class
    //  to be separated into concerns, stack, arithmetic, crypto, etc...
    OP_1NEGATE: new constants.OP_1NEGATE(),
    OP_RESERVED: new constants.OP_RESERVED(),
    OP_1: new constants.OP_1(),
    OP_TRUE: new constants.OP_TRUE(),
    OP_2: new constants.OP_2(),
    OP_3: new constants.OP_3(),
    OP_4: new constants.OP_4(),
    OP_5: new constants.OP_5(),
    OP_6: new constants.OP_6(),
    OP_7: new constants.OP_7(),
    OP_8: new constants.OP_8(),
    OP_9: new constants.OP_9(),
    OP_10: new constants.OP_10(),
    OP_11: new constants.OP_11(),
    OP_12: new constants.OP_12(),
    OP_13: new constants.OP_13(),
    OP_14: new constants.OP_14(),
    OP_15: new constants.OP_15(),
    OP_16: new constants.OP_16(),
    // control
    OP_NOP: new control.OP_NOP(),
    OP_VER: new control.OP_VER(),
    OP_IF: new control.OP_IF(),
    OP_NOTIF: new control.OP_NOTIF(),
    OP_VERIF: new control.OP_VERIF(),
    OP_VERNOTIF: new control.OP_VERNOTIF(),
    OP_ELSE: new control.OP_ELSE(),
    OP_ENDIF: new control.OP_ENDIF(),
    OP_VERIFY: new control.OP_VERIFY(),
    OP_RETURN: new control.OP_RETURN(),
    // stack
    OP_TOALTSTACK: new stack.OP_TOALTSTACK(),
    OP_FROMALTSTACK: new stack.OP_FROMALTSTACK(),
    OP_2DROP: new stack.OP_2DROP(),
    OP_2DUP: new stack.OP_2DUP(),
    OP_3DUP: new stack.OP_3DUP(),
    OP_2OVER: new stack.OP_2OVER(),
    OP_2ROT: new stack.OP_2ROT(),
    OP_2SWAP: new stack.OP_2SWAP(),
    OP_IFDUP: new stack.OP_IFDUP(),
    OP_DEPTH: new stack.OP_DEPTH(),
    OP_DROP: new stack.OP_DROP(),
    OP_DUP: new stack.OP_DUP(),
    OP_NIP: new stack.OP_NIP(),
    OP_OVER: new stack.OP_OVER(),
    OP_PICK: new stack.OP_PICK(),
    OP_ROLL: new stack.OP_ROLL(),
    OP_ROT: new stack.OP_ROT(),
    OP_SWAP: new stack.OP_SWAP(),
    OP_TUCK: new stack.OP_TUCK(),
    // splice
    OP_CAT: new splice.OP_CAT(),
    OP_SUBSTR: new splice.OP_SUBSTR(),
    OP_LEFT: new splice.OP_LEFT(),
    OP_RIGHT: new splice.OP_RIGHT(),
    OP_SIZE: new splice.OP_SIZE(),
    // bitwise
    OP_INVERT: new bitwise.OP_INVERT(),
    OP_AND: new bitwise.OP_AND(),
    OP_OR: new bitwise.OP_OR(),
    OP_XOR: new bitwise.OP_XOR(),
    OP_EQUAL: new bitwise.OP_EQUAL(),
    OP_EQUALVERIFY: new bitwise.OP_EQUALVERIFY(),
    OP_RESERVED1: new bitwise.OP_RESERVED1(),
    OP_RESERVED2: new bitwise.OP_RESERVED2(),
    // numeric
    OP_1ADD: new arithmetic.OP_1ADD(),
    OP_1SUB: new arithmetic.OP_1SUB(),
    OP_2MUL: new arithmetic.OP_2MUL(),
    OP_2DIV: new arithmetic.OP_2DIV(),
    OP_NEGATE: new arithmetic.OP_NEGATE(),
    OP_ABS: new arithmetic.OP_ABS(),
    OP_NOT: new arithmetic.OP_NOT(),
    OP_0NOTEQUAL: new arithmetic.OP_0NOTEQUAL(),
    OP_ADD: new arithmetic.OP_ADD(),
    OP_SUB: new arithmetic.OP_SUB(),
    OP_MUL: new arithmetic.OP_MUL(),
    OP_DIV: new arithmetic.OP_DIV(),
    OP_MOD: new arithmetic.OP_MOD(),
    OP_LSHIFT: new arithmetic.OP_LSHIFT(),
    OP_RSHIFT: new arithmetic.OP_RSHIFT(),
    OP_BOOLAND: new arithmetic.OP_BOOLAND(),
    OP_BOOLOR: new arithmetic.OP_BOOLOR(),
    OP_NUMEQUAL: new arithmetic.OP_NUMEQUAL(),
    OP_NUMEQUALVERIFY: new arithmetic.OP_NUMEQUALVERIFY(),
    OP_NUMNOTEQUAL: new arithmetic.OP_NUMNOTEQUAL(),
    OP_LESSTHAN: new arithmetic.OP_LESSTHAN(),
    OP_GREATERTHAN: new arithmetic.OP_GREATERTHAN(),
    OP_LESSTHANOREQUAL: new arithmetic.OP_LESSTHANOREQUAL(),
    OP_GREATERTHANOREQUAL: new arithmetic.OP_GREATERTHANOREQUAL(),
    OP_MIN: new arithmetic.OP_MIN(),
    OP_MAX: new arithmetic.OP_MAX(),
    OP_WITHIN: new arithmetic.OP_WITHIN(),
    // crypto
    OP_RIPEMD160: new crypto.OP_RIPEMD160(),
    OP_SHA1: new crypto.OP_SHA1(),
    OP_SHA256: new crypto.OP_SHA256(),
    OP_HASH160: new crypto.OP_HASH160(),
    OP_HASH256: new crypto.OP_HASH256(),
    OP_CODESEPARATOR: new crypto.OP_CODESEPARATOR(),
    OP_CHECKSIG: new crypto.OP_CHECKSIG(),
    OP_CHECKSIGVERIFY: new crypto.OP_CHECKSIGVERIFY(),
    OP_CHECKMULTISIG: new crypto.OP_CHECKMULTISIG(),
    OP_CHECKMULTISIGVERIFY: new crypto.OP_CHECKMULTISIGVERIFY(),
    // expansion
    OP_NOP1: new expansion.OP_NOP1(),
    OP_CHECKLOCKTIMEVERIFY: new expansion.OP_CHECKLOCKTIMEVERIFY(),
    OP_NOP2: new expansion.OP_NOP2(),
    OP_CHECKSEQUENCEVERIFY: new expansion.OP_CHECKSEQUENCEVERIFY(),
    OP_NOP3: new expansion.OP_NOP3(),
    OP_NOP4: new expansion.OP_NOP4(),
    OP_NOP5: new expansion.OP_NOP5(),
    OP_NOP6: new expansion.OP_NOP6(),
    OP_NOP7: new expansion.OP_NOP7(),
    OP_NOP8: new expansion.OP_NOP8(),
    OP_NOP9: new expansion.OP_NOP9(),
    OP_NOP10: new expansion.OP_NOP10(),
    // invalid
    OP_INVALIDOPCODE: new invalid.OP_INVALIDOPCODE()
};
/**
 * Hex code mapping of all static OP_CODES
 */
const HEX_MAPPING = {
    0x00: exports.OP_CODES.OP_0,
    0x4f: exports.OP_CODES.OP_1NEGATE,
    0x50: exports.OP_CODES.OP_RESERVED,
    0x51: exports.OP_CODES.OP_1,
    0x52: exports.OP_CODES.OP_2,
    0x53: exports.OP_CODES.OP_3,
    0x54: exports.OP_CODES.OP_4,
    0x55: exports.OP_CODES.OP_5,
    0x56: exports.OP_CODES.OP_6,
    0x57: exports.OP_CODES.OP_7,
    0x58: exports.OP_CODES.OP_8,
    0x59: exports.OP_CODES.OP_9,
    0x5a: exports.OP_CODES.OP_10,
    0x5b: exports.OP_CODES.OP_11,
    0x5c: exports.OP_CODES.OP_12,
    0x5d: exports.OP_CODES.OP_13,
    0x5e: exports.OP_CODES.OP_14,
    0x5f: exports.OP_CODES.OP_15,
    0x60: exports.OP_CODES.OP_16,
    // control
    0x61: exports.OP_CODES.OP_NOP,
    0x62: exports.OP_CODES.OP_VER,
    0x63: exports.OP_CODES.OP_IF,
    0x64: exports.OP_CODES.OP_NOTIF,
    0x65: exports.OP_CODES.OP_VERIF,
    0x66: exports.OP_CODES.OP_VERNOTIF,
    0x67: exports.OP_CODES.OP_ELSE,
    0x68: exports.OP_CODES.OP_ENDIF,
    0x69: exports.OP_CODES.OP_VERIFY,
    0x6a: exports.OP_CODES.OP_RETURN,
    // stack
    0x6b: exports.OP_CODES.OP_TOALTSTACK,
    0x6c: exports.OP_CODES.OP_FROMALTSTACK,
    0x6d: exports.OP_CODES.OP_2DROP,
    0x6e: exports.OP_CODES.OP_2DUP,
    0x6f: exports.OP_CODES.OP_3DUP,
    0x70: exports.OP_CODES.OP_2OVER,
    0x71: exports.OP_CODES.OP_2ROT,
    0x72: exports.OP_CODES.OP_2SWAP,
    0x73: exports.OP_CODES.OP_IFDUP,
    0x74: exports.OP_CODES.OP_DEPTH,
    0x75: exports.OP_CODES.OP_DROP,
    0x76: exports.OP_CODES.OP_DUP,
    0x77: exports.OP_CODES.OP_NIP,
    0x78: exports.OP_CODES.OP_OVER,
    0x79: exports.OP_CODES.OP_PICK,
    0x7a: exports.OP_CODES.OP_ROLL,
    0x7b: exports.OP_CODES.OP_ROT,
    0x7c: exports.OP_CODES.OP_SWAP,
    0x7d: exports.OP_CODES.OP_TUCK,
    // splice
    0x7e: exports.OP_CODES.OP_CAT,
    0x7f: exports.OP_CODES.OP_SUBSTR,
    0x80: exports.OP_CODES.OP_LEFT,
    0x81: exports.OP_CODES.OP_RIGHT,
    0x82: exports.OP_CODES.OP_SIZE,
    // bitwise
    0x83: exports.OP_CODES.OP_INVERT,
    0x84: exports.OP_CODES.OP_AND,
    0x85: exports.OP_CODES.OP_OR,
    0x86: exports.OP_CODES.OP_XOR,
    0x87: exports.OP_CODES.OP_EQUAL,
    0x88: exports.OP_CODES.OP_EQUALVERIFY,
    0x89: exports.OP_CODES.OP_RESERVED1,
    0x8a: exports.OP_CODES.OP_RESERVED2,
    // numeric
    0x8b: exports.OP_CODES.OP_1ADD,
    0x8c: exports.OP_CODES.OP_1SUB,
    0x8d: exports.OP_CODES.OP_2MUL,
    0x8e: exports.OP_CODES.OP_2DIV,
    0x8f: exports.OP_CODES.OP_NEGATE,
    0x90: exports.OP_CODES.OP_ABS,
    0x91: exports.OP_CODES.OP_NOT,
    0x92: exports.OP_CODES.OP_0NOTEQUAL,
    0x93: exports.OP_CODES.OP_ADD,
    0x94: exports.OP_CODES.OP_SUB,
    0x95: exports.OP_CODES.OP_MUL,
    0x96: exports.OP_CODES.OP_DIV,
    0x97: exports.OP_CODES.OP_MOD,
    0x98: exports.OP_CODES.OP_LSHIFT,
    0x99: exports.OP_CODES.OP_RSHIFT,
    0x9a: exports.OP_CODES.OP_BOOLAND,
    0x9b: exports.OP_CODES.OP_BOOLOR,
    0x9c: exports.OP_CODES.OP_NUMEQUAL,
    0x9d: exports.OP_CODES.OP_NUMEQUALVERIFY,
    0x9e: exports.OP_CODES.OP_NUMNOTEQUAL,
    0x9f: exports.OP_CODES.OP_LESSTHAN,
    0xa0: exports.OP_CODES.OP_GREATERTHAN,
    0xa1: exports.OP_CODES.OP_LESSTHANOREQUAL,
    0xa2: exports.OP_CODES.OP_GREATERTHANOREQUAL,
    0xa3: exports.OP_CODES.OP_MIN,
    0xa4: exports.OP_CODES.OP_MAX,
    0xa5: exports.OP_CODES.OP_WITHIN,
    // crypto
    0xa6: exports.OP_CODES.OP_RIPEMD160,
    0xa7: exports.OP_CODES.OP_SHA1,
    0xa8: exports.OP_CODES.OP_SHA256,
    0xa9: exports.OP_CODES.OP_HASH160,
    0xaa: exports.OP_CODES.OP_HASH256,
    0xab: exports.OP_CODES.OP_CODESEPARATOR,
    0xac: exports.OP_CODES.OP_CHECKSIG,
    0xad: exports.OP_CODES.OP_CHECKSIGVERIFY,
    0xae: exports.OP_CODES.OP_CHECKMULTISIG,
    0xaf: exports.OP_CODES.OP_CHECKMULTISIGVERIFY,
    // expansion
    0xb0: exports.OP_CODES.OP_NOP1,
    0xb1: exports.OP_CODES.OP_CHECKLOCKTIMEVERIFY,
    0xb2: exports.OP_CODES.OP_CHECKSEQUENCEVERIFY,
    0xb3: exports.OP_CODES.OP_NOP4,
    0xb4: exports.OP_CODES.OP_NOP5,
    0xb5: exports.OP_CODES.OP_NOP6,
    0xb6: exports.OP_CODES.OP_NOP7,
    0xb7: exports.OP_CODES.OP_NOP8,
    0xb8: exports.OP_CODES.OP_NOP9,
    0xb9: exports.OP_CODES.OP_NOP10,
    // invalid
    0xff: exports.OP_CODES.OP_INVALIDOPCODE
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./_buffer":95,"./arithmetic":96,"./bitwise":97,"./constants":98,"./control":99,"./crypto":100,"./data":101,"./dftx":115,"./dftx/dftx":102,"./dftx/dftx_account":103,"./dftx/dftx_governance":105,"./dftx/dftx_icxorderbook":106,"./dftx/dftx_loans":107,"./dftx/dftx_masternode":108,"./dftx/dftx_misc":109,"./dftx/dftx_oracles":110,"./dftx/dftx_pool":111,"./dftx/dftx_token":113,"./expansion":116,"./invalid":118,"./opcode":120,"./splice":121,"./stack":122,"@defichain/jellyfish-buffer":63,"buffer":3,"smart-buffer":273}],120:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticCode = exports.OPCode = void 0;
/**
 * Operation code, script words, opcodes, commands and functions there are many names to this.
 * This is essentially things to be pushed into the DeFi scripting stack.
 *
 * Like bitcoin, it uses a scripting system for transactions.
 * Script is simple, stack-based, and processed from left to right.
 * It is intentionally none Turing-complete, with no loops.
 *
 * In jellyfish-transaction, this stack scripting is implemented as class for first class type support.
 * This allows instanceof assertions and wraps all data to be pushed into a stack as a an instantiatable object.
 */
class OPCode {
    constructor(type) {
        this.type = type;
    }
}
exports.OPCode = OPCode;
/**
 * Statically mapped code of OPCode
 */
class StaticCode extends OPCode {
    constructor(code, type) {
        super(type);
        this.code = code;
    }
    asBuffer() {
        const buffer = Buffer.allocUnsafe(1);
        buffer.writeUInt8(this.code);
        return buffer;
    }
}
exports.StaticCode = StaticCode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_SIZE = exports.OP_RIGHT = exports.OP_LEFT = exports.OP_SUBSTR = exports.OP_CAT = void 0;
const opcode_1 = require("./opcode");
/**
 * Concatenates two strings. disabled.
 */
class OP_CAT extends opcode_1.StaticCode {
    constructor() {
        super(0x7e, 'OP_CAT');
    }
}
exports.OP_CAT = OP_CAT;
/**
 * Returns a section of a string. disabled.
 */
class OP_SUBSTR extends opcode_1.StaticCode {
    constructor() {
        super(0x7f, 'OP_SUBSTR');
    }
}
exports.OP_SUBSTR = OP_SUBSTR;
/**
 * Keeps only characters left of the specified point in a string. disabled.
 */
class OP_LEFT extends opcode_1.StaticCode {
    constructor() {
        super(0x80, 'OP_LEFT');
    }
}
exports.OP_LEFT = OP_LEFT;
/**
 * Keeps only characters right of the specified point in a string. disabled.
 */
class OP_RIGHT extends opcode_1.StaticCode {
    constructor() {
        super(0x81, 'OP_RIGHT');
    }
}
exports.OP_RIGHT = OP_RIGHT;
/**
 * Pushes the string length of the top element of the stack (without popping it).
 */
class OP_SIZE extends opcode_1.StaticCode {
    constructor() {
        super(0x82, 'OP_SIZE');
    }
}
exports.OP_SIZE = OP_SIZE;

},{"./opcode":120}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OP_TUCK = exports.OP_SWAP = exports.OP_ROT = exports.OP_ROLL = exports.OP_PICK = exports.OP_OVER = exports.OP_NIP = exports.OP_DUP = exports.OP_DROP = exports.OP_DEPTH = exports.OP_IFDUP = exports.OP_2SWAP = exports.OP_2ROT = exports.OP_2OVER = exports.OP_3DUP = exports.OP_2DUP = exports.OP_2DROP = exports.OP_FROMALTSTACK = exports.OP_TOALTSTACK = void 0;
const opcode_1 = require("./opcode");
/**
 * Puts the input onto the top of the alt stack. Removes it from the main stack.
 */
class OP_TOALTSTACK extends opcode_1.StaticCode {
    constructor() {
        super(0x6b, 'OP_TOALTSTACK');
    }
}
exports.OP_TOALTSTACK = OP_TOALTSTACK;
/**
 * Puts the input onto the top of the main stack. Removes it from the alt stack.
 */
class OP_FROMALTSTACK extends opcode_1.StaticCode {
    constructor() {
        super(0x6c, 'OP_FROMALTSTACK');
    }
}
exports.OP_FROMALTSTACK = OP_FROMALTSTACK;
/**
 * Removes the top two stack items.
 */
class OP_2DROP extends opcode_1.StaticCode {
    constructor() {
        super(0x6d, 'OP_2DROP');
    }
}
exports.OP_2DROP = OP_2DROP;
/**
 * Duplicates the top two stack items.
 */
class OP_2DUP extends opcode_1.StaticCode {
    constructor() {
        super(0x6e, 'OP_2DUP');
    }
}
exports.OP_2DUP = OP_2DUP;
/**
 * Duplicates the top three stack items.
 */
class OP_3DUP extends opcode_1.StaticCode {
    constructor() {
        super(0x6f, 'OP_3DUP');
    }
}
exports.OP_3DUP = OP_3DUP;
/**
 * Copies the pair of items two spaces back in the stack to the front.
 */
class OP_2OVER extends opcode_1.StaticCode {
    constructor() {
        super(0x70, 'OP_2OVER');
    }
}
exports.OP_2OVER = OP_2OVER;
/**
 * The fifth and sixth items back are moved to the top of the stack.
 */
class OP_2ROT extends opcode_1.StaticCode {
    constructor() {
        super(0x71, 'OP_2ROT');
    }
}
exports.OP_2ROT = OP_2ROT;
/**
 * Swaps the top two pairs of items.
 */
class OP_2SWAP extends opcode_1.StaticCode {
    constructor() {
        super(0x72, 'OP_2SWAP');
    }
}
exports.OP_2SWAP = OP_2SWAP;
/**
 * If the top stack value is not 0, duplicate it.
 */
class OP_IFDUP extends opcode_1.StaticCode {
    constructor() {
        super(0x73, 'OP_IFDUP');
    }
}
exports.OP_IFDUP = OP_IFDUP;
/**
 * Puts the number of stack items onto the stack.
 */
class OP_DEPTH extends opcode_1.StaticCode {
    constructor() {
        super(0x74, 'OP_DEPTH');
    }
}
exports.OP_DEPTH = OP_DEPTH;
/**
 * Removes the top stack item.
 */
class OP_DROP extends opcode_1.StaticCode {
    constructor() {
        super(0x75, 'OP_DROP');
    }
}
exports.OP_DROP = OP_DROP;
/**
 * Duplicates the top stack item.
 */
class OP_DUP extends opcode_1.StaticCode {
    constructor() {
        super(0x76, 'OP_DUP');
    }
}
exports.OP_DUP = OP_DUP;
/**
 * Removes the second-to-top stack item.
 */
class OP_NIP extends opcode_1.StaticCode {
    constructor() {
        super(0x77, 'OP_NIP');
    }
}
exports.OP_NIP = OP_NIP;
/**
 * Copies the second-to-top stack item to the top.
 */
class OP_OVER extends opcode_1.StaticCode {
    constructor() {
        super(0x78, 'OP_OVER');
    }
}
exports.OP_OVER = OP_OVER;
/**
 * The item n back in the stack is copied to the top.
 */
class OP_PICK extends opcode_1.StaticCode {
    constructor() {
        super(0x79, 'OP_PICK');
    }
}
exports.OP_PICK = OP_PICK;
/**
 * The item n back in the stack is moved to the top.
 */
class OP_ROLL extends opcode_1.StaticCode {
    constructor() {
        super(0x7a, 'OP_ROLL');
    }
}
exports.OP_ROLL = OP_ROLL;
/**
 * The 3rd item down the stack is moved to the top.
 */
class OP_ROT extends opcode_1.StaticCode {
    constructor() {
        super(0x7b, 'OP_ROT');
    }
}
exports.OP_ROT = OP_ROT;
/**
 * The top two items on the stack are swapped.
 */
class OP_SWAP extends opcode_1.StaticCode {
    constructor() {
        super(0x7c, 'OP_SWAP');
    }
}
exports.OP_SWAP = OP_SWAP;
/**
 * The item at the top of the stack is copied and inserted before the second-to-top item.
 */
class OP_TUCK extends opcode_1.StaticCode {
    constructor() {
        super(0x7d, 'OP_TUCK');
    }
}
exports.OP_TUCK = OP_TUCK;

},{"./opcode":120}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SIGHASH = void 0;
var SIGHASH;
(function (SIGHASH) {
    SIGHASH[SIGHASH["ALL"] = 1] = "ALL";
    SIGHASH[SIGHASH["NONE"] = 2] = "NONE";
    SIGHASH[SIGHASH["SINGLE"] = 3] = "SINGLE";
    SIGHASH[SIGHASH["ANYONECANPAY"] = 128] = "ANYONECANPAY";
    SIGHASH[SIGHASH["ALL_ANYONECANPAY"] = 129] = "ALL_ANYONECANPAY";
    SIGHASH[SIGHASH["NONE_ANYONECANPAY"] = 130] = "NONE_ANYONECANPAY";
    SIGHASH[SIGHASH["SINGLE_ANYONECANPAY"] = 131] = "SINGLE_ANYONECANPAY";
})(SIGHASH = exports.SIGHASH || (exports.SIGHASH = {}));

},{}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CWitnessScript = exports.CWitness = exports.CTransactionSegWit = exports.CScript = exports.CVoutV4 = exports.CVoutV2 = exports.CVin = exports.CTransaction = void 0;
const smart_buffer_1 = require("smart-buffer");
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const script_1 = require("./script");
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
/**
 * USE CTransaction AT YOUR OWN RISK.
 * The TransactionBuilder has safety logic built-in to prevent overspent, CTransaction is its raw counter part.
 *
 * Composable Transaction, C stands for Composable.
 * Immutable by design, it implements the Transaction interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 */
class CTransaction extends jellyfish_buffer_1.ComposableBuffer {
    get version() {
        return this.data.version;
    }
    get vin() {
        return this.data.vin;
    }
    get vout() {
        return this.data.vout;
    }
    get lockTime() {
        return this.data.lockTime;
    }
    composers(tx) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => tx.version, v => tx.version = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => tx.vin, v => tx.vin = v, v => new CVin(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => tx.vout, v => tx.vout = v, v => {
                if (tx.version < 4) {
                    return new CVoutV2(v);
                }
                return new CVoutV4(v);
            }),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => tx.lockTime, v => tx.lockTime = v)
        ];
    }
    /**
     * TransactionId is the double SHA256 of transaction buffer.
     * TxId are usually presented in BE order, this method return TxId in BE order.
     *
     * @return string transaction id
     */
    get txId() {
        const buffer = new smart_buffer_1.SmartBuffer();
        this.toBuffer(buffer);
        const hash = jellyfish_crypto_1.dSHA256(buffer.toBuffer());
        return hash.reverse().toString('hex');
    }
}
exports.CTransaction = CTransaction;
/**
 * Composable Vin, C stands for Composable.
 * Immutable by design, it implements the Vin interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 */
class CVin extends jellyfish_buffer_1.ComposableBuffer {
    /**
     * 32 bytes, 64 in hex
     */
    get txid() {
        return this.data.txid;
    }
    get index() {
        return this.data.index;
    }
    get script() {
        return this.data.script;
    }
    get sequence() {
        return this.data.sequence;
    }
    composers(vin) {
        return [
            // defid returns txid in BE order hence we need to reverse it
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => vin.txid, v => vin.txid = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => vin.index, v => vin.index = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => vin.script, v => vin.script = v, v => new CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => vin.sequence, v => vin.sequence = v)
        ];
    }
}
exports.CVin = CVin;
/**
 * Composable Vout, C stands for Composable.
 * Immutable by design, it implements the Vout interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 *
 * This is Transaction V2 buffer composition
 */
class CVoutV2 extends jellyfish_buffer_1.ComposableBuffer {
    get value() {
        return this.data.value;
    }
    get script() {
        return this.data.script;
    }
    get tokenId() {
        return 0x00;
    }
    composers(vout) {
        return [
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => vout.value, v => vout.value = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => vout.script, v => vout.script = v, v => new CScript(v))
        ];
    }
}
exports.CVoutV2 = CVoutV2;
/**
 * Composable Vout, C stands for Composable.
 * Immutable by design, it implements the Vout interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 *
 * This is Transaction V4 buffer composition
 */
class CVoutV4 extends jellyfish_buffer_1.ComposableBuffer {
    get value() {
        return this.data.value;
    }
    get script() {
        return this.data.script;
    }
    get tokenId() {
        return this.data.tokenId;
    }
    composers(vout) {
        return [
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => vout.value, v => vout.value = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => vout.script, v => vout.script = v, v => new CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.varUInt(() => vout.tokenId, v => vout.tokenId = v)
        ];
    }
}
exports.CVoutV4 = CVoutV4;
/**
 * Composable Script, C stands for Composable.
 * Immutable by design, it implements the Script interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 *
 * This wraps the OPCode built in composer.
 */
class CScript extends jellyfish_buffer_1.ComposableBuffer {
    get stack() {
        return this.data.stack;
    }
    composers(script) {
        return [
            {
                fromBuffer: (buffer) => {
                    script.stack = script_1.OP_CODES.fromBuffer(buffer);
                },
                toBuffer: (buffer) => {
                    script_1.OP_CODES.toBuffer(script.stack, buffer);
                }
            }
        ];
    }
}
exports.CScript = CScript;
/**
 * USE CTransactionSegWit AT YOUR OWN RISK.
 * The TransactionBuilder has safety logic built-in to prevent overspent, CTransactionSegWit is its raw counter part.
 *
 * Composable TransactionSegWit, C stands for Composable.
 * Immutable by design, it implements the TransactionSegWit interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 *
 * @see https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki
 * @see https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki
 * @see https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki
 */
class CTransactionSegWit extends jellyfish_buffer_1.ComposableBuffer {
    get version() {
        return this.data.version;
    }
    get marker() {
        return this.data.marker;
    }
    get flag() {
        return this.data.flag;
    }
    get vin() {
        return this.data.vin;
    }
    get vout() {
        return this.data.vout;
    }
    get witness() {
        return this.data.witness;
    }
    get lockTime() {
        return this.data.lockTime;
    }
    composers(tx) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => tx.version, v => tx.version = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => tx.marker, v => tx.marker = v),
            jellyfish_buffer_1.ComposableBuffer.uInt8(() => tx.flag, v => tx.flag = v),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => tx.vin, v => tx.vin = v, v => new CVin(v)),
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => tx.vout, v => tx.vout = v, v => {
                if (tx.version < 4) {
                    return new CVoutV2(v);
                }
                return new CVoutV4(v);
            }),
            jellyfish_buffer_1.ComposableBuffer.array(() => tx.witness, v => tx.witness = v, v => new CWitness(v), () => tx.vin.length),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => tx.lockTime, v => tx.lockTime = v)
        ];
    }
    /**
     * TransactionId is the double SHA256 of transaction buffer.
     * TxId are usually presented in BE order, this method return TxId in BE order.
     *
     * @return string transaction id
     */
    get txId() {
        return new CTransaction(this).txId;
    }
}
exports.CTransactionSegWit = CTransactionSegWit;
/**
 * Composable Witness, C stands for Composable.
 * Immutable by design, it implements the Witness interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 */
class CWitness extends jellyfish_buffer_1.ComposableBuffer {
    get scripts() {
        return this.data.scripts;
    }
    composers(wit) {
        return [
            jellyfish_buffer_1.ComposableBuffer.varUIntArray(() => wit.scripts, v => wit.scripts = v, v => new CWitnessScript(v))
        ];
    }
}
exports.CWitness = CWitness;
/**
 * Composable WitnessScript, C stands for Composable.
 * Immutable by design, it implements the WitnessScript interface for convenience.
 * Bi-directional fromBuffer, toBuffer deep composer.
 *
 * This just wraps the WitnessScript with (n = VarUInt, + n Bytes).
 */
class CWitnessScript extends jellyfish_buffer_1.ComposableBuffer {
    get hex() {
        return this.data.hex;
    }
    composers(script) {
        return [
            {
                fromBuffer: (buffer) => {
                    const len = jellyfish_buffer_1.readVarUInt(buffer);
                    script.hex = buffer.readString(len, 'hex');
                },
                toBuffer: (buffer) => {
                    jellyfish_buffer_1.writeVarUInt(script.hex.length / 2, buffer);
                    buffer.writeString(script.hex, 'hex');
                }
            }
        ];
    }
}
exports.CWitnessScript = CWitnessScript;

},{"./script":117,"@defichain/jellyfish-buffer":63,"@defichain/jellyfish-crypto":71,"smart-buffer":273}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CWitnessProgram = void 0;
const smart_buffer_1 = require("smart-buffer");
const jellyfish_buffer_1 = require("@defichain/jellyfish-buffer");
const tx_composer_1 = require("./tx_composer");
/**
 * Composable WitnessProgram
 */
class CWitnessProgram extends jellyfish_buffer_1.ComposableBuffer {
    composers(wp) {
        return [
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => wp.version, v => wp.version = v),
            jellyfish_buffer_1.ComposableBuffer.hex(32, () => wp.hashPrevouts, v => wp.hashPrevouts = v),
            jellyfish_buffer_1.ComposableBuffer.hex(32, () => wp.hashSequence, v => wp.hashSequence = v),
            jellyfish_buffer_1.ComposableBuffer.hexBEBufferLE(32, () => wp.outpointTxId, v => wp.outpointTxId = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => wp.outpointIndex, v => wp.outpointIndex = v),
            jellyfish_buffer_1.ComposableBuffer.single(() => wp.scriptCode, v => wp.scriptCode = v, v => new tx_composer_1.CScript(v)),
            jellyfish_buffer_1.ComposableBuffer.satoshiAsBigNumber(() => wp.value, v => wp.value = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => wp.sequence, v => wp.sequence = v),
            jellyfish_buffer_1.ComposableBuffer.hex(32, () => wp.hashOutputs, v => wp.hashOutputs = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => wp.lockTime, v => wp.lockTime = v),
            jellyfish_buffer_1.ComposableBuffer.uInt32(() => wp.hashType, v => wp.hashType = v)
        ];
    }
    asBuffer() {
        const buffer = new smart_buffer_1.SmartBuffer();
        this.toBuffer(buffer);
        return buffer.toBuffer();
    }
}
exports.CWitnessProgram = CWitnessProgram;

},{"./tx_composer":124,"@defichain/jellyfish-buffer":63,"smart-buffer":273}],126:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKeyEncryption = exports.EncryptedData = void 0;
const randombytes_1 = __importDefault(require("randombytes"));
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const scrypt_1 = require("./scrypt");
class EncryptedData {
    /**
     * Total = 7 + 2n bytes
     *
     * @param {number} prefix - 0x01
     * @param {number} type - 0x42 or 0x43 (only 0x42 for now)
     * @param {number} flags - 1 byte (only true for 2 most significant bit for now)
     * @param {Buffer} hash - 4 bytes, checksum and salt
     * @param {Buffer} encryptedFirstHalf - n bytes
     * @param {Buffer} encryptedSecondHalf - n bytes
     */
    constructor(prefix, type, flags, hash, encryptedFirstHalf, encryptedSecondHalf) {
        this.prefix = prefix;
        this.type = type;
        this.flags = flags;
        this.hash = hash;
        this.encryptedFirstHalf = encryptedFirstHalf;
        this.encryptedSecondHalf = encryptedSecondHalf;
        if (encryptedFirstHalf.length !== encryptedSecondHalf.length) {
            throw new Error('Unexpected data size, first and second half should have same length');
        }
    }
    encode() {
        const first3Bytes = Buffer.from([this.prefix, this.type, this.flags]).toString('hex');
        return first3Bytes +
            this.hash.toString('hex') +
            this.encryptedFirstHalf.toString('hex') +
            this.encryptedSecondHalf.toString('hex');
    }
    static decode(encoded) {
        if (encoded.length < 18) { // min length is 9 bytes
            throw new Error('Invalid encrypted data');
        }
        const dataLen = encoded.length - 14;
        if (dataLen % 2 !== 0) {
            throw new Error('Invalid encrypted data');
        }
        const firstHalfEndIndex = 14 + (dataLen / 2);
        return new EncryptedData(Number(encoded.slice(0, 2)), Number(encoded.slice(2, 4)), Number(encoded.slice(4, 6)), Buffer.from(encoded.slice(6, 14), 'hex'), Buffer.from(encoded.slice(14, firstHalfEndIndex), 'hex'), Buffer.from(encoded.slice(firstHalfEndIndex), 'hex'));
    }
}
exports.EncryptedData = EncryptedData;
class PrivateKeyEncryption {
    /**
     * @param {Scrypt} scrypt to convert a utf8 string into a secret, cryptographically secured
     * @param {(number) => Buffer} [rng = randomBytes] cryptographically strong random values generator required for IV
     */
    constructor(scrypt = new scrypt_1.Scrypt(), rng = randombytes_1.default) {
        this.scrypt = scrypt;
        this.rng = rng;
    }
    /**
     * To encrypt `data` with a `passphrase` derived secret (derivation based on provided `ScryptProvider`)
     * @see https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki#Encryption_when_EC_multiply_flag_is_not_used for encryption methodology
     *
     * @param {Buffer} data data with even number length
     * @param {string} passphrase to derived encryption secret, utf8 string in normalization format C
     */
    encrypt(data, passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data.length % 2 !== 0) {
                throw new Error('Data length must be even number');
            }
            const hash = jellyfish_crypto_1.dSHA256(data).slice(0, 4);
            const key = yield this.scrypt.derive(passphrase, hash, 64);
            const k1a = Buffer.from(key.toString('hex').slice(0, 32), 'hex'); // 16 bytes
            const k1b = Buffer.from(key.toString('hex').slice(32, 64), 'hex'); // 16 bytes
            const k2 = Buffer.from(key.toString('hex').slice(64), 'hex'); // 32 bytes
            const d1 = Buffer.from(data.toString('hex').slice(0, data.length), 'hex');
            const d2 = Buffer.from(data.toString('hex').slice(data.length), 'hex');
            const xor1 = _xor(k1a, d1);
            const xor2 = _xor(k1b, d2);
            const b1 = jellyfish_crypto_1.AES256.encrypt(k2, xor1, this.rng);
            const b2 = jellyfish_crypto_1.AES256.encrypt(k2, xor2, this.rng);
            return new EncryptedData(0x01, 0x42, 0xc0, hash, b1, b2);
        });
    }
    /**
     * To decrypt raw data
     *
     * @param {string} encrypted to decrypt
     * @param {string} passphrase to decrypted data, utf8 string in normalization format C
     * @returns {Promise<Buffer>} null if no data found in storage
     * @throws Error InvalidPassphrase if passphrase is invalid (decrypted value has no matching hash)
     */
    decrypt(encrypted, passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = EncryptedData.decode(encrypted);
            const key = yield this.scrypt.derive(passphrase, data.hash, 64);
            const k1a = Buffer.from(key.toString('hex').slice(0, 32), 'hex'); // 16 bytes
            const k1b = Buffer.from(key.toString('hex').slice(32, 64), 'hex'); // 16 bytes
            const k2 = Buffer.from(key.toString('hex').slice(64), 'hex'); // 32 bytes
            const dec1 = jellyfish_crypto_1.AES256.decrypt(k2, data.encryptedFirstHalf); // 16 bytes = decipher(32 bytes) - salt
            const dec2 = jellyfish_crypto_1.AES256.decrypt(k2, data.encryptedSecondHalf);
            const d1 = _xor(k1a, dec1);
            const d2 = _xor(k1b, dec2);
            const decrypted = Buffer.from([...d1, ...d2]);
            const dataHash = jellyfish_crypto_1.dSHA256(decrypted).slice(0, 4);
            if (dataHash.toString('hex') !== data.hash.toString('hex')) {
                throw new Error('invalid hash');
            }
            return decrypted;
        });
    }
}
exports.PrivateKeyEncryption = PrivateKeyEncryption;
function _xor(key, data) {
    const output = Buffer.alloc(data.length);
    for (let i = 0, j = 0; i < data.length && i < data.length; i++) {
        output[i] = data[i] ^ key[j];
        if (j + 1 === data.length) {
            j = 0;
        }
        else {
            j++;
        }
    }
    return output;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./scrypt":129,"@defichain/jellyfish-crypto":71,"buffer":3,"randombytes":246}],127:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedHdNodeProvider = exports.EncryptedMnemonicHdNode = void 0;
const bip32 = __importStar(require("bip32"));
const jellyfish_wallet_mnemonic_1 = require("@defichain/jellyfish-wallet-mnemonic");
/**
 * EncryptedMnemonicHdNode extends MnemonicHdNode to implement promise-based privKey resolution.
 * This allows latent based implementation where privKey need to be decrypted.
 *
 * Prior Art:
 * - BIP32 Hierarchical Deterministic Wallets
 * - BIP39 Mnemonic code for generating deterministic keys
 * - BIP44 Multi-Account Hierarchy for Deterministic Wallets
 */
class EncryptedMnemonicHdNode extends jellyfish_wallet_mnemonic_1.MnemonicHdNode {
    constructor(path, chainCode, options, rootPubKey, promisePrivKey) {
        super(path, Buffer.alloc(0), chainCode, options);
        this.rootPubKey = rootPubKey;
        this.promisePrivKey = promisePrivKey;
    }
    /**
     * Latent based implementation where privKey need to be resolved via a promise.
     */
    deriveNode() {
        return __awaiter(this, void 0, void 0, function* () {
            const rootPrivKey = yield this.promisePrivKey();
            return bip32.fromPrivateKey(rootPrivKey, this.chainCode, this.options)
                .derivePath(this.path);
        });
    }
    /**
     * @return Promise<Buffer> compressed public key
     */
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return bip32.fromPublicKey(this.rootPubKey, this.chainCode, this.options)
                .derivePath(this.path)
                .publicKey;
        });
    }
}
exports.EncryptedMnemonicHdNode = EncryptedMnemonicHdNode;
/**
 * EncryptedHdNodeProvider implements MnemonicHdNode implementation privateKey on-demand decryption via scrypt.
 *
 */
class EncryptedHdNodeProvider {
    constructor(data, options, scrypt, promptPassphrase) {
        this.data = data;
        this.options = options;
        this.scrypt = scrypt;
        this.promptPassphrase = promptPassphrase;
    }
    /**
     * @param {string} path to derive with on-demand node
     * @return EncryptedMnemonicHdNode with promisePrivKey that will only be resolved and decrypted when privateKey is accessed
     */
    derive(path) {
        const encrypted = this.data.encryptedPrivKey;
        const rootPubKey = Buffer.from(this.data.pubKey, 'hex');
        const chainCode = Buffer.from(this.data.chainCode, 'hex');
        const promisePrivKey = () => __awaiter(this, void 0, void 0, function* () {
            const passphrase = yield this.promptPassphrase();
            return yield this.scrypt.decrypt(encrypted, passphrase);
        });
        return new EncryptedMnemonicHdNode(path, chainCode, this.options, rootPubKey, promisePrivKey);
    }
    /**
     * @param {string[]} words to convert into EncryptedProviderData
     * @param {Bip32Options} options
     * @param {string} scrypt to encrypt mnemonic words
     * @param {string} passphrase to encrypt mnemonic words with
     * @return EncryptedProviderData with unencrypted "pubKey & chainCode" and scrypt encoded 'encryptedPrivKey'
     */
    static wordsToEncryptedData(words, options, scrypt, passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            const mnemonic = jellyfish_wallet_mnemonic_1.MnemonicHdNodeProvider.wordsToData(words, options);
            const privKey = Buffer.from(mnemonic.privKey, 'hex');
            const chainCode = Buffer.from(mnemonic.chainCode, 'hex');
            const root = bip32.fromPrivateKey(privKey, chainCode, options);
            const encrypted = yield scrypt.encrypt(privKey, passphrase);
            return {
                pubKey: root.publicKey.toString('hex'),
                chainCode: mnemonic.chainCode,
                encryptedPrivKey: encrypted.encode()
            };
        });
    }
    /**
     * @param {EncryptedProviderData} data with unencrypted "pubKey & chainCode" and scrypt encoded 'encryptedPrivKey'
     * @param {Bip32Options} options
     * @param {string} scrypt to decrypt encrypted private key
     * @param {PromptPassphrase} promptPassphrase for on-demand request passphrase to decrypt encrypted private key
     * @return EncryptedHdNodeProvider
     */
    static init(data, options, scrypt, promptPassphrase) {
        return new EncryptedHdNodeProvider(data, options, scrypt, promptPassphrase);
    }
}
exports.EncryptedHdNodeProvider = EncryptedHdNodeProvider;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@defichain/jellyfish-wallet-mnemonic":131,"bip32":170,"buffer":3}],128:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./encryption"), exports);
__exportStar(require("./hd_node"), exports);
__exportStar(require("./scrypt"), exports);

},{"./encryption":126,"./hd_node":127,"./scrypt":129}],129:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scrypt = void 0;
const scrypt_js_1 = __importDefault(require("scrypt-js"));
/**
 * The scrypt password-base key derivation function (pbkdf) is an algorithm designed to be brute-force resistant that
 * converts human readable passwords into fixed length arrays of bytes, which can then be used as a key for symmetric
 * block ciphers, private keys, et cetera.
 *
 * This implementation is an adapter for https://github.com/ricmoo/scrypt-js implementation.
 */
class Scrypt {
    /**
     * @param {number} N the CPU/memory cost; increasing this increases the overall difficulty
     * @param {number} r the block size; increasing this increases the dependency on memory latency and bandwidth
     * @param {number} p the parallelization cost; increasing this increases the dependency on multi-processing
     */
    constructor(N = 16384, r = 8, p = 1) {
        this.N = N;
        this.r = r;
        this.p = p;
    }
    /**
     * Derive a specific length buffer via Scrypt implementation
     * Recommended (by bip38) to serve as an private key encryption key
     *
     * @param {string} passphrase utf8 string
     * @param {Buffer} salt
     * @param {number} keyLength desired output buffer length
     * @returns {Buffer}
     */
    derive(passphrase, salt, keyLength) {
        return __awaiter(this, void 0, void 0, function* () {
            const secret = Buffer.from(passphrase.normalize('NFKC'), 'utf8');
            const array = yield scrypt_js_1.default.scrypt(secret, salt, this.N, this.r, this.p, keyLength);
            return Buffer.from(array);
        });
    }
}
exports.Scrypt = Scrypt;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3,"scrypt-js":264}],130:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MnemonicHdNodeProvider = exports.MnemonicHdNode = void 0;
const create_hmac_1 = __importDefault(require("create-hmac"));
const bip32 = __importStar(require("bip32"));
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_transaction_signature_1 = require("@defichain/jellyfish-transaction-signature");
const mnemonic_1 = require("./mnemonic");
/**
 * MnemonicHdNode implements the WalletHdNode from jellyfish-wallet.
 * MnemonicHdNode implementations is purpose and derivation agnostic.
 *
 * Prior-art:
 * - BIP32 Hierarchical Deterministic Wallets
 * - BIP39 Mnemonic code for generating deterministic keys
 * - BIP44 Multi-Account Hierarchy for Deterministic Wallets
 */
class MnemonicHdNode {
    constructor(path, rootPrivKey, chainCode, options) {
        this.path = path;
        this.rootPrivKey = rootPrivKey;
        this.chainCode = chainCode;
        this.options = options;
    }
    deriveNode() {
        return __awaiter(this, void 0, void 0, function* () {
            return bip32.fromPrivateKey(this.rootPrivKey, this.chainCode, this.options)
                .derivePath(this.path);
        });
    }
    /**
     * @return Promise<Buffer> compressed public key
     */
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const node = yield this.deriveNode();
            return node.publicKey;
        });
    }
    /**
     * @return Promise<Buffer> privateKey of the WalletHdNode
     */
    privateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const node = yield this.deriveNode();
            return node.privateKey;
        });
    }
    /**
     * Sign a transaction with all prevout belong to this HdNode with SIGHASH.ALL
     * This implementation can only sign a P2WPKH, hence the implementing WalletAccount should only
     * recognize P2WPKH addresses encoded in bech32 format.
     *
     * @param {Transaction} transaction to sign
     * @param {Vout[]} prevouts of transaction to sign, ellipticPair will be mapped to current node
     * @return TransactionSegWit signed transaction ready to broadcast
     */
    signTx(transaction, prevouts) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield jellyfish_transaction_signature_1.TransactionSigner.signPrevoutsWithEllipticPairs(transaction, prevouts, prevouts.map(() => this), {
                sigHashType: jellyfish_transaction_1.SIGHASH.ALL
            });
        });
    }
    /**
     * @param {Buffer} hash to sign
     * @return {Buffer} signature in DER format, SIGHASHTYPE not included
     */
    sign(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = yield this.deriveNode();
            const signature = node.sign(hash, true);
            return jellyfish_crypto_1.DERSignature.encode(signature);
        });
    }
    /**
     * @param {Buffer} hash to verify with signature
     * @param {Buffer} derSignature of the hash in encoded with DER, SIGHASHTYPE must not be included
     * @return Promise<boolean> validity of signature of the hash
     */
    verify(hash, derSignature) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = yield this.deriveNode();
            const signature = jellyfish_crypto_1.DERSignature.decode(derSignature);
            return node.verify(hash, signature);
        });
    }
}
exports.MnemonicHdNode = MnemonicHdNode;
/**
 * Provider that derive MnemonicHdNode from root. Uses a lite on demand derivation.
 */
class MnemonicHdNodeProvider {
    constructor(data, options) {
        this.data = data;
        this.options = options;
    }
    derive(path) {
        const rootPrivKey = Buffer.from(this.data.privKey, 'hex');
        const chainCode = Buffer.from(this.data.chainCode, 'hex');
        return new MnemonicHdNode(path, rootPrivKey, chainCode, this.options);
    }
    /**
     * @param {MnemonicProviderData} data to init MnemonicHdNodeProvider
     * @param {Bip32Options} options
     */
    static fromData(data, options) {
        return new MnemonicHdNodeProvider(data, options);
    }
    /**
     * @param {string[]} words to init MnemonicHdNodeProvider
     * @param {Bip32Options} options
     */
    static fromWords(words, options) {
        const data = this.wordsToData(words, options);
        return this.fromData(data, options);
    }
    /**
     * @param {string[]} words to convert into MnemonicProviderData
     * @param {Bip32Options} options
     * @return MnemonicProviderData
     */
    static wordsToData(words, options) {
        const node = fromWordsToSeed(words, options);
        const privKey = node.privateKey.toString('hex');
        const chainCode = node.chainCode.toString('hex');
        return { words, chainCode, privKey };
    }
    /**
     * Generate a random mnemonic code of length, uses crypto.randomBytes under the hood.
     *
     * @param {number} length the sentence length of the mnemonic code
     * @param {(number) => Buffer} rng random number generation, generate random num of bytes buffer
     * @return {string[]} generated mnemonic word list, (COLD STORAGE)
     */
    static generateWords(length = 24, rng) {
        return mnemonic_1.generateMnemonicWords(length, rng);
    }
}
exports.MnemonicHdNodeProvider = MnemonicHdNodeProvider;
/**
 * Derive from mnemonic words using our own seed called '@defichain/jellyfish-wallet-mnemonic'.
 *
 * @param {string[]} words to convert into Bip32Interface
 * @param {Bip32Options} options
 */
function fromWordsToSeed(words, options) {
    const seed = mnemonic_1.mnemonicToSeed(words);
    if (seed.length < 16) {
        throw new TypeError('Seed should be at least 128 bits');
    }
    if (seed.length > 64) {
        throw new TypeError('Seed should be at most 512 bits');
    }
    const key = Buffer.from('@defichain/jellyfish-wallet-mnemonic', 'utf8');
    const I = create_hmac_1.default('sha512', key).update(seed).digest();
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return bip32.fromPrivateKey(IL, IR, options);
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./mnemonic":132,"@defichain/jellyfish-crypto":71,"@defichain/jellyfish-transaction":94,"@defichain/jellyfish-transaction-signature":92,"bip32":170,"buffer":3,"create-hmac":201}],131:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./hd_node"), exports);
__exportStar(require("./mnemonic"), exports);

},{"./hd_node":130,"./mnemonic":132}],132:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.entropyAsMnemonic = exports.mnemonicAsEntropy = exports.mnemonicToSeed = exports.generateMnemonicWords = exports.validateMnemonicWord = exports.validateMnemonicSentence = void 0;
const randombytes_1 = __importDefault(require("randombytes"));
const bip39 = __importStar(require("bip39"));
/**
 * @param {string} mnemonic sentence to validate
 * @return {boolean} validity
 */
function validateMnemonicSentence(mnemonic) {
    if (Array.isArray(mnemonic)) {
        return bip39.validateMnemonic(mnemonic.join(' '));
    }
    return bip39.validateMnemonic(mnemonic);
}
exports.validateMnemonicSentence = validateMnemonicSentence;
/**
 * @param {string} word to check if exist in mnemonic english word list
 * @return {boolean} validity
 */
function validateMnemonicWord(word) {
    return bip39.wordlists.english.includes(word);
}
exports.validateMnemonicWord = validateMnemonicWord;
/**
 * Generate a random mnemonic code of length, uses crypto.randomBytes under the hood.
 * Defaults to 256-bits of entropy.
 * https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
 *
 * |  ENT  | CS | ENT+CS |  MS  |
 * +-------+----+--------+------+
 * |  128  |  4 |   132  |  12  |
 * |  160  |  5 |   165  |  15  |
 * |  192  |  6 |   198  |  18  |
 * |  224  |  7 |   231  |  21  |
 * |  256  |  8 |   264  |  24  |
 *
 * @param {number} length the sentence length of the mnemonic code
 * @param {(number) => Buffer} [rng = randomBytes] cryptographically strong random values generator required
 * @return {string[]} generated mnemonic word list, (COLD STORAGE)
 */
function generateMnemonicWords(length = 24, rng = randombytes_1.default) {
    const entropy = length / 3 * 32;
    const sentence = bip39.generateMnemonic(entropy, rng);
    return sentence.split(' ');
}
exports.generateMnemonicWords = generateMnemonicWords;
/**
 * @param {string[]} mnemonic words, (COLD)
 * @return {Buffer} HD seed, (HOT) but ideally should not be kept at rest
 */
function mnemonicToSeed(mnemonic) {
    return bip39.mnemonicToSeedSync(mnemonic.join(' '));
}
exports.mnemonicToSeed = mnemonicToSeed;
/**
 * @param {string[]} mnemonic words, (COLD)
 * @return {Buffer} 32 byte
 */
function mnemonicAsEntropy(mnemonic) {
    const hex = bip39.mnemonicToEntropy(mnemonic.join(' '));
    return Buffer.from(hex, 'hex');
}
exports.mnemonicAsEntropy = mnemonicAsEntropy;
/**
 * @param {Buffer} entropy 32 bytes buffer
 * @return {string[]} mnemonic words, (COLD)
 */
function entropyAsMnemonic(entropy) {
    if (entropy.length !== 32) {
        throw new Error('expected entropy to be 32 byte long');
    }
    const sentence = bip39.entropyToMnemonic(entropy);
    return sentence.split(' ');
}
exports.entropyAsMnemonic = entropyAsMnemonic;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bip39":172,"buffer":3,"randombytes":246}],133:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./wallet"), exports);
__exportStar(require("./wallet_account"), exports);
__exportStar(require("./wallet_hd_node"), exports);
__exportStar(require("./wallet_elliptic_pair"), exports);

},{"./wallet":134,"./wallet_account":135,"./wallet_elliptic_pair":136,"./wallet_hd_node":137}],134:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JellyfishWallet = void 0;
/**
 * Jellyfish managed wallet.
 * WalletHdNode instance is provided by WalletHdNodeProvider.
 * WalletAccount instance for interfacing layer/upstream to service will be provided by WalletAccountProvider.
 *
 * JellyfishWallet doesn't follow BIP-44.
 */
class JellyfishWallet {
    /**
     * @param {WalletHdNodeProvider} nodeProvider
     * @param {WalletAccountProvider} accountProvider
     * @param {number} [coinType=1129] COIN_TYPE_DFI
     * @param {number} [purpose=0] PURPOSE_LIGHT_WALLET
     */
    constructor(nodeProvider, accountProvider, coinType = JellyfishWallet.COIN_TYPE_DFI, purpose = JellyfishWallet.PURPOSE_LIGHT_WALLET) {
        this.nodeProvider = nodeProvider;
        this.accountProvider = accountProvider;
        this.coinType = coinType;
        this.purpose = purpose;
    }
    /**
     * @param {number} account number to get
     * @return Promise<WalletAccount>
     */
    get(account) {
        const path = `${this.coinType}/${this.purpose}/0/${account}`;
        const node = this.nodeProvider.derive(path);
        return this.accountProvider.provide(node);
    }
    /**
     * Check if account in the wallet is usable.
     * An usable account in wallet is a account that has no activity gap.
     * Account 0 (default) is always valid.
     *
     * @example 0 is the default account and usable regardless
     * @example 0,1 is usable when [0] has activity
     * @example 0,1,2 is usable when [0,1] has activity
     * @example 0,1,2,3 is usable when [0,1,2] has activity
     * @example 0,1 is usable when [0,1,3] has activity (3 should never ever has transaction in the first place)
     *
     * @param {number} account number to check if valid
     * @return Promise<boolean> usability of account
     */
    isUsable(account) {
        return __awaiter(this, void 0, void 0, function* () {
            if (account === 0) {
                return true;
            }
            return yield this.get(account - 1).isActive();
        });
    }
    /**
     * Discover accounts that are active in managed JellyfishWallet.
     * Account are considered active if the address contains any transaction activity.
     * Default account, the first account will always get discovered regardless.
     *
     * @param {number} maxAccounts to discover
     * @return WalletAccount[] discovered
     */
    discover(maxAccounts = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallets = [];
            for (let i = 0; i < maxAccounts; i++) {
                const account = yield this.get(i);
                if (!(yield account.isActive())) {
                    break;
                }
                wallets[i] = account;
            }
            return wallets;
        });
    }
}
exports.JellyfishWallet = JellyfishWallet;
JellyfishWallet.COIN_TYPE_BTC = 0;
JellyfishWallet.COIN_TYPE_DFI = 1129;
/**
 * Default purpose, for Light Wallet Implementation
 */
JellyfishWallet.PURPOSE_LIGHT_WALLET = 0;
/**
 * For Masternode creation UTXO locking
 */
JellyfishWallet.PURPOSE_LIGHT_MASTERNODE = 1;
/**
 * For light price oracle implementation
 */
JellyfishWallet.PURPOSE_LIGHT_PRICE_ORACLE = 2;

},{}],135:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletAccount = void 0;
const jellyfish_transaction_1 = require("@defichain/jellyfish-transaction");
const jellyfish_crypto_1 = require("@defichain/jellyfish-crypto");
const jellyfish_address_1 = require("@defichain/jellyfish-address");
/**
 * An HDW is organized as several 'accounts'.
 * Accounts are numbered, the default account ("") being number 0.
 * Account are derived from root and the pubkey to be used is `${account}/0/0`
 *
 * WalletAccount implementation uses NATIVE SEGWIT redeem script exclusively.
 */
class WalletAccount {
    constructor(walletEllipticPair, network) {
        this.walletEllipticPair = walletEllipticPair;
        this.network = network;
    }
    /**
     * @return {Promise<string>} Bech32 address of this account. (NATIVE SEGWIT)
     */
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const pubKey = yield this.walletEllipticPair.publicKey();
            return jellyfish_crypto_1.Bech32.fromPubKey(pubKey, this.network.bech32.hrp, 0x00);
        });
    }
    /**
     * @return {Promise<Script>} redeem script of this account. (NATIVE SEGWIT)
     */
    getScript() {
        return __awaiter(this, void 0, void 0, function* () {
            const pubKey = yield this.walletEllipticPair.publicKey();
            return {
                stack: [
                    jellyfish_transaction_1.OP_CODES.OP_0,
                    jellyfish_transaction_1.OP_CODES.OP_PUSHDATA(jellyfish_crypto_1.HASH160(pubKey), 'little')
                ]
            };
        });
    }
    /**
     * Convert address to script, this validate that you are sending to the same network.
     * It uses jellyfish-address under the hood.
     *
     * @param {string} address to parse into script
     * @return {Script} parsed from address
     */
    addressToScript(address) {
        const parsed = jellyfish_address_1.DeFiAddress.from(this.network.name, address);
        return parsed.getScript();
    }
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.walletEllipticPair.publicKey();
        });
    }
    privateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.walletEllipticPair.privateKey();
        });
    }
    sign(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.walletEllipticPair.sign(hash);
        });
    }
    signTx(transaction, prevouts) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.walletEllipticPair.signTx(transaction, prevouts);
        });
    }
    verify(hash, derSignature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.walletEllipticPair.verify(hash, derSignature);
        });
    }
}
exports.WalletAccount = WalletAccount;

},{"@defichain/jellyfish-address":31,"@defichain/jellyfish-crypto":71,"@defichain/jellyfish-transaction":94}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],138:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = void 0;
/**
 * DeFi whale endpoint for address related services.
 */
class Address {
    constructor(client) {
        this.client = client;
    }
    /**
     * List account history
     *
     * @param {string} address to list account history
     * @param {string} size of account history
     * @param {string} next set of account history
     * @return {Promise<ApiPagedResponse<AddressHistory>>}
     */
    listAccountHistory(address, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `address/${address}/history`, size, next);
        });
    }
    /**
     * Get current balance of an address
     *
     * @param {string} address bech32/legacy/b58 formatted address
     * @return {Promise<string>} balance in string
     */
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `address/${address}/balance`);
        });
    }
    /**
     * Get current aggregated stats of an address
     *
     * @param {string} address bech32/legacy/b58 formatted address
     * @return {Promise<AddressAggregation>}
     */
    getAggregation(address) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO(fuxingloh): typing
            return yield this.client.requestData('GET', `address/${address}/aggregation`);
        });
    }
    /**
     * List all tokens balance belonging to an address.
     *
     * @param {string} address bech32/legacy/b58 formatted address
     * @param {number} size to query
     * @param {number} next token for next slice of AddressToken
     * @return {Promise<ApiPagedResponse<AddressToken>>}
     */
    listToken(address, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `address/${address}/tokens`, size, next);
        });
    }
    /**
     * List all vaults belonging to an address.
     *
     * @param {string} address bech32/legacy/b58 formatted address
     * @param {number} size of vaults to query
     * @param {string} next set of vaults
     * @return {Promise<ApiPagedResponse<LoanVaultActive | LoanVaultLiquidated>>}
     */
    listVault(address, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `address/${address}/vaults`, size, next);
        });
    }
    /**
     * List all transaction activity belonging to an address.
     *
     * @param {string} address bech32/legacy/b58 formatted address
     * @param {number} size to query
     * @param {number} next token for next slice of AddressActivity
     * @return {Promise<ApiPagedResponse<AddressActivity>>}
     */
    listTransaction(address, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `address/${address}/transactions`, size, next);
        });
    }
    /**
     * List all unspent belonging to an address.
     *
     * @param {string} address bech32/legacy/b58 formatted address
     * @param {number} size to query
     * @param {number} next token for next slice of AddressUnspent
     * @return {Promise<ApiPagedResponse<AddressUnspent>>}
     */
    listTransactionUnspent(address, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `address/${address}/transactions/unspent`, size, next);
        });
    }
}
exports.Address = Address;

},{}],139:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blocks = void 0;
class Blocks {
    constructor(client) {
        this.client = client;
    }
    /**
     * @param {number} [size=30] size to query
     * @param {string} [next] next token for next slice of blocks
     * @return {Promise<ApiPagedResponse<Block>>}
     */
    list(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'blocks', size, next);
        });
    }
    /**
     * @param {string} id as hash or height of the block
     * @return {Promise<<Block>}
     */
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `blocks/${id}`);
        });
    }
    /**
     * @param {string} hash of the block
     * @param {number} [size=30] size to query
     * @param {string} [next] next token for next slice of blocks
     * @return {Promise<ApiPagedResponse<Transaction>>}
     */
    getTransactions(hash, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `blocks/${hash}/transactions`, size, next);
        });
    }
}
exports.Blocks = Blocks;

},{}],140:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fee = void 0;
/**
 * DeFi whale endpoint for fee related services.
 */
class Fee {
    constructor(client) {
        this.client = client;
    }
    /**
     * @param {number} confirmationTarget in blocks till fee get confirmed
     * @return {Promise<number>} fee rate per KB
     */
    estimate(confirmationTarget = 10) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `fee/estimate?confirmationTarget=${confirmationTarget}`);
        });
    }
}
exports.Fee = Fee;

},{}],141:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoanVaultState = exports.Loan = void 0;
class Loan {
    constructor(client) {
        this.client = client;
    }
    /**
     * Paginate query loan schemes.
     *
     * @param {number} size of scheme to query
     * @param {string} next set of schemes
     * @return {Promise<ApiPagedResponse<LoanScheme>>}
     */
    listScheme(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'loans/schemes', size, next);
        });
    }
    /**
     * Get information about a scheme with given scheme id.
     *
     * @param {string} id scheme id to get
     * @return {Promise<LoanScheme>}
     */
    getScheme(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `loans/schemes/${id}`);
        });
    }
    /**
     * Paginate query loan collateral tokens.
     *
     * @param {number} size of collateral tokens to query
     * @param {string} next set of collateral tokens
     * @return {Promise<ApiPagedResponse<CollateralToken>>}
     */
    listCollateralToken(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'loans/collaterals', size, next);
        });
    }
    /**
     * Get information about a collateral token with given collateral token id.
     *
     * @param {string} id collateralToken id to get
     * @return {Promise<CollateralToken>}
     */
    getCollateralToken(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `loans/collaterals/${id}`);
        });
    }
    /**
     * Paginate query loan tokens.
     *
     * @param {number} size of loan token to query
     * @param {string} next set of loan tokens
     * @return {Promise<ApiPagedResponse<LoanToken>>}
     */
    listLoanToken(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'loans/tokens', size, next);
        });
    }
    /**
     * Get information about a loan token with given loan token id.
     *
     * @param {string} id loanToken id to get
     * @return {Promise<LoanToken>}
     */
    getLoanToken(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `loans/tokens/${id}`);
        });
    }
    /**
     * Paginate query loan vaults.
     *
     * @param {number} size of vaults to query
     * @param {string} next set of vaults
     * @return {Promise<ApiPagedResponse<LoanVaultActive | LoanVaultLiquidated>>}
     */
    listVault(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'loans/vaults', size, next);
        });
    }
    /**
     * Get information about a vault with given vault id.
     *
     * @param {string} id vault id to get
     * @return {Promise<LoanVaultActive | LoanVaultLiquidated>}
     */
    getVault(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `loans/vaults/${id}`);
        });
    }
    /**
     * List vault auction history.
     *
     * @param {string} id vaultId
     * @param {number} height liquidation height
     * @param {number} batchIndex batch index
     * @param {number} size of auction batch index history
     * @param {string} next set of auction batch index history
     * @return {Promise<ApiPagedResponse<VaultAuctionBatchHistory>>}
     */
    listVaultAuctionHistory(id, height, batchIndex, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `loans/vaults/${id}/auctions/${height}/batches/${batchIndex}/history`, size, next);
        });
    }
    /**
     * Paginate query loan auctions.
     *
     * @param {number} size of auctions to query
     * @param {string} next set of auctions
     * @return {Promise<ApiPagedResponse<LoanVaultLiquidated>>}
     */
    listAuction(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'loans/auctions', size, next);
        });
    }
}
exports.Loan = Loan;
var LoanVaultState;
(function (LoanVaultState) {
    LoanVaultState["UNKNOWN"] = "UNKNOWN";
    LoanVaultState["ACTIVE"] = "ACTIVE";
    LoanVaultState["FROZEN"] = "FROZEN";
    LoanVaultState["IN_LIQUIDATION"] = "IN_LIQUIDATION";
    LoanVaultState["MAY_LIQUIDATE"] = "MAY_LIQUIDATE";
})(LoanVaultState = exports.LoanVaultState || (exports.LoanVaultState = {}));

},{}],142:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MasternodeState = exports.Masternodes = void 0;
/**
 * DeFi whale endpoint for masternode related services.
 */
class Masternodes {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of masternodes.
     *
     * @param {number} size masternodes size to query
     * @param {string} next  set of masternodes to get
     * @return {Promise<ApiPagedResponse<MasternodeData>>}
     */
    list(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'masternodes', size, next);
        });
    }
    /**
     * Get information about a masternode with given id.
     *
     * @param {string} id masternode id to get
     * @return {Promise<MasternodeData>}
     */
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `masternodes/${id}`);
        });
    }
}
exports.Masternodes = Masternodes;
/**
 * Masternode state
 */
var MasternodeState;
(function (MasternodeState) {
    MasternodeState["PRE_ENABLED"] = "PRE_ENABLED";
    MasternodeState["ENABLED"] = "ENABLED";
    MasternodeState["PRE_RESIGNED"] = "PRE_RESIGNED";
    MasternodeState["RESIGNED"] = "RESIGNED";
    MasternodeState["PRE_BANNED"] = "PRE_BANNED";
    MasternodeState["BANNED"] = "BANNED";
    MasternodeState["UNKNOWN"] = "UNKNOWN";
})(MasternodeState = exports.MasternodeState || (exports.MasternodeState = {}));

},{}],143:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Oracles = void 0;
/**
 * DeFi whale endpoint for oracle related services.
 */
class Oracles {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a list of Oracles
     *
     * @param {number} [size=30] for number of records per page
     * @param {string} [next] offset for the next page
     * @return {Promise<Oracle>}
     */
    list(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'oracles', size, next);
        });
    }
    /**
     * Get price feed
     *
     * @param {string} oracleId identifier for an Oracle
     * @param {string} token symbol as part of the price feed pair
     * @param {string} currency fiat currency part of the price feed pair
     * @param {number} [size=30] for number of records per page
     * @param {string} [next] offset for the next page
     * @return {Promise<OraclePriceFeed>}
     */
    getPriceFeed(oracleId, token, currency, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `${token}-${currency}`;
            return yield this.client.requestList('GET', `oracles/${oracleId}/${key}/feed`, size, next);
        });
    }
    /**
     * Get oracle by address
     *
     * @param {string} address owner address for an Oracle
     * @return {Promise<Oracle>}
     */
    getOracleByAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `oracles/${address}`);
        });
    }
}
exports.Oracles = Oracles;

},{}],144:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolPairs = void 0;
/**
 * DeFi whale endpoint for poolpair related services.
 */
class PoolPairs {
    constructor(client) {
        this.client = client;
    }
    /**
     * List pool pairs
     *
     * @param {number} size of PoolPairData balance to query
     * @param {string} next set of PoolPairData
     * @return {Promise<ApiPagedResponse<PoolPairData>>}
     */
    list(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'poolpairs', size, next);
        });
    }
    /**
     * Get pool pair
     *
     * @param {string} id
     * @return {Promise<PoolPairData>}
     */
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `poolpairs/${id}`);
        });
    }
}
exports.PoolPairs = PoolPairs;

},{}],145:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Prices = exports.PriceFeedTimeInterval = void 0;
/**
 * Time interval for graphing
 */
var PriceFeedTimeInterval;
(function (PriceFeedTimeInterval) {
    PriceFeedTimeInterval[PriceFeedTimeInterval["FIVE_MINUTES"] = 300] = "FIVE_MINUTES";
    PriceFeedTimeInterval[PriceFeedTimeInterval["TEN_MINUTES"] = 600] = "TEN_MINUTES";
    PriceFeedTimeInterval[PriceFeedTimeInterval["ONE_HOUR"] = 3600] = "ONE_HOUR";
    PriceFeedTimeInterval[PriceFeedTimeInterval["ONE_DAY"] = 86400] = "ONE_DAY";
})(PriceFeedTimeInterval = exports.PriceFeedTimeInterval || (exports.PriceFeedTimeInterval = {}));
/**
 * DeFi whale endpoint for price related services.
 */
class Prices {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a list of PriceTicker
     *
     * @param {number} [size=30] for the number of records per page
     * @param {string} [next] offset for the next page
     * @return {Promise<PriceTicker>}
     */
    list(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'prices', size, next);
        });
    }
    /**
     * Get a PriceTicker
     *
     * @param {string} token symbol for the PriceTicker
     * @param {string} currency fiat currency for the PriceTicker
     * @return {Promise<PriceTicker>}
     */
    get(token, currency) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `${token}-${currency}`;
            return yield this.client.requestData('GET', `prices/${key}`);
        });
    }
    getFeedActive(token, currency, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `${token}-${currency}`;
            return yield this.client.requestList('GET', `prices/${key}/feed/active`, size, next);
        });
    }
    /**
     * Get a list of price feed
     *
     * @param {string} token symbol for the PriceTicker
     * @param {string} currency fiat for the PriceTicker
     * @param {number} [size=30] for number of records per page
     * @param {string} [next] offset for the next page
     * @return {Promise<ApiPagedResponse<PriceFeed>>}
     */
    getFeed(token, currency, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `${token}-${currency}`;
            return yield this.client.requestList('GET', `prices/${key}/feed`, size, next);
        });
    }
    getFeedWithInterval(token, currency, interval, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `${token}-${currency}`;
            return yield this.client.requestList('GET', `prices/${key}/feed/interval/${interval}`, size, next);
        });
    }
    /**
     * Get a list of Oracles
     *
     * @param {string} token symbol for the PriceOracle
     * @param {string} currency fiat currency for the PriceOracle
     * @param {number} [size=30] for number of records per page
     * @param {string} [next] offset for the next page
     * @return {Promise<ApiPagedResponse<PriceOracle>>}
     */
    getOracles(token, currency, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `${token}-${currency}`;
            return yield this.client.requestList('GET', `prices/${key}/oracles`, size, next);
        });
    }
}
exports.Prices = Prices;

},{}],146:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rawtx = void 0;
/**
 * DeFi whale endpoint for rawtx related services.
 */
class Rawtx {
    constructor(client) {
        this.client = client;
    }
    /**
     * Send a raw transaction
     *
     * @param {RawTxReq} rawTx to submit to the network.
     * @throws WhaleApiException if failed mempool acceptance
     * @returns {Promise<string>} txid
     */
    send(rawTx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('POST', 'rawtx/send', rawTx);
        });
    }
    /**
     * Send a raw transaction to test the mempool acceptance
     *
     * @param {RawTxReq} rawTx to test mempool acceptance
     * @throws WhaleApiException if failed mempool acceptance
     */
    test(rawTx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('POST', 'rawtx/test', rawTx);
        });
    }
}
exports.Rawtx = Rawtx;

},{}],147:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rpc = void 0;
const jellyfish_api_core_1 = require("@defichain/jellyfish-api-core");
const errors_1 = require("../errors");
class Rpc {
    constructor(client) {
        this.client = client;
    }
    /**
     * @param {string} method of the RPC method
     * @param {any[]} params to send upstream
     * @param {Precision | PrecisionPath} precision for JSON parsing
     * @throws WhaleApiException instanceof for upstream errors
     * @throws WhaleClientException instanceof for local issues
     * @returns {Promise<T>}
     */
    call(method, params, precision) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = jellyfish_api_core_1.JellyfishJSON.stringify({ params: params });
            const responseRaw = yield this.client.requestAsString('POST', `rpc/${method}`, body);
            const response = jellyfish_api_core_1.JellyfishJSON.parse(responseRaw.body, precision);
            errors_1.raiseIfError(response);
            return response.data;
        });
    }
}
exports.Rpc = Rpc;

},{"../errors":154,"@defichain/jellyfish-api-core":59}],148:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stats = void 0;
class Stats {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get stats of DeFi Blockchain
     *
     * @return {Promise<StatsData>}
     */
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', 'stats');
        });
    }
}
exports.Stats = Stats;

},{}],149:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tokens = void 0;
class Tokens {
    constructor(client) {
        this.client = client;
    }
    /**
     * Paginate query tokens.
     *
     * @param {number} size of tokens to query
     * @param {string} next set of tokens
     * @return {Promise<ApiPagedResponse<TokenData>>}
     */
    list(size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'tokens', size, next);
        });
    }
    /**
     * Get information about a token with id of the token.
     *
     * @param {string} id
     * @return {Promise<TokenData>}
     */
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `tokens/${id}`);
        });
    }
}
exports.Tokens = Tokens;

},{}],150:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transactions = void 0;
class Transactions {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a Transaction
     *
     * @param {string} id of transaction to query
     * @return {Promise<Transaction>}
     */
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `transactions/${id}`);
        });
    }
    /**
     * Get a list of vins of a Transaction
     *
     * @param {string} txid of the transaction
     * @param {number} [size=30] size to query
     * @param {string} [next] next token for next slice of vin
     * @return {Promise<ApiPagedResponse<TransactionVin[]>>}
     */
    getVins(txid, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `transactions/${txid}/vins`, size, next);
        });
    }
    /**
     * Get a list of vouts of a Transaction
     *
     * @param {string} txid of the transaction
     * @param {number} [size=30] size to query
     * @param {string} [next] next token for next slice of vout
     * @return {Promise<ApiPagedResponse<TransactionVout[]>>}
     */
    getVouts(txid, size = 30, next) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `transactions/${txid}/vouts`, size, next);
        });
    }
}
exports.Transactions = Transactions;

},{}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleApiException = exports.WhaleApiErrorType = void 0;
var WhaleApiErrorType;
(function (WhaleApiErrorType) {
    WhaleApiErrorType["ValidationError"] = "ValidationError";
    WhaleApiErrorType["BadRequest"] = "BadRequest";
    WhaleApiErrorType["NotFound"] = "NotFound";
    WhaleApiErrorType["Conflict"] = "Conflict";
    WhaleApiErrorType["Forbidden"] = "Forbidden";
    WhaleApiErrorType["Unauthorized"] = "Unauthorized";
    WhaleApiErrorType["BadGateway"] = "BadGateway";
    WhaleApiErrorType["TimeoutError"] = "TimeoutError";
    WhaleApiErrorType["UnknownError"] = "UnknownError";
})(WhaleApiErrorType = exports.WhaleApiErrorType || (exports.WhaleApiErrorType = {}));
/**
 * Serialized exception from DeFi Whale
 */
class WhaleApiException extends Error {
    constructor(error) {
        super(`${error.code} - ${error.type} ${WhaleApiException.url(error)}${WhaleApiException.message(error)}`);
        this.error = error;
    }
    /**
     * @return {number} error code
     */
    get code() {
        return this.error.code;
    }
    /**
     * @return {string} error type
     */
    get type() {
        return this.error.type;
    }
    /**
     * @return {number} time that error occurred at
     */
    get at() {
        return this.error.at;
    }
    /**
     * @return {string} url that threw this endpoint
     */
    get url() {
        return this.error.url;
    }
    static url({ url }) {
        return url !== undefined && url !== null ? `(${url})` : '';
    }
    static message({ message }) {
        return message !== undefined && message !== null ? `: ${message}` : '';
    }
}
exports.WhaleApiException = WhaleApiException;

},{}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleApiValidationException = void 0;
const api_error_1 = require("./api.error");
/**
 * Rich constraints validation error coming from DeFi Whale API.
 */
class WhaleApiValidationException extends api_error_1.WhaleApiException {
    /**
     * @return {ApiValidationProperty[]} that failed constraints validation
     */
    get properties() {
        const error = this.error;
        return error.validation.properties;
    }
}
exports.WhaleApiValidationException = WhaleApiValidationException;

},{"./api.error":151}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleClientTimeoutException = exports.WhaleClientException = void 0;
/**
 * Local client exception, due to local reason.
 */
class WhaleClientException extends Error {
}
exports.WhaleClientException = WhaleClientException;
/**
 * Whale client timeout locally.
 */
class WhaleClientTimeoutException extends WhaleClientException {
    constructor(timeout) {
        super(`request aborted due to timeout of ${timeout} ms`);
        this.timeout = timeout;
    }
}
exports.WhaleClientTimeoutException = WhaleClientTimeoutException;

},{}],154:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.raiseIfError = void 0;
const api_validation_exception_1 = require("./api.validation.exception");
const api_error_1 = require("./api.error");
__exportStar(require("./api.error"), exports);
__exportStar(require("./api.validation.exception"), exports);
__exportStar(require("./client.timeout.exception"), exports);
/**
 * @param {WhaleApiResponse} response to check and raise error if any
 * @throws {WhaleApiException} raised error
 */
function raiseIfError(response) {
    const error = response.error;
    if (error === undefined) {
        return;
    }
    if (error.code === 422 && error.type === api_error_1.WhaleApiErrorType.ValidationError) {
        throw new api_validation_exception_1.WhaleApiValidationException(error);
    }
    throw new api_error_1.WhaleApiException(error);
}
exports.raiseIfError = raiseIfError;

},{"./api.error":151,"./api.validation.exception":152,"./client.timeout.exception":153}],155:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loan = exports.fee = exports.rawtx = exports.stats = exports.prices = exports.oracles = exports.blocks = exports.masternodes = exports.tokens = exports.transactions = exports.poolpairs = exports.address = exports.rpc = void 0;
__exportStar(require("./errors"), exports);
exports.rpc = __importStar(require("./api/rpc"));
exports.address = __importStar(require("./api/address"));
exports.poolpairs = __importStar(require("./api/poolpairs"));
exports.transactions = __importStar(require("./api/transactions"));
exports.tokens = __importStar(require("./api/tokens"));
exports.masternodes = __importStar(require("./api/masternodes"));
exports.blocks = __importStar(require("./api/blocks"));
exports.oracles = __importStar(require("./api/oracles"));
exports.prices = __importStar(require("./api/prices"));
exports.stats = __importStar(require("./api/stats"));
exports.rawtx = __importStar(require("./api/rawtx"));
exports.fee = __importStar(require("./api/fee"));
exports.loan = __importStar(require("./api/loan"));
__exportStar(require("./whale.api.client"), exports);
__exportStar(require("./whale.api.response"), exports);
__exportStar(require("./whale.rpc.client"), exports);

},{"./api/address":138,"./api/blocks":139,"./api/fee":140,"./api/loan":141,"./api/masternodes":142,"./api/oracles":143,"./api/poolpairs":144,"./api/prices":145,"./api/rawtx":146,"./api/rpc":147,"./api/stats":148,"./api/tokens":149,"./api/transactions":150,"./errors":154,"./whale.api.client":157,"./whale.api.response":158,"./whale.rpc.client":159}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = 'v0.18';

},{}],157:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleApiClient = void 0;
require("url-search-params-polyfill");
const abort_controller_1 = __importDefault(require("abort-controller"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const version_1 = __importDefault(require("./version"));
const errors_1 = require("./errors");
const whale_api_response_1 = require("./whale.api.response");
const address_1 = require("./api/address");
const poolpairs_1 = require("./api/poolpairs");
const rpc_1 = require("./api/rpc");
const transactions_1 = require("./api/transactions");
const tokens_1 = require("./api/tokens");
const masternodes_1 = require("./api/masternodes");
const blocks_1 = require("./api/blocks");
const oracles_1 = require("./api/oracles");
const prices_1 = require("./api/prices");
const stats_1 = require("./api/stats");
const rawtx_1 = require("./api/rawtx");
const fee_1 = require("./api/fee");
const loan_1 = require("./api/loan");
/**
 * WhaleApiClient default options
 */
const DEFAULT_OPTIONS = {
    url: 'https://ocean.defichain.com',
    timeout: 60000,
    version: version_1.default,
    network: 'mainnet'
};
class WhaleApiClient {
    constructor(options) {
        this.options = options;
        this.rpc = new rpc_1.Rpc(this);
        this.address = new address_1.Address(this);
        this.poolpairs = new poolpairs_1.PoolPairs(this);
        this.transactions = new transactions_1.Transactions(this);
        this.tokens = new tokens_1.Tokens(this);
        this.masternodes = new masternodes_1.Masternodes(this);
        this.blocks = new blocks_1.Blocks(this);
        this.oracles = new oracles_1.Oracles(this);
        this.prices = new prices_1.Prices(this);
        this.stats = new stats_1.Stats(this);
        this.rawtx = new rawtx_1.Rawtx(this);
        this.fee = new fee_1.Fee(this);
        this.loan = new loan_1.Loan(this);
        this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.options.url = this.options.url.replace(/\/$/, '');
    }
    /**
     * @param {ApiPagedResponse} response from the previous request for pagination chaining
     */
    paginate(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = response.nextToken;
            if (token === undefined) {
                return new whale_api_response_1.ApiPagedResponse({ data: [] }, response.method, response.endpoint);
            }
            const [path, query] = response.endpoint.split('?');
            if (query === undefined) {
                throw new errors_1.WhaleClientException('endpoint does not contain query params for pagination');
            }
            const params = new URLSearchParams(query);
            params.set('next', token.toString());
            const endpoint = `${path}?${params.toString()}`;
            const apiResponse = yield this.requestAsApiResponse(response.method, endpoint);
            return new whale_api_response_1.ApiPagedResponse(apiResponse, response.method, endpoint);
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {number} [size] of the list
     * @param {string} [next] token for pagination
     * @return {ApiPagedResponse} data list in the JSON response body for pagination query
     * @see {paginate(ApiPagedResponse)} for pagination query chaining
     */
    requestList(method, path, size, next) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams();
            params.set('size', size.toString());
            if (next !== undefined) {
                params.set('next', next);
            }
            const endpoint = `${path}?${params.toString()}`;
            const response = yield this.requestAsApiResponse(method, endpoint);
            return new whale_api_response_1.ApiPagedResponse(response, method, endpoint);
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {any} [object] JSON to send in request
     * @return {T} data object in the JSON response body
     */
    requestData(method, path, object) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.requestAsApiResponse(method, path, object);
            return response.data;
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {object} [object] JSON to send in request
     * @return {WhaleApiResponse} parsed structured JSON response
     */
    requestAsApiResponse(method, path, object) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = object !== undefined ? JSON.stringify(object) : undefined;
            const raw = yield this.requestAsString(method, path, json);
            const response = JSON.parse(raw.body);
            errors_1.raiseIfError(response);
            return response;
        });
    }
    /**
     * @param {'POST|'GET'} method to request
     * @param {string} path to request
     * @param {object} [body] in string in request
     * @return {ResponseAsString} as JSON string (RawResponse)
     */
    requestAsString(method, path, body) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url: urlString, version, network, timeout } = this.options;
            const url = `${urlString}/${version}/${network}/${path}`;
            const controller = new abort_controller_1.default();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                const response = yield _fetch(method, url, controller, body);
                clearTimeout(id);
                return response;
            }
            catch (err) {
                if (err.type === 'aborted') {
                    /* eslint-disable @typescript-eslint/no-non-null-assertion */
                    throw new errors_1.WhaleClientTimeoutException(timeout);
                }
                throw err;
            }
        });
    }
}
exports.WhaleApiClient = WhaleApiClient;
/**
 * Generic method for making http requests
 *
 * @param {Method} method for the endpoint
 * @param {string} url to fetch
 * @param {AbortController} controller for aborting request
 * @param {string} body of the request
 * @returns {Promise<ResponseAsString>}
 */
function _fetch(method, url, controller, body) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield cross_fetch_1.default(url, {
            method: method,
            headers: method !== 'GET' ? { 'Content-Type': 'application/json' } : {},
            body: body,
            cache: 'no-cache',
            signal: controller.signal
        });
        return {
            status: response.status,
            body: yield response.text()
        };
    });
}

},{"./api/address":138,"./api/blocks":139,"./api/fee":140,"./api/loan":141,"./api/masternodes":142,"./api/oracles":143,"./api/poolpairs":144,"./api/prices":145,"./api/rawtx":146,"./api/rpc":147,"./api/stats":148,"./api/tokens":149,"./api/transactions":150,"./errors":154,"./version":156,"./whale.api.response":158,"abort-controller":164,"cross-fetch":203,"url-search-params-polyfill":282}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiPagedResponse = void 0;
/**
 * ApiPagedResponse class facilitate the ability to pagination query chaining.
 * It extends the Array class and can be accessed like an array, `res[0]`, `res.length`.
 *
 * After accessing all the items in the Array, you can use the same ApiPagedResponse
 * to query the next set of items. Hence allowing you query pagination chaining until you
 * exhaustive all items in the list.
 *
 * @example
 *   let response: ApiPagedResponse = await client.address.listToken(...)
 *   for (const item of response) {
 *     console.log(item)
 *   }
 *
 *   // To query next set of items:
 *   let response = await client.pagination(response)
 *   for (const item of response) {
 *     console.log(item)
 *   }
 */
class ApiPagedResponse extends Array {
    /**
     * @param {WhaleApiResponse} response that holds the data array and next token
     * @param {Method} method of the REST endpoint
     * @param {string} endpoint to paginate query
     */
    constructor(response, method, endpoint) {
        super(...response.data);
        this._paginate = {
            page: response.page,
            method: method,
            endpoint: endpoint
        };
    }
    /**
     * Built-in methods such as map, filter creates a new array for functional programming.
     * It does that with the constructor found in the static Symbol.species class property.
     * This needs to be overridden as ApiPagedResponse constructor has a different signature.
     */
    static get [Symbol.species]() {
        return Array;
    }
    /**
     * @return {string} endpoint to paginate query
     */
    get endpoint() {
        return this._paginate.endpoint;
    }
    /**
     * @return {Method} method of the REST endpoint
     */
    get method() {
        return this._paginate.method;
    }
    /**
     * @return {boolean} whether there a next set of items to paginate
     */
    get hasNext() {
        return this.nextToken !== undefined;
    }
    /**
     * @return {string} next token
     */
    get nextToken() {
        var _a;
        return (_a = this._paginate.page) === null || _a === void 0 ? void 0 : _a.next;
    }
}
exports.ApiPagedResponse = ApiPagedResponse;

},{}],159:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleRpcClient = void 0;
const jellyfish_api_core_1 = require("@defichain/jellyfish-api-core");
/**
 * A JSON-RPC client implemented with WhaleApiClient.call specification.
 * Not all methods are whitelisted.
 */
class WhaleRpcClient extends jellyfish_api_core_1.ApiClient {
    constructor(whaleApiClient) {
        super();
        this.whaleApiClient = whaleApiClient;
        this.wallet = NotEnabledProxy('wallet');
        this.net = NotEnabledProxy('net');
    }
    /**
     * Implements jellyfish-api-core ApiClient by routing to WhaleApiClient.call
     *
     * @param {string} method the RPC method
     * @param {any[]} params to send upstream
     * @param {Precision | PrecisionPath} precision for JSON parsing
     * @throws WhaleApiException instanceof for upstream errors
     * @throws WhaleClientException instanceof for local issues
     */
    call(method, params, precision) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.whaleApiClient.rpc.call(method, params, precision);
        });
    }
}
exports.WhaleRpcClient = WhaleRpcClient;
function NotEnabledProxy(category) {
    return new Proxy({}, {
        get(target, prop) {
            throw new Error(`WhaleRpcClient: ${category}.${prop} not enabled in WhaleApiClient`);
        }
    });
}

},{"@defichain/jellyfish-api-core":59}],160:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleFeeRateProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
class WhaleFeeRateProvider {
    constructor(client) {
        this.client = client;
    }
    estimate() {
        return __awaiter(this, void 0, void 0, function* () {
            const feeRate = yield this.client.fee.estimate();
            return new bignumber_js_1.default(feeRate);
        });
    }
}
exports.WhaleFeeRateProvider = WhaleFeeRateProvider;

},{"bignumber.js":167}],161:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./feerate"), exports);
__exportStar(require("./prevout"), exports);
__exportStar(require("./wallet"), exports);

},{"./feerate":160,"./prevout":162,"./wallet":163}],162:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhalePrevoutProvider = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const smart_buffer_1 = require("smart-buffer");
const _buffer_1 = require("@defichain/jellyfish-transaction/dist/script/_buffer");
class WhalePrevoutProvider {
    /**
     * @param {WhaleWalletAccount} account to read prevout from
     * @param {number} size max size of prevout to read from all, prevout availability is limited by this
     */
    constructor(account, size) {
        this.account = account;
        this.size = size;
    }
    all() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.account.getAddress();
            const unspent = yield this.account.client.address.listTransactionUnspent(address, this.size);
            return unspent.map((item) => {
                var _a;
                return {
                    txid: item.vout.txid,
                    vout: item.vout.n,
                    value: new bignumber_js_1.default(item.vout.value),
                    script: {
                        // TODO(fuxingloh): needs to refactor once jellyfish refactor this.
                        stack: _buffer_1.toOPCodes(smart_buffer_1.SmartBuffer.fromBuffer(Buffer.from(item.script.hex, 'hex')))
                    },
                    tokenId: (_a = item.vout.tokenId) !== null && _a !== void 0 ? _a : 0x00
                };
            });
        });
    }
    collect(minBalance) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO(fuxingloh): min balance filtering
            return yield this.all();
        });
    }
}
exports.WhalePrevoutProvider = WhalePrevoutProvider;

}).call(this)}).call(this,require("buffer").Buffer)
},{"@defichain/jellyfish-transaction/dist/script/_buffer":95,"bignumber.js":167,"buffer":3,"smart-buffer":273}],163:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WhaleWalletAccountProvider = exports.WhaleWalletAccount = void 0;
const jellyfish_wallet_1 = require("@defichain/jellyfish-wallet");
const dist_1 = require("@defichain/jellyfish-transaction-builder/dist");
const feerate_1 = require("./feerate");
const prevout_1 = require("./prevout");
class WhaleWalletAccount extends jellyfish_wallet_1.WalletAccount {
    constructor(client, walletEllipticPair, network, prevoutSize = 50) {
        super(walletEllipticPair, network);
        this.client = client;
        this.feeRateProvider = new feerate_1.WhaleFeeRateProvider(client);
        this.prevoutProvider = new prevout_1.WhalePrevoutProvider(this, prevoutSize);
    }
    isActive() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            const agg = yield this.client.address.getAggregation(address);
            return agg !== undefined;
        });
    }
    withTransactionBuilder() {
        return new dist_1.P2WPKHTransactionBuilder(this.feeRateProvider, this.prevoutProvider, {
            get: (_) => this
        }, this.network);
    }
}
exports.WhaleWalletAccount = WhaleWalletAccount;
class WhaleWalletAccountProvider {
    constructor(client, network) {
        this.client = client;
        this.network = network;
    }
    provide(walletEllipticPair) {
        return new WhaleWalletAccount(this.client, walletEllipticPair, this.network);
    }
}
exports.WhaleWalletAccountProvider = WhaleWalletAccountProvider;

},{"./feerate":160,"./prevout":162,"@defichain/jellyfish-transaction-builder/dist":78,"@defichain/jellyfish-wallet":133}],164:[function(require,module,exports){
/*globals self, window */
"use strict"

/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports.default = AbortController

},{}],165:[function(require,module,exports){
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = require('safe-buffer').Buffer
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

},{"safe-buffer":263}],166:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

},{}],167:[function(require,module,exports){
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

},{}],168:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("./crypto");
const bs58check = require('bs58check');
const ecc = require('tiny-secp256k1');
const typeforce = require('typeforce');
const wif = require('wif');
const UINT256_TYPE = typeforce.BufferN(32);
const NETWORK_TYPE = typeforce.compile({
    wif: typeforce.UInt8,
    bip32: {
        public: typeforce.UInt32,
        private: typeforce.UInt32,
    },
});
const BITCOIN = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4,
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80,
};
const HIGHEST_BIT = 0x80000000;
const UINT31_MAX = Math.pow(2, 31) - 1;
function BIP32Path(value) {
    return (typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null);
}
function UInt31(value) {
    return typeforce.UInt32(value) && value <= UINT31_MAX;
}
class BIP32 {
    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
        this.__D = __D;
        this.__Q = __Q;
        this.chainCode = chainCode;
        this.network = network;
        this.__DEPTH = __DEPTH;
        this.__INDEX = __INDEX;
        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
        typeforce(NETWORK_TYPE, network);
        this.lowR = false;
    }
    get depth() {
        return this.__DEPTH;
    }
    get index() {
        return this.__INDEX;
    }
    get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
    }
    get publicKey() {
        if (this.__Q === undefined)
            this.__Q = ecc.pointFromScalar(this.__D, true);
        return this.__Q;
    }
    get privateKey() {
        return this.__D;
    }
    get identifier() {
        return crypto.hash160(this.publicKey);
    }
    get fingerprint() {
        return this.identifier.slice(0, 4);
    }
    get compressed() {
        return true;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
        return this.__D === undefined;
    }
    neutered() {
        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
        const network = this.network;
        const version = !this.isNeutered()
            ? network.bip32.private
            : network.bip32.public;
        const buffer = Buffer.allocUnsafe(78);
        // 4 bytes: version bytes
        buffer.writeUInt32BE(version, 0);
        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
        buffer.writeUInt8(this.depth, 4);
        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
        buffer.writeUInt32BE(this.parentFingerprint, 5);
        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
        // This is encoded in big endian. (0x00000000 if master key)
        buffer.writeUInt32BE(this.index, 9);
        // 32 bytes: the chain code
        this.chainCode.copy(buffer, 13);
        // 33 bytes: the public key or private key data
        if (!this.isNeutered()) {
            // 0x00 + k for private keys
            buffer.writeUInt8(0, 45);
            this.privateKey.copy(buffer, 46);
            // 33 bytes: the public key
        }
        else {
            // X9.62 encoding for public keys
            this.publicKey.copy(buffer, 45);
        }
        return bs58check.encode(buffer);
    }
    toWIF() {
        if (!this.privateKey)
            throw new TypeError('Missing private key');
        return wif.encode(this.network.wif, this.privateKey, true);
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(index) {
        typeforce(typeforce.UInt32, index);
        const isHardened = index >= HIGHEST_BIT;
        const data = Buffer.allocUnsafe(37);
        // Hardened child
        if (isHardened) {
            if (this.isNeutered())
                throw new TypeError('Missing private key for hardened child key');
            // data = 0x00 || ser256(kpar) || ser32(index)
            data[0] = 0x00;
            this.privateKey.copy(data, 1);
            data.writeUInt32BE(index, 33);
            // Normal child
        }
        else {
            // data = serP(point(kpar)) || ser32(index)
            //      = serP(Kpar) || ser32(index)
            this.publicKey.copy(data, 0);
            data.writeUInt32BE(index, 33);
        }
        const I = crypto.hmacSHA512(this.chainCode, data);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        // if parse256(IL) >= n, proceed with the next value for i
        if (!ecc.isPrivate(IL))
            return this.derive(index + 1);
        // Private parent key -> private child key
        let hd;
        if (!this.isNeutered()) {
            // ki = parse256(IL) + kpar (mod n)
            const ki = ecc.privateAdd(this.privateKey, IL);
            // In case ki == 0, proceed with the next value for i
            if (ki == null)
                return this.derive(index + 1);
            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
            // Public parent key -> public child key
        }
        else {
            // Ki = point(parse256(IL)) + Kpar
            //    = G*IL + Kpar
            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
            // In case Ki is the point at infinity, proceed with the next value for i
            if (Ki === null)
                return this.derive(index + 1);
            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
        }
        return hd;
    }
    deriveHardened(index) {
        typeforce(UInt31, index);
        // Only derives hardened private keys by default
        return this.derive(index + HIGHEST_BIT);
    }
    derivePath(path) {
        typeforce(BIP32Path, path);
        let splitPath = path.split('/');
        if (splitPath[0] === 'm') {
            if (this.parentFingerprint)
                throw new TypeError('Expected master, got child');
            splitPath = splitPath.slice(1);
        }
        return splitPath.reduce((prevHd, indexStr) => {
            let index;
            if (indexStr.slice(-1) === `'`) {
                index = parseInt(indexStr.slice(0, -1), 10);
                return prevHd.deriveHardened(index);
            }
            else {
                index = parseInt(indexStr, 10);
                return prevHd.derive(index);
            }
        }, this);
    }
    sign(hash, lowR) {
        if (!this.privateKey)
            throw new Error('Missing private key');
        if (lowR === undefined)
            lowR = this.lowR;
        if (lowR === false) {
            return ecc.sign(hash, this.privateKey);
        }
        else {
            let sig = ecc.sign(hash, this.privateKey);
            const extraData = Buffer.alloc(32, 0);
            let counter = 0;
            // if first try is lowR, skip the loop
            // for second try and on, add extra entropy counting up
            while (sig[0] > 0x7f) {
                counter++;
                extraData.writeUIntLE(counter, 0, 6);
                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
            }
            return sig;
        }
    }
    verify(hash, signature) {
        return ecc.verify(hash, this.publicKey, signature);
    }
}
function fromBase58(inString, network) {
    const buffer = bs58check.decode(inString);
    if (buffer.length !== 78)
        throw new TypeError('Invalid buffer length');
    network = network || BITCOIN;
    // 4 bytes: version bytes
    const version = buffer.readUInt32BE(0);
    if (version !== network.bip32.private && version !== network.bip32.public)
        throw new TypeError('Invalid network version');
    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
    const depth = buffer[4];
    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
    const parentFingerprint = buffer.readUInt32BE(5);
    if (depth === 0) {
        if (parentFingerprint !== 0x00000000)
            throw new TypeError('Invalid parent fingerprint');
    }
    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
    // This is encoded in MSB order. (0x00000000 if master key)
    const index = buffer.readUInt32BE(9);
    if (depth === 0 && index !== 0)
        throw new TypeError('Invalid index');
    // 32 bytes: the chain code
    const chainCode = buffer.slice(13, 45);
    let hd;
    // 33 bytes: private key data (0x00 + k)
    if (version === network.bip32.private) {
        if (buffer.readUInt8(45) !== 0x00)
            throw new TypeError('Invalid private key');
        const k = buffer.slice(46, 78);
        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
        // 33 bytes: public key data (0x02 + X or 0x03 + X)
    }
    else {
        const X = buffer.slice(45, 78);
        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
    }
    return hd;
}
exports.fromBase58 = fromBase58;
function fromPrivateKey(privateKey, chainCode, network) {
    return fromPrivateKeyLocal(privateKey, chainCode, network);
}
exports.fromPrivateKey = fromPrivateKey;
function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
        privateKey: UINT256_TYPE,
        chainCode: UINT256_TYPE,
    }, { privateKey, chainCode });
    network = network || BITCOIN;
    if (!ecc.isPrivate(privateKey))
        throw new TypeError('Private key not in range [1, n)');
    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
}
function fromPublicKey(publicKey, chainCode, network) {
    return fromPublicKeyLocal(publicKey, chainCode, network);
}
exports.fromPublicKey = fromPublicKey;
function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
    typeforce({
        publicKey: typeforce.BufferN(33),
        chainCode: UINT256_TYPE,
    }, { publicKey, chainCode });
    network = network || BITCOIN;
    // verify the X coordinate is a point on the curve
    if (!ecc.isPoint(publicKey))
        throw new TypeError('Point is not on the curve');
    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
}
function fromSeed(seed, network) {
    typeforce(typeforce.Buffer, seed);
    if (seed.length < 16)
        throw new TypeError('Seed should be at least 128 bits');
    if (seed.length > 64)
        throw new TypeError('Seed should be at most 512 bits');
    network = network || BITCOIN;
    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return fromPrivateKey(IL, IR, network);
}
exports.fromSeed = fromSeed;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./crypto":169,"bs58check":196,"buffer":3,"tiny-secp256k1":276,"typeforce":280,"wif":284}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const createHash = require('create-hash');
const createHmac = require('create-hmac');
function hash160(buffer) {
    const sha256Hash = createHash('sha256')
        .update(buffer)
        .digest();
    try {
        return createHash('rmd160')
            .update(sha256Hash)
            .digest();
    }
    catch (err) {
        return createHash('ripemd160')
            .update(sha256Hash)
            .digest();
    }
}
exports.hash160 = hash160;
function hmacSHA512(key, data) {
    return createHmac('sha512', key)
        .update(data)
        .digest();
}
exports.hmacSHA512 = hmacSHA512;

},{"create-hash":199,"create-hmac":201}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var bip32_1 = require("./bip32");
exports.fromSeed = bip32_1.fromSeed;
exports.fromBase58 = bip32_1.fromBase58;
exports.fromPublicKey = bip32_1.fromPublicKey;
exports.fromPrivateKey = bip32_1.fromPrivateKey;

},{"./bip32":168}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
const wordlists = {};
exports.wordlists = wordlists;
let _default;
exports._default = _default;
try {
    exports._default = _default = require('./wordlists/czech.json');
    wordlists.czech = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/chinese_simplified.json');
    wordlists.chinese_simplified = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/chinese_traditional.json');
    wordlists.chinese_traditional = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/korean.json');
    wordlists.korean = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/french.json');
    wordlists.french = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/italian.json');
    wordlists.italian = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/spanish.json');
    wordlists.spanish = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/japanese.json');
    wordlists.japanese = _default;
    wordlists.JA = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/portuguese.json');
    wordlists.portuguese = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/english.json');
    wordlists.english = _default;
    wordlists.EN = _default;
}
catch (err) { }

},{"./wordlists/chinese_simplified.json":undefined,"./wordlists/chinese_traditional.json":undefined,"./wordlists/czech.json":undefined,"./wordlists/english.json":173,"./wordlists/french.json":undefined,"./wordlists/italian.json":undefined,"./wordlists/japanese.json":undefined,"./wordlists/korean.json":undefined,"./wordlists/portuguese.json":undefined,"./wordlists/spanish.json":undefined}],172:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const createHash = require("create-hash");
const pbkdf2_1 = require("pbkdf2");
const randomBytes = require("randombytes");
const _wordlists_1 = require("./_wordlists");
let DEFAULT_WORDLIST = _wordlists_1._default;
const INVALID_MNEMONIC = 'Invalid mnemonic';
const INVALID_ENTROPY = 'Invalid entropy';
const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
    'Please pass a 2048 word array explicitly.';
function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
    return Promise.resolve().then(() => new Promise((resolve, reject) => {
        const callback = (err, derivedKey) => {
            if (err) {
                return reject(err);
            }
            else {
                return resolve(derivedKey);
            }
        };
        pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);
    }));
}
function normalize(str) {
    return (str || '').normalize('NFKD');
}
function lpad(str, padString, length) {
    while (str.length < length) {
        str = padString + str;
    }
    return str;
}
function binaryToByte(bin) {
    return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
}
function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = createHash('sha256')
        .update(entropyBuffer)
        .digest();
    return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function salt(password) {
    return 'mnemonic' + (password || '');
}
function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
    return Promise.resolve().then(() => {
        const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
        const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
    });
}
exports.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic).split(' ');
    if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
    }
    // convert word indices to 11 bit binary strings
    const bits = words
        .map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), '0', 11);
    })
        .join('');
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString('hex');
}
exports.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
    if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, 'hex');
    }
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    // 128 <= ENT <= 256
    if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
    });
    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
        ? words.join('\u3000')
        : words.join(' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || randomBytes;
    return entropyToMnemonic(rng(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
        DEFAULT_WORDLIST = result;
    }
    else {
        throw new Error('Could not find wordlist for language "' + language + '"');
    }
}
exports.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
        throw new Error('No Default Wordlist set');
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === 'JA' || lang === 'EN') {
            return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
}
exports.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = require("./_wordlists");
exports.wordlists = _wordlists_2.wordlists;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./_wordlists":171,"buffer":3,"create-hash":199,"pbkdf2":240,"randombytes":246}],173:[function(require,module,exports){
module.exports=[
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
]

},{}],174:[function(require,module,exports){
// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use

var Buffer = require('safe-buffer').Buffer

function check (buffer) {
  if (buffer.length < 8) return false
  if (buffer.length > 72) return false
  if (buffer[0] !== 0x30) return false
  if (buffer[1] !== buffer.length - 2) return false
  if (buffer[2] !== 0x02) return false

  var lenR = buffer[3]
  if (lenR === 0) return false
  if (5 + lenR >= buffer.length) return false
  if (buffer[4 + lenR] !== 0x02) return false

  var lenS = buffer[5 + lenR]
  if (lenS === 0) return false
  if ((6 + lenR + lenS) !== buffer.length) return false

  if (buffer[4] & 0x80) return false
  if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) return false

  if (buffer[lenR + 6] & 0x80) return false
  if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) return false
  return true
}

function decode (buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short')
  if (buffer.length > 72) throw new Error('DER sequence length is too long')
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence')
  if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid')
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer')

  var lenR = buffer[3]
  if (lenR === 0) throw new Error('R length is zero')
  if (5 + lenR >= buffer.length) throw new Error('R length is too long')
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)')

  var lenS = buffer[5 + lenR]
  if (lenS === 0) throw new Error('S length is zero')
  if ((6 + lenR + lenS) !== buffer.length) throw new Error('S length is invalid')

  if (buffer[4] & 0x80) throw new Error('R value is negative')
  if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) throw new Error('R value excessively padded')

  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative')
  if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded')

  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR)
  }
}

/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
function encode (r, s) {
  var lenR = r.length
  var lenS = s.length
  if (lenR === 0) throw new Error('R length is zero')
  if (lenS === 0) throw new Error('S length is zero')
  if (lenR > 33) throw new Error('R length is too long')
  if (lenS > 33) throw new Error('S length is too long')
  if (r[0] & 0x80) throw new Error('R value is negative')
  if (s[0] & 0x80) throw new Error('S value is negative')
  if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) throw new Error('R value excessively padded')
  if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) throw new Error('S value excessively padded')

  var signature = Buffer.allocUnsafe(6 + lenR + lenS)

  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30
  signature[1] = signature.length - 2
  signature[2] = 0x02
  signature[3] = r.length
  r.copy(signature, 4)
  signature[4 + lenR] = 0x02
  signature[5 + lenR] = s.length
  s.copy(signature, 6 + lenR)

  return signature
}

module.exports = {
  check: check,
  decode: decode,
  encode: encode
}

},{"safe-buffer":263}],175:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":2}],176:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":2}],177:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":263}],178:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":177,"./ghash":182,"./incr32":183,"buffer-xor":197,"cipher-base":198,"inherits":235,"safe-buffer":263}],179:[function(require,module,exports){
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":180,"./encrypter":181,"./modes/list.json":191}],180:[function(require,module,exports){
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./aes":177,"./authCipher":178,"./modes":190,"./streamCipher":193,"cipher-base":198,"evp_bytestokey":220,"inherits":235,"safe-buffer":263}],181:[function(require,module,exports){
var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./aes":177,"./authCipher":178,"./modes":190,"./streamCipher":193,"cipher-base":198,"evp_bytestokey":220,"inherits":235,"safe-buffer":263}],182:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":263}],183:[function(require,module,exports){
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],184:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":197}],185:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"buffer-xor":197,"safe-buffer":263}],186:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":263}],187:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":263}],188:[function(require,module,exports){
var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"../incr32":183,"buffer-xor":197,"safe-buffer":263}],189:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],190:[function(require,module,exports){
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./cbc":184,"./cfb":185,"./cfb1":186,"./cfb8":187,"./ctr":188,"./ecb":189,"./list.json":191,"./ofb":192}],191:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],192:[function(require,module,exports){
(function (Buffer){(function (){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3,"buffer-xor":197}],193:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":177,"cipher-base":198,"inherits":235,"safe-buffer":263}],194:[function(require,module,exports){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)

},{"base-x":165}],195:[function(require,module,exports){
'use strict'

var base58 = require('bs58')
var Buffer = require('safe-buffer').Buffer

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var checksum = checksumFn(payload)

    return base58.encode(Buffer.concat([
      payload,
      checksum
    ], payload.length + 4))
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}

},{"bs58":194,"safe-buffer":263}],196:[function(require,module,exports){
'use strict'

var createHash = require('create-hash')
var bs58checkBase = require('./base')

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  var tmp = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(tmp).digest()
}

module.exports = bs58checkBase(sha256x2)

},{"./base":195,"create-hash":199}],197:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3}],198:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":235,"safe-buffer":263,"stream":10,"string_decoder":25}],199:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":198,"inherits":235,"md5.js":237,"ripemd160":262,"sha.js":266}],200:[function(require,module,exports){
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":237}],201:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"./legacy":202,"cipher-base":198,"create-hash/md5":200,"inherits":235,"ripemd160":262,"safe-buffer":263,"sha.js":266}],202:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"cipher-base":198,"inherits":235,"safe-buffer":263}],203:[function(require,module,exports){
var global = typeof self !== 'undefined' ? self : this;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}));
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports

},{}],204:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":219,"./elliptic/curve":207,"./elliptic/curves":210,"./elliptic/ec":211,"./elliptic/eddsa":214,"./elliptic/utils":218,"brorand":176}],205:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":218,"bn.js":175}],206:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":218,"./base":205,"bn.js":175,"inherits":235}],207:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":205,"./edwards":206,"./mont":208,"./short":209}],208:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":218,"./base":205,"bn.js":175,"inherits":235}],209:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":218,"./base":205,"bn.js":175,"inherits":235}],210:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"./curve":207,"./precomputed/secp256k1":217,"./utils":218,"hash.js":222}],211:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":210,"../utils":218,"./key":212,"./signature":213,"bn.js":175,"brorand":176,"hmac-drbg":234}],212:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":218,"bn.js":175}],213:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":218,"bn.js":175}],214:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":210,"../utils":218,"./key":215,"./signature":216,"hash.js":222}],215:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":218}],216:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":218,"bn.js":175}],217:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],218:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":175,"minimalistic-assert":238,"minimalistic-crypto-utils":239}],219:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "elliptic@6.5.4",
      "C:\\Users\\ufboq\\Downloads\\Telegram Desktop\\dtoken"
    ]
  ],
  "_development": true,
  "_from": "elliptic@6.5.4",
  "_id": "elliptic@6.5.4",
  "_inBundle": false,
  "_integrity": "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
  "_location": "/elliptic",
  "_phantomChildren": {},
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "elliptic@6.5.4",
    "name": "elliptic",
    "escapedName": "elliptic",
    "rawSpec": "6.5.4",
    "saveSpec": null,
    "fetchSpec": "6.5.4"
  },
  "_requiredBy": [
    "/tiny-secp256k1"
  ],
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
  "_spec": "6.5.4",
  "_where": "C:\\Users\\ufboq\\Downloads\\Telegram Desktop\\dtoken",
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  },
  "description": "EC cryptography",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "files": [
    "lib"
  ],
  "homepage": "https://github.com/indutny/elliptic",
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "license": "MIT",
  "main": "lib/elliptic.js",
  "name": "elliptic",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "test": "npm run lint && npm run unit",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "version": "grunt dist && git add dist/"
  },
  "version": "6.5.4"
}

},{}],220:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"md5.js":237,"safe-buffer":263}],221:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('readable-stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":235,"readable-stream":261,"safe-buffer":263}],222:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":223,"./hash/hmac":224,"./hash/ripemd":225,"./hash/sha":226,"./hash/utils":233}],223:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":233,"minimalistic-assert":238}],224:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":233,"minimalistic-assert":238}],225:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":223,"./utils":233}],226:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":227,"./sha/224":228,"./sha/256":229,"./sha/384":230,"./sha/512":231}],227:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":223,"../utils":233,"./common":232}],228:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":233,"./256":229}],229:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":223,"../utils":233,"./common":232,"minimalistic-assert":238}],230:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":233,"./512":231}],231:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":223,"../utils":233,"minimalistic-assert":238}],232:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":233}],233:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":235,"minimalistic-assert":238}],234:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":222,"minimalistic-assert":238,"minimalistic-crypto-utils":239}],235:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],236:[function(require,module,exports){
!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((r="undefined"!=typeof globalThis?globalThis:r||self).LosslessJSON={})}(this,function(r){"use strict";var e=!0;function o(r){return r&&void 0!==r.circularRefs&&null!==r.circularRefs&&(e=!0===r.circularRefs),{circularRefs:e}}function i(r){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&"function"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r})(r)}function f(r,e){for(var n=0;n<e.length;n++){var t=e[n];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}var u=function(){function e(r){!function(r,e){if(!(r instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.value=function r(e){{if("string"==typeof e){if(!l(e))throw new Error('Invalid number (value: "'+e+'")');return e}if("number"!=typeof e)return r(e&&e.valueOf());if(15<a(e+"").length)throw new Error("Invalid number: contains more than 15 digits (value: "+e+")");if(isNaN(e))throw new Error("Invalid number: NaN");if(!isFinite(e))throw new Error("Invalid number: Infinity");return e+""}}(r),this.type="LosslessNumber",this.isLosslessNumber=!0}var r,n,t;return r=e,(n=[{key:"valueOf",value:function(){var r=parseFloat(this.value),e=a(this.value);if(15<e.length)throw new Error("Cannot convert to number: number would be truncated (value: "+this.value+")");if(!isFinite(r))throw new Error("Cannot convert to number: number would overflow (value: "+this.value+")");if(Math.abs(r)<Number.MIN_VALUE&&!/^0*$/.test(e))throw new Error("Cannot convert to number: number would underflow (value: "+this.value+")");return r}},{key:"toString",value:function(){return this.value}}])&&f(r.prototype,n),t&&f(r,t),e}();function a(r){return("string"!=typeof r?r+"":r).replace(/^-/,"").replace(/e.*$/,"").replace(/^0\.?0*|\./,"")}function l(r){return/^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/.test(r)}function c(r,e,n,t){return Array.isArray(n)?t.call(r,e,function(r,e){for(var n=[],t=0;t<r.length;t++)n[t]=c(r,t+"",r[t],e);return n}(n,t)):n&&"object"===i(n)&&!n.isLosslessNumber?t.call(r,e,function(r,e){var n,t={};for(n in r)r.hasOwnProperty(n)&&(t[n]=c(r,n,r[n],e));return t}(n,t)):t.call(r,e,n)}function n(r){return encodeURIComponent(r.replace(/\//g,"~1").replace(/~/g,"~0"))}function s(r){return decodeURIComponent(r).replace(/~1/g,"/").replace(/~0/g,"~")}function h(r){return"#/"+r.map(n).join("/")}var v={NULL:0,DELIMITER:1,NUMBER:2,STRING:3,SYMBOL:4,UNKNOWN:5},t={"":!0,"{":!0,"}":!0,"[":!0,"]":!0,":":!0,",":!0},p={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"},d="",y=0,b="",g="",m=v.NULL,w=[],I=[];function E(){y++,b=d.charAt(y)}function N(){for(m=v.NULL,g="";" "===b||"\t"===b||"\n"===b||"\r"===b;)E();if(t[b])return m=v.DELIMITER,g=b,void E();if(R(b)||"-"===b){if(m=v.NUMBER,"-"===b){if(g+=b,E(),!R(b))throw S("Invalid number, digit expected",y)}else"0"===b&&(g+=b,E());for(;R(b);)g+=b,E();if("."===b){if(g+=b,E(),!R(b))throw S("Invalid number, digit expected",y);for(;R(b);)g+=b,E()}if("e"===b||"E"===b){if(g+=b,E(),"+"!==b&&"-"!==b||(g+=b,E()),!R(b))throw S("Invalid number, digit expected",y);for(;R(b);)g+=b,E()}}else if('"'!==b){if(!L(b)){for(m=v.UNKNOWN;""!==b;)g+=b,E();throw S('Syntax error in part "'+g+'"')}for(m=v.SYMBOL;L(b);)g+=b,E()}else{for(m=v.STRING,E();""!==b&&'"'!==b;)if("\\"===b){E();var r=p[b];if(void 0!==r)g+=r,E();else{if("u"!==b)throw S('Invalid escape character "\\'+b+'"',y);E();for(var e="",n=0;n<4;n++){if(!/^[0-9a-fA-F]/.test(b))throw S("Invalid unicode character");e+=b,E()}g+=String.fromCharCode(parseInt(e,16))}}else g+=b,E();if('"'!==b)throw S("End of string expected");E()}}function L(r){return/^[a-zA-Z_]/.test(r)}function R(r){return"0"<=r&&r<="9"}function S(r,e){void 0===e&&(e=y-g.length);r=new SyntaxError(r+" (char "+e+")");return r.char=e,r}function O(){if(m!==v.DELIMITER||"{"!==g)return function(){if(m!==v.DELIMITER||"["!==g)return function(){if(m!==v.STRING)return function(){if(m!==v.NUMBER)return function(){if(m!==v.SYMBOL)return function(){throw S(""===g?"Unexpected end of json string":"Value expected")}();if("true"===g)return N(),!0;if("false"===g)return N(),!1;if("null"!==g)throw S('Unknown symbol "'+g+'"');return N(),null}();var r=new u(g);return N(),r}();var r=g;return N(),r}();N();var r=[];if(m===v.DELIMITER&&"]"===g)return N(),r;var e=I.length;I[e]=r;for(;w[e]=r.length+"",r.push(O()),m===v.DELIMITER&&","===g;)N();if(m===v.DELIMITER&&"]"===g)return N(),I.length=e,w.length=e,r;throw S('Comma or end of array "]" expected')}();var r,e;N();var n={};if(m===v.DELIMITER&&"}"===g)return N(),n;var t=I.length;for(I[t]=n;;){if(m!==v.STRING)throw S("Object key expected");if(e=g,N(),m!==v.DELIMITER||":"!==g)throw S("Colon expected");if(N(),n[w[t]=e]=O(),m!==v.DELIMITER||","!==g)break;N()}if(m!==v.DELIMITER||"}"!==g)throw S('Comma or end of object "}" expected');return N(),"string"==typeof(r=n).$ref&&1===Object.keys(r).length?function(r){if(!o().circularRefs)return r;for(var e=function(r){if("#"!==(r=r.split("/").map(s)).shift())throw SyntaxError("Cannot parse JSON Pointer: no valid URI fragment");return""===r[r.length-1]&&r.pop(),r}(r.$ref),n=0;n<e.length;n++)if(e[n]!==w[n])throw new Error('Invalid circular reference "'+r.$ref+'"');return I[e.length]}(n):(I.length=t,w.length=t,n)}var M=[],x=[];function T(r,e,n){x=[],M=[];var t,r="function"==typeof e?e.call({"":r},"",r):r;return"number"==typeof n?10<n?t=j(" ",10):1<=n&&(t=j(" ",n)):"string"==typeof n&&""!==n&&(t=n),U(r,e,t,"")}function U(r,e,n,t){return"boolean"==typeof r||r instanceof Boolean||null===r||"number"==typeof r||r instanceof Number||"string"==typeof r||r instanceof String||r instanceof Date?JSON.stringify(r):r&&r.isLosslessNumber?r.value:Array.isArray(r)?function(r,e,n,t){var o=n?t+n:void 0,i=n?"[\n":"[";if(D(r))return A(r,e,n,t);var f=x.length;x[f]=r;for(var u=0;u<r.length;u++){var a=u+"",l="function"==typeof e?e.call(r,a,r[u]):r[u];n&&(i+=o),void 0!==l&&"function"!=typeof l?(M[f]=a,i+=U(l,e,n,o)):i+="null",u<r.length-1&&(i+=n?",\n":",")}return x.length=f,M.length=f,i+=n?"\n"+t+"]":"]"}(r,e,n,t):r&&"object"===i(r)?C(r,e,n,t):void 0}function C(r,e,n,t){var o=n?t+n:void 0,i=!0,f=n?"{\n":"{";if("function"==typeof r.toJSON)return T(r.toJSON(),e,n);if(D(r))return A(r,e,n,t);var u,a,l,c,s,h=x.length;for(u in x[h]=r)r.hasOwnProperty(u)&&(a="function"==typeof e?e.call(r,u,r[u]):r[u],l=u,s=e,void 0===(c=a)||"function"==typeof c||Array.isArray(s)&&!function(r,e){for(var n=0;n<r.length;n++)if(r[n]==e)return!0;return!1}(s,l)||(i?i=!1:f+=n?",\n":",",l=JSON.stringify(u),f+=n?o+l+": ":l+":",M[h]=u,f+=U(a,e,n,o)));return x.length=h,M.length=h,f+=n?"\n"+t+"}":"}"}function D(r){return-1!==x.indexOf(r)}function A(r,e,n,t){if(!o().circularRefs)throw new Error('Circular reference at "'+h(M)+'"');r=x.indexOf(r);return C({$ref:h(M.slice(0,r))},e,n,t)}function j(r,e){for(var n="";0<e--;)n+=r;return n}r.LosslessNumber=u,r.config=o,r.parse=function(r,e){y=0,b=(d=r).charAt(0),g="",m=v.NULL,I=[],w=[],N();var n=O();if(""!==g)throw S("Unexpected characters");return e?c({"":r=n},"",r,e):n},r.stringify=T,Object.defineProperty(r,"__esModule",{value:!0})});


},{}],237:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":221,"inherits":235,"safe-buffer":263}],238:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],239:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],240:[function(require,module,exports){
exports.pbkdf2 = require('./lib/async')
exports.pbkdf2Sync = require('./lib/sync')

},{"./lib/async":241,"./lib/sync":244}],241:[function(require,module,exports){
(function (global){(function (){
var Buffer = require('safe-buffer').Buffer

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var sync = require('./sync')
var toBuffer = require('./to-buffer')

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
var nextTick
function getNextTick () {
  if (nextTick) {
    return nextTick
  }
  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask
  } else if (global.setImmediate) {
    nextTick = global.setImmediate
  } else {
    nextTick = global.setTimeout
  }
  return nextTick
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out)
    })
  }, function (e) {
    getNextTick()(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
    return
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":242,"./precondition":243,"./sync":244,"./to-buffer":245,"safe-buffer":263}],242:[function(require,module,exports){
(function (process,global){(function (){
var defaultEncoding
/* istanbul ignore next */
if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8'
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":8}],243:[function(require,module,exports){
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

},{}],244:[function(require,module,exports){
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Buffer = require('safe-buffer').Buffer

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var toBuffer = require('./to-buffer')

var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2

},{"./default-encoding":242,"./precondition":243,"./to-buffer":245,"create-hash/md5":200,"ripemd160":262,"safe-buffer":263,"sha.js":266}],245:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}

},{"safe-buffer":263}],246:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":8,"safe-buffer":263}],247:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],248:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./_stream_readable":250,"./_stream_writable":252,"_process":8,"dup":12,"inherits":235}],249:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"./_stream_transform":251,"dup":13,"inherits":235}],250:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"../errors":247,"./_stream_duplex":248,"./internal/streams/async_iterator":253,"./internal/streams/buffer_list":254,"./internal/streams/destroy":255,"./internal/streams/from":257,"./internal/streams/state":259,"./internal/streams/stream":260,"_process":8,"buffer":3,"dup":14,"events":4,"inherits":235,"string_decoder/":275,"util":2}],251:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"../errors":247,"./_stream_duplex":248,"dup":15,"inherits":235}],252:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"../errors":247,"./_stream_duplex":248,"./internal/streams/destroy":255,"./internal/streams/state":259,"./internal/streams/stream":260,"_process":8,"buffer":3,"dup":16,"inherits":235,"util-deprecate":283}],253:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./end-of-stream":256,"_process":8,"dup":17}],254:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"buffer":3,"dup":18,"util":2}],255:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"_process":8,"dup":19}],256:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"../../../errors":247,"dup":20}],257:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],258:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"../../../errors":247,"./end-of-stream":256,"dup":22}],259:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"../../../errors":247,"dup":23}],260:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"events":4}],261:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":248,"./lib/_stream_passthrough.js":249,"./lib/_stream_readable.js":250,"./lib/_stream_transform.js":251,"./lib/_stream_writable.js":252,"./lib/internal/streams/end-of-stream.js":256,"./lib/internal/streams/pipeline.js":258}],262:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":3,"hash-base":221,"inherits":235}],263:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"buffer":3,"dup":9}],264:[function(require,module,exports){
(function (setImmediate){(function (){
"use strict";

(function(root) {
    const MAX_VALUE = 0x7fffffff;

    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
        const K = new Uint32Array([
           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
       ]);

        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const w = new Uint32Array(64);

        function blocks(p) {
            let off = 0, len = p.length;
            while (len >= 64) {
                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;

                for (i = 0; i < 16; i++) {
                    j = off + i*4;
                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |
                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);
                }

                for (i = 16; i < 64; i++) {
                    u = w[i-2];
                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);

                    u = w[i-15];
                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);

                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;
                }

                for (i = 0; i < 64; i++) {
                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^
                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +
                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;

                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^
                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;

                    h = g;
                    g = f;
                    f = e;
                    e = (d + t1) | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = (t1 + t2) | 0;
                }

                h0 = (h0 + a) | 0;
                h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0;
                h3 = (h3 + d) | 0;
                h4 = (h4 + e) | 0;
                h5 = (h5 + f) | 0;
                h6 = (h6 + g) | 0;
                h7 = (h7 + h) | 0;

                off += 64;
                len -= 64;
            }
        }

        blocks(m);

        let i, bytesLeft = m.length % 64,
        bitLenHi = (m.length / 0x20000000) | 0,
        bitLenLo = m.length << 3,
        numZeros = (bytesLeft < 56) ? 56 : 120,
        p = m.slice(m.length - bytesLeft, m.length);

        p.push(0x80);
        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }
        p.push((bitLenHi >>> 24) & 0xff);
        p.push((bitLenHi >>> 16) & 0xff);
        p.push((bitLenHi >>> 8)  & 0xff);
        p.push((bitLenHi >>> 0)  & 0xff);
        p.push((bitLenLo >>> 24) & 0xff);
        p.push((bitLenLo >>> 16) & 0xff);
        p.push((bitLenLo >>> 8)  & 0xff);
        p.push((bitLenLo >>> 0)  & 0xff);

        blocks(p);

        return [
            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,
            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,
            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,
            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,
            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,
            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,
            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,
            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff
        ];
    }

    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        // compress password if it's longer than hash block length
        password = (password.length <= 64) ? password : SHA256(password);

        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);

        let i;
        let dk = [];

        // inner = (password ^ ipad) || salt || counter
        for (i = 0; i < 64; i++) { inner[i] = 0x36; }
        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }
        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }
        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }

        // outerKey = password ^ opad
        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

        // increments counter inside inner
        function incrementCounter() {
            for (let i = innerLen - 1; i >= innerLen - 4; i--) {
                inner[i]++;
                if (inner[i] <= 0xff) return;
                inner[i] = 0;
            }
        }

        // output blocks = SHA256(outerKey || SHA256(inner)) ...
        while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
        }
        if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }

        return dk;
    }

    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;

        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r; i++) {
            blockxor(BY, i * 16, _X, 16);
            salsa20_8(_X, x);
            arraycopy(_X, 0, BY, Yi + (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
    }

    function R(a, b) {
        return (a << b) | (a >>> (32 - b));
    }

    function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);

        for (let i = 8; i > 0; i -= 2) {
            x[ 4] ^= R(x[ 0] + x[12], 7);
            x[ 8] ^= R(x[ 4] + x[ 0], 9);
            x[12] ^= R(x[ 8] + x[ 4], 13);
            x[ 0] ^= R(x[12] + x[ 8], 18);
            x[ 9] ^= R(x[ 5] + x[ 1], 7);
            x[13] ^= R(x[ 9] + x[ 5], 9);
            x[ 1] ^= R(x[13] + x[ 9], 13);
            x[ 5] ^= R(x[ 1] + x[13], 18);
            x[14] ^= R(x[10] + x[ 6], 7);
            x[ 2] ^= R(x[14] + x[10], 9);
            x[ 6] ^= R(x[ 2] + x[14], 13);
            x[10] ^= R(x[ 6] + x[ 2], 18);
            x[ 3] ^= R(x[15] + x[11], 7);
            x[ 7] ^= R(x[ 3] + x[15], 9);
            x[11] ^= R(x[ 7] + x[ 3], 13);
            x[15] ^= R(x[11] + x[ 7], 18);
            x[ 1] ^= R(x[ 0] + x[ 3], 7);
            x[ 2] ^= R(x[ 1] + x[ 0], 9);
            x[ 3] ^= R(x[ 2] + x[ 1], 13);
            x[ 0] ^= R(x[ 3] + x[ 2], 18);
            x[ 6] ^= R(x[ 5] + x[ 4], 7);
            x[ 7] ^= R(x[ 6] + x[ 5], 9);
            x[ 4] ^= R(x[ 7] + x[ 6], 13);
            x[ 5] ^= R(x[ 4] + x[ 7], 18);
            x[11] ^= R(x[10] + x[ 9], 7);
            x[ 8] ^= R(x[11] + x[10], 9);
            x[ 9] ^= R(x[ 8] + x[11], 13);
            x[10] ^= R(x[ 9] + x[ 8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }

        for (let i = 0; i < 16; ++i) {
            B[i] += x[i];
        }
    }

    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
        for (let i = 0; i < len; i++) {
            D[i] ^= S[Si + i]
        }
    }

    function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
            dest[destPos++] = src[srcPos++];
        }
    }

    function checkBufferish(o) {
        if (!o || typeof(o.length) !== 'number') { return false; }

        for (let i = 0; i < o.length; i++) {
            const v = o[i];
            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {
                return false;
            }
        }

        return true;
    }

    function ensureInteger(value, name) {
        if (typeof(value) !== "number" || (value % 1)) { throw new Error('invalid ' + name); }
        return value;
    }

    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {

        N = ensureInteger(N, 'N');
        r = ensureInteger(r, 'r');
        p = ensureInteger(p, 'p');

        dkLen = ensureInteger(dkLen, 'dkLen');

        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }

        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }
        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }

        if (!checkBufferish(password)) {
            throw new Error('password must be an array or buffer');
        }
        password = Array.prototype.slice.call(password);

        if (!checkBufferish(salt)) {
            throw new Error('salt must be an array or buffer');
        }
        salt = Array.prototype.slice.call(salt);

        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r)
        for (let i = 0; i < B.length; i++) {
            const j = i * 4;
            B[i] = ((b[j + 3] & 0xff) << 24) |
                   ((b[j + 2] & 0xff) << 16) |
                   ((b[j + 1] & 0xff) << 8) |
                   ((b[j + 0] & 0xff) << 0);
        }

        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);

        const Yi = 32 * r;

        // scratch space
        const x = new Uint32Array(16);       // salsa20_8
        const _X = new Uint32Array(16);      // blockmix_salsa8

        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;

        // Set this to true to abandon the scrypt on the next step
        let stop = false;

        // State information
        let state = 0;
        let i0 = 0, i1;
        let Bi;

        // How many blockmix_salsa8 can we do per step?
        const limit = callback ? parseInt(1000 / r): 0xffffffff;

        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;

        // This is really all I changed; making scryptsy a state machine so we occasionally
        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
        const incrementalSMix = function() {
            if (stop) {
                return callback(new Error('cancelled'), currentOp / totalOps);
            }

            let steps;

            switch (state) {
                case 0:
                    // for (var i = 0; i < p; i++)...
                    Bi = i0 * 32 * r;

                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1

                    state = 1;                                         // Move to ROMix 2
                    i1 = 0;

                    // Fall through

                case 1:

                    // Run up to 1000 steps of the first inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                  // ROMix - 2
                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi)         // ROMix - 3
                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4
                    }

                    // for (var i = 0; i < N; i++)
                    i1 += steps;
                    currentOp += steps;

                    if (callback) {
                        // Call the callback with the progress (optionally stopping us)
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    i1 = 0;                                          // Move to ROMix 6
                    state = 2;

                    // Fall through

                case 2:

                    // Run up to 1000 steps of the second inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                // ROMix - 6
                        const offset = (2 * r - 1) * 16;             // ROMix - 7
                        const j = XY[offset] & (N - 1);
                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)
                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)
                    }

                    // for (var i = 0; i < N; i++)...
                    i1 += steps;
                    currentOp += steps;

                    // Call the callback with the progress (optionally stopping us)
                    if (callback) {
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10

                    // for (var i = 0; i < p; i++)...
                    i0++;
                    if (i0 < p) {
                        state = 0;
                        break;
                    }

                    b = [];
                    for (let i = 0; i < B.length; i++) {
                        b.push((B[i] >>  0) & 0xff);
                        b.push((B[i] >>  8) & 0xff);
                        b.push((B[i] >> 16) & 0xff);
                        b.push((B[i] >> 24) & 0xff);
                    }

                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

                    // Send the result to the callback
                    if (callback) { callback(null, 1.0, derivedKey); }

                    // Done; don't break (which would reschedule)
                    return derivedKey;
            }

            // Schedule the next steps
            if (callback) { nextTick(incrementalSMix); }
        }

        // Run the smix state machine until completion
        if (!callback) {
            while (true) {
                const derivedKey = incrementalSMix();
                if (derivedKey != undefined) { return derivedKey; }
            }
        }

        // Bootstrap the async incremental smix
        incrementalSMix();
    }

    const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
                let lastProgress = 0;
                if (progressCallback) { progressCallback(0); }
                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
                    if (error) {
                        reject(error);
                    } else if (key) {
                        if (progressCallback && lastProgress !== 1) {
                            progressCallback(1);
                        }
                        resolve(new Uint8Array(key));
                    } else if (progressCallback && progress !== lastProgress) {
                        lastProgress = progress;
                        return progressCallback(progress);
                    }
                });
            });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
    };

    // node.js
    if (typeof(exports) !== 'undefined') {
       module.exports = lib;

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else if (typeof(define) === 'function' && define.amd) {
        define(lib);

    // Web Browsers
    } else if (root) {

        // If there was an existing library "scrypt", make sure it is still available
        if (root.scrypt) {
            root._scrypt = root.scrypt;
        }

        root.scrypt = lib;
    }

})(this);

}).call(this)}).call(this,require("timers").setImmediate)
},{"timers":26}],265:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":263}],266:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":267,"./sha1":268,"./sha224":269,"./sha256":270,"./sha384":271,"./sha512":272}],267:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":265,"inherits":235,"safe-buffer":263}],268:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":265,"inherits":235,"safe-buffer":263}],269:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":265,"./sha256":270,"inherits":235,"safe-buffer":263}],270:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":265,"inherits":235,"safe-buffer":263}],271:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":265,"./sha512":272,"inherits":235,"safe-buffer":263}],272:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":265,"inherits":235,"safe-buffer":263}],273:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
// The default Buffer size if one is not provided.
const DEFAULT_SMARTBUFFER_SIZE = 4096;
// The default string encoding to use for reading/writing strings.
const DEFAULT_SMARTBUFFER_ENCODING = 'utf8';
class SmartBuffer {
    /**
     * Creates a new SmartBuffer instance.
     *
     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
     */
    constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (SmartBuffer.isSmartBufferOptions(options)) {
            // Checks for encoding
            if (options.encoding) {
                utils_1.checkEncoding(options.encoding);
                this._encoding = options.encoding;
            }
            // Checks for initial size length
            if (options.size) {
                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
                    this._buff = Buffer.allocUnsafe(options.size);
                }
                else {
                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
                }
                // Check for initial Buffer
            }
            else if (options.buff) {
                if (Buffer.isBuffer(options.buff)) {
                    this._buff = options.buff;
                    this.length = options.buff.length;
                }
                else {
                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
                }
            }
            else {
                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
            }
        }
        else {
            // If something was passed but it's not a SmartBufferOptions object
            if (typeof options !== 'undefined') {
                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
            }
            // Otherwise default to sane options
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
    }
    /**
     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
     *
     * @param size { Number } The size of the internal Buffer.
     * @param encoding { String } The BufferEncoding to use for strings.
     *
     * @return { SmartBuffer }
     */
    static fromSize(size, encoding) {
        return new this({
            size: size,
            encoding: encoding
        });
    }
    /**
     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
     *
     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
     * @param encoding { String } The BufferEncoding to use for strings.
     *
     * @return { SmartBuffer }
     */
    static fromBuffer(buff, encoding) {
        return new this({
            buff: buff,
            encoding: encoding
        });
    }
    /**
     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
     *
     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
     */
    static fromOptions(options) {
        return new this(options);
    }
    /**
     * Type checking function that determines if an object is a SmartBufferOptions object.
     */
    static isSmartBufferOptions(options) {
        const castOptions = options;
        return (castOptions &&
            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));
    }
    // Signed integers
    /**
     * Reads an Int8 value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
    }
    /**
     * Reads an Int16BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
    }
    /**
     * Reads an Int16LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
    }
    /**
     * Reads an Int32BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
    }
    /**
     * Reads an Int32LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
    }
    /**
     * Reads a BigInt64BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
    }
    /**
     * Reads a BigInt64LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
    }
    /**
     * Writes an Int8 value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
    }
    /**
     * Inserts an Int8 value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
    }
    /**
     * Writes an Int16BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
    }
    /**
     * Inserts an Int16BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
    }
    /**
     * Writes an Int16LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
    }
    /**
     * Inserts an Int16LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
    }
    /**
     * Writes an Int32BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
    }
    /**
     * Inserts an Int32BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
    }
    /**
     * Writes an Int32LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
    }
    /**
     * Inserts an Int32LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
    }
    /**
     * Writes a BigInt64BE value to the current write position (or at optional offset).
     *
     * @param value { BigInt } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
    }
    /**
     * Inserts a BigInt64BE value at the given offset value.
     *
     * @param value { BigInt } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
    }
    /**
     * Writes a BigInt64LE value to the current write position (or at optional offset).
     *
     * @param value { BigInt } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
    }
    /**
     * Inserts a Int64LE value at the given offset value.
     *
     * @param value { BigInt } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
    }
    // Unsigned Integers
    /**
     * Reads an UInt8 value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
    }
    /**
     * Reads an UInt16BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
    }
    /**
     * Reads an UInt16LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
    }
    /**
     * Reads an UInt32BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
    }
    /**
     * Reads an UInt32LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
    }
    /**
     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
    }
    /**
     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { BigInt }
     */
    readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
    }
    /**
     * Writes an UInt8 value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
    }
    /**
     * Inserts an UInt8 value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
    }
    /**
     * Writes an UInt16BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
    }
    /**
     * Inserts an UInt16BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
    }
    /**
     * Writes an UInt16LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
    }
    /**
     * Inserts an UInt16LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
    }
    /**
     * Writes an UInt32BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
    }
    /**
     * Inserts an UInt32BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
    }
    /**
     * Writes an UInt32LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
    }
    /**
     * Inserts an UInt32LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
    }
    /**
     * Writes a BigUInt64BE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
    }
    /**
     * Inserts a BigUInt64BE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
    }
    /**
     * Writes a BigUInt64LE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
    }
    /**
     * Inserts a BigUInt64LE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
    }
    // Floating Point
    /**
     * Reads an FloatBE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
    }
    /**
     * Reads an FloatLE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
    }
    /**
     * Writes a FloatBE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
    }
    /**
     * Inserts a FloatBE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
    }
    /**
     * Writes a FloatLE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
    }
    /**
     * Inserts a FloatLE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
    }
    // Double Floating Point
    /**
     * Reads an DoublEBE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
    }
    /**
     * Reads an DoubleLE value from the current read position or an optionally provided offset.
     *
     * @param offset { Number } The offset to read data from (optional)
     * @return { Number }
     */
    readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
    }
    /**
     * Writes a DoubleBE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
    }
    /**
     * Inserts a DoubleBE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
    }
    /**
     * Writes a DoubleLE value to the current write position (or at optional offset).
     *
     * @param value { Number } The value to write.
     * @param offset { Number } The offset to write the value at.
     *
     * @return this
     */
    writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
    }
    /**
     * Inserts a DoubleLE value at the given offset value.
     *
     * @param value { Number } The value to insert.
     * @param offset { Number } The offset to insert the value at.
     *
     * @return this
     */
    insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
    }
    // Strings
    /**
     * Reads a String from the current read position.
     *
     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
     *             the string (Defaults to instance level encoding).
     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
     *
     * @return { String }
     */
    readString(arg1, encoding) {
        let lengthVal;
        // Length provided
        if (typeof arg1 === 'number') {
            utils_1.checkLengthValue(arg1);
            lengthVal = Math.min(arg1, this.length - this._readOffset);
        }
        else {
            encoding = arg1;
            lengthVal = this.length - this._readOffset;
        }
        // Check encoding
        if (typeof encoding !== 'undefined') {
            utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
    }
    /**
     * Inserts a String
     *
     * @param value { String } The String value to insert.
     * @param offset { Number } The offset to insert the string at.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
    }
    /**
     * Writes a String
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
    }
    /**
     * Reads a null-terminated String from the current read position.
     *
     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
     *
     * @return { String }
     */
    readStringNT(encoding) {
        if (typeof encoding !== 'undefined') {
            utils_1.checkEncoding(encoding);
        }
        // Set null character position to the end SmartBuffer instance.
        let nullPos = this.length;
        // Find next null character (if one is not found, default from above is used)
        for (let i = this._readOffset; i < this.length; i++) {
            if (this._buff[i] === 0x00) {
                nullPos = i;
                break;
            }
        }
        // Read string value
        const value = this._buff.slice(this._readOffset, nullPos);
        // Increment internal Buffer read offset
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
    }
    /**
     * Inserts a null-terminated String.
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        // Write Values
        this.insertString(value, offset, encoding);
        this.insertUInt8(0x00, offset + value.length);
        return this;
    }
    /**
     * Writes a null-terminated String.
     *
     * @param value { String } The String value to write.
     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     *
     * @return this
     */
    writeStringNT(value, arg2, encoding) {
        // Write Values
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);
        return this;
    }
    // Buffers
    /**
     * Reads a Buffer from the internal read position.
     *
     * @param length { Number } The length of data to read as a Buffer.
     *
     * @return { Buffer }
     */
    readBuffer(length) {
        if (typeof length !== 'undefined') {
            utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === 'number' ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        // Read buffer value
        const value = this._buff.slice(this._readOffset, endPoint);
        // Increment internal Buffer read offset
        this._readOffset = endPoint;
        return value;
    }
    /**
     * Writes a Buffer to the current write position.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
    }
    /**
     * Writes a Buffer to the current write position.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
    }
    /**
     * Reads a null-terminated Buffer from the current read poisiton.
     *
     * @return { Buffer }
     */
    readBufferNT() {
        // Set null character position to the end SmartBuffer instance.
        let nullPos = this.length;
        // Find next null character (if one is not found, default from above is used)
        for (let i = this._readOffset; i < this.length; i++) {
            if (this._buff[i] === 0x00) {
                nullPos = i;
                break;
            }
        }
        // Read value
        const value = this._buff.slice(this._readOffset, nullPos);
        // Increment internal Buffer read offset
        this._readOffset = nullPos + 1;
        return value;
    }
    /**
     * Inserts a null-terminated Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        // Write Values
        this.insertBuffer(value, offset);
        this.insertUInt8(0x00, offset + value.length);
        return this;
    }
    /**
     * Writes a null-terminated Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     *
     * @return this
     */
    writeBufferNT(value, offset) {
        // Checks for valid numberic value;
        if (typeof offset !== 'undefined') {
            utils_1.checkOffsetValue(offset);
        }
        // Write Values
        this.writeBuffer(value, offset);
        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);
        return this;
    }
    /**
     * Clears the SmartBuffer instance to its original empty state.
     */
    clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
    }
    /**
     * Gets the remaining data left to be read from the SmartBuffer instance.
     *
     * @return { Number }
     */
    remaining() {
        return this.length - this._readOffset;
    }
    /**
     * Gets the current read offset value of the SmartBuffer instance.
     *
     * @return { Number }
     */
    get readOffset() {
        return this._readOffset;
    }
    /**
     * Sets the read offset value of the SmartBuffer instance.
     *
     * @param offset { Number } - The offset value to set.
     */
    set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        // Check for bounds.
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
    }
    /**
     * Gets the current write offset value of the SmartBuffer instance.
     *
     * @return { Number }
     */
    get writeOffset() {
        return this._writeOffset;
    }
    /**
     * Sets the write offset value of the SmartBuffer instance.
     *
     * @param offset { Number } - The offset value to set.
     */
    set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        // Check for bounds.
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
    }
    /**
     * Gets the currently set string encoding of the SmartBuffer instance.
     *
     * @return { BufferEncoding } The string Buffer encoding currently set.
     */
    get encoding() {
        return this._encoding;
    }
    /**
     * Sets the string encoding of the SmartBuffer instance.
     *
     * @param encoding { BufferEncoding } The string Buffer encoding to set.
     */
    set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
    }
    /**
     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
     *
     * @return { Buffer } The Buffer value.
     */
    get internalBuffer() {
        return this._buff;
    }
    /**
     * Gets the value of the internal managed Buffer (Includes managed data only)
     *
     * @param { Buffer }
     */
    toBuffer() {
        return this._buff.slice(0, this.length);
    }
    /**
     * Gets the String value of the internal managed Buffer
     *
     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
     */
    toString(encoding) {
        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;
        // Check for invalid encoding.
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
    }
    /**
     * Destroys the SmartBuffer instance.
     */
    destroy() {
        this.clear();
        return this;
    }
    /**
     * Handles inserting and writing strings.
     *
     * @param value { String } The String value to insert.
     * @param isInsert { Boolean } True if inserting a string, false if writing.
     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
     */
    _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        // Check for offset
        if (typeof arg3 === 'number') {
            offsetVal = arg3;
            // Check for encoding
        }
        else if (typeof arg3 === 'string') {
            utils_1.checkEncoding(arg3);
            encodingVal = arg3;
        }
        // Check for encoding (third param)
        if (typeof encoding === 'string') {
            utils_1.checkEncoding(encoding);
            encodingVal = encoding;
        }
        // Calculate bytelength of string.
        const byteLength = Buffer.byteLength(value, encodingVal);
        // Ensure there is enough internal Buffer capacity.
        if (isInsert) {
            this.ensureInsertable(byteLength, offsetVal);
        }
        else {
            this._ensureWriteable(byteLength, offsetVal);
        }
        // Write value
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        // Increment internal Buffer write offset;
        if (isInsert) {
            this._writeOffset += byteLength;
        }
        else {
            // If an offset was given, check to see if we wrote beyond the current writeOffset.
            if (typeof arg3 === 'number') {
                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
            }
            else {
                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.
                this._writeOffset += byteLength;
            }
        }
        return this;
    }
    /**
     * Handles writing or insert of a Buffer.
     *
     * @param value { Buffer } The Buffer to write.
     * @param offset { Number } The offset to write the Buffer to.
     */
    _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;
        // Ensure there is enough internal Buffer capacity.
        if (isInsert) {
            this.ensureInsertable(value.length, offsetVal);
        }
        else {
            this._ensureWriteable(value.length, offsetVal);
        }
        // Write buffer value
        value.copy(this._buff, offsetVal);
        // Increment internal Buffer write offset;
        if (isInsert) {
            this._writeOffset += value.length;
        }
        else {
            // If an offset was given, check to see if we wrote beyond the current writeOffset.
            if (typeof offset === 'number') {
                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
            }
            else {
                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.
                this._writeOffset += value.length;
            }
        }
        return this;
    }
    /**
     * Ensures that the internal Buffer is large enough to read data.
     *
     * @param length { Number } The length of the data that needs to be read.
     * @param offset { Number } The offset of the data that needs to be read.
     */
    ensureReadable(length, offset) {
        // Offset value defaults to managed read offset.
        let offsetVal = this._readOffset;
        // If an offset was provided, use it.
        if (typeof offset !== 'undefined') {
            // Checks for valid numberic value;
            utils_1.checkOffsetValue(offset);
            // Overide with custom offset.
            offsetVal = offset;
        }
        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.
        if (offsetVal < 0 || offsetVal + length > this.length) {
            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
    }
    /**
     * Ensures that the internal Buffer is large enough to insert data.
     *
     * @param dataLength { Number } The length of the data that needs to be written.
     * @param offset { Number } The offset of the data to be written.
     */
    ensureInsertable(dataLength, offset) {
        // Checks for valid numberic value;
        utils_1.checkOffsetValue(offset);
        // Ensure there is enough internal Buffer capacity.
        this._ensureCapacity(this.length + dataLength);
        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.
        if (offset < this.length) {
            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        // Adjust tracked smart buffer length
        if (offset + dataLength > this.length) {
            this.length = offset + dataLength;
        }
        else {
            this.length += dataLength;
        }
    }
    /**
     * Ensures that the internal Buffer is large enough to write data.
     *
     * @param dataLength { Number } The length of the data that needs to be written.
     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
     */
    _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;
        // Ensure enough capacity to write data.
        this._ensureCapacity(offsetVal + dataLength);
        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)
        if (offsetVal + dataLength > this.length) {
            this.length = offsetVal + dataLength;
        }
    }
    /**
     * Ensures that the internal Buffer is large enough to write at least the given amount of data.
     *
     * @param minLength { Number } The minimum length of the data needs to be written.
     */
    _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
            let data = this._buff;
            let newLength = (oldLength * 3) / 2 + 1;
            if (newLength < minLength) {
                newLength = minLength;
            }
            this._buff = Buffer.allocUnsafe(newLength);
            data.copy(this._buff, 0, 0, oldLength);
        }
    }
    /**
     * Reads a numeric number value using the provided function.
     *
     * @typeparam T { number | bigint } The type of the value to be read
     *
     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes read.
     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
     *
     * @returns { T } the number value
     */
    _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        // Call Buffer.readXXXX();
        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);
        // Adjust internal read offset if an optional read offset was not provided.
        if (typeof offset === 'undefined') {
            this._readOffset += byteSize;
        }
        return value;
    }
    /**
     * Inserts a numeric number value based on the given offset and value.
     *
     * @typeparam T { number | bigint } The type of the value to be written
     *
     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes written.
     * @param value { T } The number value to write.
     * @param offset { Number } the offset to write the number at (REQUIRED).
     *
     * @returns SmartBuffer this buffer
     */
    _insertNumberValue(func, byteSize, value, offset) {
        // Check for invalid offset values.
        utils_1.checkOffsetValue(offset);
        // Ensure there is enough internal Buffer capacity. (raw offset is passed)
        this.ensureInsertable(byteSize, offset);
        // Call buffer.writeXXXX();
        func.call(this._buff, value, offset);
        // Adjusts internally managed write offset.
        this._writeOffset += byteSize;
        return this;
    }
    /**
     * Writes a numeric number value based on the given offset and value.
     *
     * @typeparam T { number | bigint } The type of the value to be written
     *
     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
     * @param byteSize { Number } The number of bytes written.
     * @param value { T } The number value to write.
     * @param offset { Number } the offset to write the number at (REQUIRED).
     *
     * @returns SmartBuffer this buffer
     */
    _writeNumberValue(func, byteSize, value, offset) {
        // If an offset was provided, validate it.
        if (typeof offset === 'number') {
            // Check if we're writing beyond the bounds of the managed data.
            if (offset < 0) {
                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
            }
            utils_1.checkOffsetValue(offset);
        }
        // Default to writeOffset if no offset value was given.
        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;
        // Ensure there is enough internal Buffer capacity. (raw offset is passed)
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        // If an offset was given, check to see if we wrote beyond the current writeOffset.
        if (typeof offset === 'number') {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        }
        else {
            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.
            this._writeOffset += byteSize;
        }
        return this;
    }
}
exports.SmartBuffer = SmartBuffer;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./utils":274,"buffer":3}],274:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
/**
 * Error strings
 */
const ERRORS = {
    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',
    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',
    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',
    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',
    INVALID_OFFSET: 'An invalid offset value was provided.',
    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',
    INVALID_LENGTH: 'An invalid length value was provided.',
    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',
    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',
    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',
    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',
    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'
};
exports.ERRORS = ERRORS;
/**
 * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)
 *
 * @param { String } encoding The encoding string to check.
 */
function checkEncoding(encoding) {
    if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
    }
}
exports.checkEncoding = checkEncoding;
/**
 * Checks if a given number is a finite integer. (Throws an exception if check fails)
 *
 * @param { Number } value The number value to check.
 */
function isFiniteInteger(value) {
    return typeof value === 'number' && isFinite(value) && isInteger(value);
}
exports.isFiniteInteger = isFiniteInteger;
/**
 * Checks if an offset/length value is valid. (Throws an exception if check fails)
 *
 * @param value The value to check.
 * @param offset True if checking an offset, false if checking a length.
 */
function checkOffsetOrLengthValue(value, offset) {
    if (typeof value === 'number') {
        // Check for non finite/non integers
        if (!isFiniteInteger(value) || value < 0) {
            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
    }
    else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
    }
}
/**
 * Checks if a length value is valid. (Throws an exception if check fails)
 *
 * @param { Number } length The value to check.
 */
function checkLengthValue(length) {
    checkOffsetOrLengthValue(length, false);
}
exports.checkLengthValue = checkLengthValue;
/**
 * Checks if a offset value is valid. (Throws an exception if check fails)
 *
 * @param { Number } offset The value to check.
 */
function checkOffsetValue(offset) {
    checkOffsetOrLengthValue(offset, true);
}
exports.checkOffsetValue = checkOffsetValue;
/**
 * Checks if a target offset value is out of bounds. (Throws an exception if check fails)
 *
 * @param { Number } offset The offset value to check.
 * @param { SmartBuffer } buff The SmartBuffer instance to check against.
 */
function checkTargetOffset(offset, buff) {
    if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
    }
}
exports.checkTargetOffset = checkTargetOffset;
/**
 * Determines whether a given number is a integer.
 * @param value The number to check.
 */
function isInteger(value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
}
/**
 * Throws if Node.js version is too low to support bigint
 */
function bigIntAndBufferInt64Check(bufferMethod) {
    if (typeof BigInt === 'undefined') {
        throw new Error('Platform does not support JS BigInt type.');
    }
    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
    }
}
exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;

},{"buffer":3}],275:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"safe-buffer":263}],276:[function(require,module,exports){
(function (Buffer){(function (){
const BN = require('bn.js')
const EC = require('elliptic').ec
const secp256k1 = new EC('secp256k1')
const deterministicGenerateK = require('./rfc6979')

const ZERO32 = Buffer.alloc(32, 0)
const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')
const EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')

const n = secp256k1.curve.n
const nDiv2 = n.shrn(1)
const G = secp256k1.curve.g

const THROW_BAD_PRIVATE = 'Expected Private'
const THROW_BAD_POINT = 'Expected Point'
const THROW_BAD_TWEAK = 'Expected Tweak'
const THROW_BAD_HASH = 'Expected Hash'
const THROW_BAD_SIGNATURE = 'Expected Signature'
const THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'

function isScalar (x) {
  return Buffer.isBuffer(x) && x.length === 32
}

function isOrderScalar (x) {
  if (!isScalar(x)) return false
  return x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isPoint (p) {
  if (!Buffer.isBuffer(p)) return false
  if (p.length < 33) return false

  const t = p[0]
  const x = p.slice(1, 33)
  if (x.compare(ZERO32) === 0) return false
  if (x.compare(EC_P) >= 0) return false
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary
    return true
  }

  const y = p.slice(33)
  if (y.compare(ZERO32) === 0) return false
  if (y.compare(EC_P) >= 0) return false
  if (t === 0x04 && p.length === 65) return true
  return false
}

function __isPointCompressed (p) {
  return p[0] !== 0x04
}

function isPointCompressed (p) {
  if (!isPoint(p)) return false
  return __isPointCompressed(p)
}

function isPrivate (x) {
  if (!isScalar(x)) return false
  return x.compare(ZERO32) > 0 && // > 0
    x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isSignature (value) {
  const r = value.slice(0, 32)
  const s = value.slice(32, 64)
  return Buffer.isBuffer(value) && value.length === 64 &&
    r.compare(EC_GROUP_ORDER) < 0 &&
    s.compare(EC_GROUP_ORDER) < 0
}

function assumeCompression (value, pubkey) {
  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)
  if (value === undefined) return true
  return value
}

function fromBuffer (d) { return new BN(d) }
function toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }
function decodeFrom (P) { return secp256k1.curve.decodePoint(P) }
function getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }

function pointAdd (pA, pB, __compressed) {
  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)
  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)

  const a = decodeFrom(pA)
  const b = decodeFrom(pB)
  const pp = a.add(b)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed, pA)
  return getEncoded(pp, compressed)
}

function pointAddScalar (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)

  const tt = fromBuffer(tweak)
  const qq = G.mul(tt)
  const uu = pp.add(qq)
  if (uu.isInfinity()) return null

  return getEncoded(uu, compressed)
}

function pointCompress (p, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)

  const pp = decodeFrom(p)
  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)

  const compressed = assumeCompression(__compressed, p)

  return getEncoded(pp, compressed)
}

function pointFromScalar (d, __compressed) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)

  const dd = fromBuffer(d)
  const pp = G.mul(dd)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed)
  return getEncoded(pp, compressed)
}

function pointMultiply (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  const tt = fromBuffer(tweak)
  const qq = pp.mul(tt)
  if (qq.isInfinity()) return null

  return getEncoded(qq, compressed)
}

function privateAdd (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.add(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function privateSub (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.sub(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function sign (hash, x) {
  return __sign(hash, x)
}

function signWithEntropy (hash, x, addData) {
  return __sign(hash, x, addData)
}

function __sign (hash, x, addData) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)
  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)

  const d = fromBuffer(x)
  const e = fromBuffer(hash)

  let r, s
  const checkSig = function (k) {
    const kI = fromBuffer(k)
    const Q = G.mul(kI)

    if (Q.isInfinity()) return false

    r = Q.x.umod(n)
    if (r.isZero() === 0) return false

    s = kI
      .invm(n)
      .mul(e.add(d.mul(r)))
      .umod(n)
    if (s.isZero() === 0) return false

    return true
  }

  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.cmp(nDiv2) > 0) {
    s = n.sub(s)
  }

  const buffer = Buffer.allocUnsafe(64)
  toBuffer(r).copy(buffer, 0)
  toBuffer(s).copy(buffer, 32)
  return buffer
}

function verify (hash, q, signature, strict) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (1, isSignature enforces '< n - 1')
  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)

  const Q = decodeFrom(q)
  const r = fromBuffer(signature.slice(0, 32))
  const s = fromBuffer(signature.slice(32, 64))

  if (strict && s.cmp(nDiv2) > 0) {
    return false
  }

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (2, enforces '> 0')
  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false
  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false

  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  const e = fromBuffer(hash)

  // Compute s^-1
  const sInv = s.invm(n)

  // 1.4.4 Compute u1 = es^1 mod n
  //               u2 = rs^1 mod n
  const u1 = e.mul(sInv).umod(n)
  const u2 = r.mul(sInv).umod(n)

  // 1.4.5 Compute R = (xR, yR)
  //               R = u1G + u2Q
  const R = G.mulAdd(u1, Q, u2)

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (R.isInfinity()) return false

  // 1.4.6 Convert the field element R.x to an integer
  const xR = R.x

  // 1.4.7 Set v = xR mod n
  const v = xR.umod(n)

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.eq(r)
}

module.exports = {
  isPoint,
  isPointCompressed,
  isPrivate,
  pointAdd,
  pointAddScalar,
  pointCompress,
  pointFromScalar,
  pointMultiply,
  privateAdd,
  privateSub,
  sign,
  signWithEntropy,
  verify
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./rfc6979":277,"bn.js":175,"buffer":3,"elliptic":204}],277:[function(require,module,exports){
(function (Buffer){(function (){
const createHmac = require('create-hmac')

const ONE1 = Buffer.alloc(1, 1)
const ZERO1 = Buffer.alloc(1, 0)

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {
  // Step A, ignored as hash already provided
  // Step B
  // Step C
  let k = Buffer.alloc(32, 0)
  let v = Buffer.alloc(32, 1)

  // Step D
  k = createHmac('sha256', k)
    .update(v)
    .update(ZERO1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step E
  v = createHmac('sha256', k).update(v).digest()

  // Step F
  k = createHmac('sha256', k)
    .update(v)
    .update(ONE1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step G
  v = createHmac('sha256', k).update(v).digest()

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = createHmac('sha256', k).update(v).digest()

  let T = v

  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
  while (!isPrivate(T) || !checkSig(T)) {
    k = createHmac('sha256', k)
      .update(v)
      .update(ZERO1)
      .digest()

    v = createHmac('sha256', k).update(v).digest()

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = createHmac('sha256', k).update(v).digest()
    T = v
  }

  return T
}

module.exports = deterministicGenerateK

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3,"create-hmac":201}],278:[function(require,module,exports){
var native = require('./native')

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}

},{"./native":281}],279:[function(require,module,exports){
(function (Buffer){(function (){
var NATIVE = require('./native')
var ERRORS = require('./errors')

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

}).call(this)}).call(this,{"isBuffer":require("../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js":7,"./errors":278,"./native":281}],280:[function(require,module,exports){
var ERRORS = require('./errors')
var NATIVE = require('./native')

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = require('./extra')
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce

},{"./errors":278,"./extra":279,"./native":281}],281:[function(require,module,exports){
var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

},{}],282:[function(require,module,exports){
(function (global){(function (){
/**
 *
 *
 * @author Jerry Bendy <jerry@icewingcc.com>
 * @licence MIT
 *
 */

(function(self) {
    'use strict';

    var nativeURLSearchParams = (function() {
            // #41 Fix issue in RN
            try {
                if (self.URLSearchParams && (new self.URLSearchParams('foo=bar')).get('foo') === 'bar') {
                    return self.URLSearchParams;
                }
            } catch (e) {}
            return null;
        })(),
        isSupportObjectConstructor = nativeURLSearchParams && (new nativeURLSearchParams({a: 1})).toString() === 'a=1',
        // There is a bug in safari 10.1 (and earlier) that incorrectly decodes `%2B` as an empty space and not a plus.
        decodesPlusesCorrectly = nativeURLSearchParams && (new nativeURLSearchParams('s=%2B').get('s') === '+'),
        __URLSearchParams__ = "__URLSearchParams__",
        // Fix bug in Edge which cannot encode ' &' correctly
        encodesAmpersandsCorrectly = nativeURLSearchParams ? (function() {
            var ampersandTest = new nativeURLSearchParams();
            ampersandTest.append('s', ' &');
            return ampersandTest.toString() === 's=+%26';
        })() : true,
        prototype = URLSearchParamsPolyfill.prototype,
        iterable = !!(self.Symbol && self.Symbol.iterator);

    if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
        return;
    }


    /**
     * Make a URLSearchParams instance
     *
     * @param {object|string|URLSearchParams} search
     * @constructor
     */
    function URLSearchParamsPolyfill(search) {
        search = search || "";

        // support construct object with another URLSearchParams instance
        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
            search = search.toString();
        }
        this [__URLSearchParams__] = parseToDict(search);
    }


    /**
     * Appends a specified key/value pair as a new search parameter.
     *
     * @param {string} name
     * @param {string} value
     */
    prototype.append = function(name, value) {
        appendTo(this [__URLSearchParams__], name, value);
    };

    /**
     * Deletes the given search parameter, and its associated value,
     * from the list of all search parameters.
     *
     * @param {string} name
     */
    prototype['delete'] = function(name) {
        delete this [__URLSearchParams__] [name];
    };

    /**
     * Returns the first value associated to the given search parameter.
     *
     * @param {string} name
     * @returns {string|null}
     */
    prototype.get = function(name) {
        var dict = this [__URLSearchParams__];
        return this.has(name) ? dict[name][0] : null;
    };

    /**
     * Returns all the values association with a given search parameter.
     *
     * @param {string} name
     * @returns {Array}
     */
    prototype.getAll = function(name) {
        var dict = this [__URLSearchParams__];
        return this.has(name) ? dict [name].slice(0) : [];
    };

    /**
     * Returns a Boolean indicating if such a search parameter exists.
     *
     * @param {string} name
     * @returns {boolean}
     */
    prototype.has = function(name) {
        return hasOwnProperty(this [__URLSearchParams__], name);
    };

    /**
     * Sets the value associated to a given search parameter to
     * the given value. If there were several values, delete the
     * others.
     *
     * @param {string} name
     * @param {string} value
     */
    prototype.set = function set(name, value) {
        this [__URLSearchParams__][name] = ['' + value];
    };

    /**
     * Returns a string containg a query string suitable for use in a URL.
     *
     * @returns {string}
     */
    prototype.toString = function() {
        var dict = this[__URLSearchParams__], query = [], i, key, name, value;
        for (key in dict) {
            name = encode(key);
            for (i = 0, value = dict[key]; i < value.length; i++) {
                query.push(name + '=' + encode(value[i]));
            }
        }
        return query.join('&');
    };

    // There is a bug in Safari 10.1 and `Proxy`ing it is not enough.
    var forSureUsePolyfill = !decodesPlusesCorrectly;
    var useProxy = (!forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self.Proxy);
    var propValue; 
    if (useProxy) {
        // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0
        propValue = new Proxy(nativeURLSearchParams, {
            construct: function (target, args) {
                return new target((new URLSearchParamsPolyfill(args[0]).toString()));
            }
        })
        // Chrome <=60 .toString() on a function proxy got error "Function.prototype.toString is not generic"
        propValue.toString = Function.prototype.toString.bind(URLSearchParamsPolyfill);
    } else {
        propValue = URLSearchParamsPolyfill;
    }
    /*
     * Apply polifill to global object and append other prototype into it
     */
    Object.defineProperty(self, 'URLSearchParams', {
        value: propValue
    });

    var USPProto = self.URLSearchParams.prototype;

    USPProto.polyfill = true;

    /**
     *
     * @param {function} callback
     * @param {object} thisArg
     */
    USPProto.forEach = USPProto.forEach || function(callback, thisArg) {
        var dict = parseToDict(this.toString());
        Object.getOwnPropertyNames(dict).forEach(function(name) {
            dict[name].forEach(function(value) {
                callback.call(thisArg, value, name, this);
            }, this);
        }, this);
    };

    /**
     * Sort all name-value pairs
     */
    USPProto.sort = USPProto.sort || function() {
        var dict = parseToDict(this.toString()), keys = [], k, i, j;
        for (k in dict) {
            keys.push(k);
        }
        keys.sort();

        for (i = 0; i < keys.length; i++) {
            this['delete'](keys[i]);
        }
        for (i = 0; i < keys.length; i++) {
            var key = keys[i], values = dict[key];
            for (j = 0; j < values.length; j++) {
                this.append(key, values[j]);
            }
        }
    };

    /**
     * Returns an iterator allowing to go through all keys of
     * the key/value pairs contained in this object.
     *
     * @returns {function}
     */
    USPProto.keys = USPProto.keys || function() {
        var items = [];
        this.forEach(function(item, name) {
            items.push(name);
        });
        return makeIterator(items);
    };

    /**
     * Returns an iterator allowing to go through all values of
     * the key/value pairs contained in this object.
     *
     * @returns {function}
     */
    USPProto.values = USPProto.values || function() {
        var items = [];
        this.forEach(function(item) {
            items.push(item);
        });
        return makeIterator(items);
    };

    /**
     * Returns an iterator allowing to go through all key/value
     * pairs contained in this object.
     *
     * @returns {function}
     */
    USPProto.entries = USPProto.entries || function() {
        var items = [];
        this.forEach(function(item, name) {
            items.push([name, item]);
        });
        return makeIterator(items);
    };


    if (iterable) {
        USPProto[self.Symbol.iterator] = USPProto[self.Symbol.iterator] || USPProto.entries;
    }


    function encode(str) {
        var replace = {
            '!': '%21',
            "'": '%27',
            '(': '%28',
            ')': '%29',
            '~': '%7E',
            '%20': '+',
            '%00': '\x00'
        };
        return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function(match) {
            return replace[match];
        });
    }

    function decode(str) {
        return str
            .replace(/[ +]/g, '%20')
            .replace(/(%[a-f0-9]{2})+/ig, function(match) {
                return decodeURIComponent(match);
            });
    }

    function makeIterator(arr) {
        var iterator = {
            next: function() {
                var value = arr.shift();
                return {done: value === undefined, value: value};
            }
        };

        if (iterable) {
            iterator[self.Symbol.iterator] = function() {
                return iterator;
            };
        }

        return iterator;
    }

    function parseToDict(search) {
        var dict = {};

        if (typeof search === "object") {
            // if `search` is an array, treat it as a sequence
            if (isArray(search)) {
                for (var i = 0; i < search.length; i++) {
                    var item = search[i];
                    if (isArray(item) && item.length === 2) {
                        appendTo(dict, item[0], item[1]);
                    } else {
                        throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
                    }
                }

            } else {
                for (var key in search) {
                    if (search.hasOwnProperty(key)) {
                        appendTo(dict, key, search[key]);
                    }
                }
            }

        } else {
            // remove first '?'
            if (search.indexOf("?") === 0) {
                search = search.slice(1);
            }

            var pairs = search.split("&");
            for (var j = 0; j < pairs.length; j++) {
                var value = pairs [j],
                    index = value.indexOf('=');

                if (-1 < index) {
                    appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));

                } else {
                    if (value) {
                        appendTo(dict, decode(value), '');
                    }
                }
            }
        }

        return dict;
    }

    function appendTo(dict, name, value) {
        var val = typeof value === 'string' ? value : (
            value !== null && value !== undefined && typeof value.toString === 'function' ? value.toString() : JSON.stringify(value)
        );

        // #47 Prevent using `hasOwnProperty` as a property name
        if (hasOwnProperty(dict, name)) {
            dict[name].push(val);
        } else {
            dict[name] = [val];
        }
    }

    function isArray(val) {
        return !!val && '[object Array]' === Object.prototype.toString.call(val);
    }

    function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    }

})(typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],283:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],284:[function(require,module,exports){
(function (Buffer){(function (){
var bs58check = require('bs58check')

function decodeRaw (buffer, version) {
  // check version only if defined
  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')

  // uncompressed
  if (buffer.length === 33) {
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: false
    }
  }

  // invalid length
  if (buffer.length !== 34) throw new Error('Invalid WIF length')

  // invalid compression flag
  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')

  return {
    version: buffer[0],
    privateKey: buffer.slice(1, 33),
    compressed: true
  }
}

function encodeRaw (version, privateKey, compressed) {
  var result = new Buffer(compressed ? 34 : 33)

  result.writeUInt8(version, 0)
  privateKey.copy(result, 1)

  if (compressed) {
    result[33] = 0x01
  }

  return result
}

function decode (string, version) {
  return decodeRaw(bs58check.decode(string), version)
}

function encode (version, privateKey, compressed) {
  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))

  return bs58check.encode(
    encodeRaw(
      version.version,
      version.privateKey,
      version.compressed
    )
  )
}

module.exports = {
  decode: decode,
  decodeRaw: decodeRaw,
  encode: encode,
  encodeRaw: encodeRaw
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bs58check":196,"buffer":3}],285:[function(require,module,exports){
(function (Buffer){(function (){
const {EncryptedHdNodeProvider, PrivateKeyEncryption, Scrypt} = require("@defichain/jellyfish-wallet-encrypted")
const {generateMnemonicWords} = require("@defichain/jellyfish-wallet-mnemonic")
const {WhaleWalletAccountProvider} = require("@defichain/whale-api-wallet")
const {WhaleApiClient} = require("@defichain/whale-api-client")
const {JellyfishWallet} = require("@defichain/jellyfish-wallet")
const {MainNet} = require("@defichain/jellyfish-network")
const {DeFiAddress} = require("@defichain/jellyfish-address")
const BigNumber = require("bignumber.js")
const {CTransactionSegWit} = require("@defichain/jellyfish-transaction")

const MainNetName = 'mainnet'
const network = MainNet

const bip32Options = {
    bip32: {
        public: network.bip32.publicPrefix,
        private: network.bip32.privatePrefix
    },
    wif: network.wifPrefix
}

const DEFAULT_SCRYPT = {
    N: Math.pow(2, 9),
    r: 8, // decide stress on ram, not to reduce, to remained strong POW
    p: 2 // iteration, directly stack up time (if only purely single thread)
}

const script = new Scrypt(DEFAULT_SCRYPT.N, DEFAULT_SCRYPT.r, DEFAULT_SCRYPT.p)
const encryption = new PrivateKeyEncryption(script, numOfBytes => {
    const bytes = crypto.getRandomValues(new Uint8Array(numOfBytes))
    return Buffer.from(bytes)
})

async function deriveEncryptedKeys(words, password) {
    return await EncryptedHdNodeProvider.wordsToEncryptedData(words, bip32Options, encryption, password)
}

async function createEncryptedWallet(encryptedKeys, passwordPrompt) {
    const walletProvider = EncryptedHdNodeProvider.init(encryptedKeys, bip32Options, encryption, passwordPrompt)

    const client = new WhaleApiClient({ url: 'https://ocean.defichain.com', network: MainNetName, version: 'v0' })
    const accountProvider = new WhaleWalletAccountProvider(client, network)
    return new JellyfishWallet(walletProvider, accountProvider)
}

function getAddressScript(address) {
    return DeFiAddress.from(MainNetName, address).getScript()
}

module.exports = {
    BigNumber,
    CTransactionSegWit,
    getAddressScript,
    createEncryptedWallet,
    deriveEncryptedKeys,
    generateMnemonicPhrase: () => generateMnemonicWords(24)
}
}).call(this)}).call(this,require("buffer").Buffer)
},{"@defichain/jellyfish-address":31,"@defichain/jellyfish-network":77,"@defichain/jellyfish-transaction":94,"@defichain/jellyfish-wallet":133,"@defichain/jellyfish-wallet-encrypted":128,"@defichain/jellyfish-wallet-mnemonic":131,"@defichain/whale-api-client":155,"@defichain/whale-api-wallet":161,"bignumber.js":167,"buffer":3}]},{},[285])(285)
});
